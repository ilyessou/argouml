# $Id$
# Copyright (c) 2004 The Regents of the University of California. All
# Rights Reserved. Permission to use, copy, modify, and distribute this
# software and its documentation without fee, and without a written
# agreement is hereby granted, provided that the above copyright notice
# and this paragraph appear in all copies.  This software program and
# documentation are copyrighted by The Regents of the University of
# California. The software program and documentation are supplied "AS
# IS", without any accompanying services from The Regents. The Regents
# does not warrant that the operation of the program will be
# uninterrupted or error-free. The end-user understands that the program
# was developed for research purposes and is advised not to rely
# exclusively on the program for any reason.  IN NO EVENT SHALL THE
# UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
# SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
# UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
#
# Created from UMLCognitiveResourceBundle_de.java
#
# The keys are generated from the class names of the classes that use them.
#
critics.CrAssocNameConflict-head = L\u00f6sen Sie den Konflikt bei den Assoziationsnamen auf
critics.CrAssocNameConflict-desc = Jedes Element eines Namensraumes mu\u00df einen eindeutigen Namen haben. \n\nEine klare und unzweideutige Namensgebung ist ein Schl\u00fcsselelement f�r die Codegenerierung, die Verst\u00e4ndlichkeit und die Wartbarkeit des Entwurfes. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren die Elemente und \u00e4ndern die Namen im Registerblatt \"Eigenschaften\".

critics.CrAttrNameConflict-head = Um einen Konflikt zu vermeiden, \u00c4ndern Sie den Namen des Attributes.
critics.CrAttrNameConflict-desc = Attribute m\u00fcssen unterschiedliche Namen haben.  Dieses Problem kann auch durch vererbte Attribute entstehen. \n\nKlare und eindeutige Namen sind ein Schl\u00fcsselelement bei der Codegenerierung und beim Erstellen eines verst\u00e4ndlichen und pflegbaren Entwurfes.\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren eines der betroffenen Attribute dieser Klasse und \u00e4ndern seinen Namen.

critics.CrOperNameConflict-head = \u00c4ndern Sie  in \"<ocl>self</ocl>\" Namen oder Signaturen.
critics.CrOperNameConflict-desc = Zwei Methoden haben exakt die gleiche Signatur.  Methoden m\u00fcssen unterschiedliche Signaturen haben. Eine Signatur ist die Kombination eines Namens mit den Parametertypen der Methode. \n\nDas Vermeiden von identischen Signaturen ist ein Schl\u00fcsselelement bei der Codegenerierung und beim Erstellen eines verst\u00e4ndlichen und wartbaren Entwurfes.\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren eine der betroffenen Methoden dieser Klasse und \u00e4ndern deren Namen.

critics.CrCircularAssocClass-head = Schleife bei Assoziation
critics.CrCircularAssocClass-desc = Assoziierte Klassen k\u00f6nnen keine Rolle enthalten, die sich wiederum direkt auf die Klasse bezieht

critics.CrCircularInheritance-head = Entfernen Sie die \"<ocl>self</ocl>\"-zirkulare Vererbung.
critics.CrCircularInheritance-desc = Vererbungsbeziehungen d\u00fcrfen keine Schleifen bilden. \n\nf\u00fcr die Code-Generierung und die Richtigkeit des Entwurfes ist eine zul\u00e4ssige Klassen-Vererbungshierarchie erforderlich. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie w\u00e4hlen manuell einen der Vererbungspfeile in der Schleife aus und entfernen diesen.

critics.CrCircularComposition-head = Entfernen Sie die zirkulare Komposition.
critics.CrCircularComposition-desc = Kompositionsbeziehungen (schwarze Diamanten) d\u00fcrfen keine Schleifen bilden. \n\nF\u00fcr die Code-Generierung und f\u00fcr die Richtigkeit des Entwurfes wird eine zul\u00e4ssige Aggregationshierarchie ben\u00f6tigt. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie w\u00e4hlen manuell eine der Assoziationen in der Schleife aus und entfernen diese.

critics.CrCrossNamespaceAssoc-head = Die Klassifizierung \"<ocl>self</ocl>\" befindet sich nicht im Namensraum dieser Assoziation.
critics.CrCrossNamespaceAssoc-desc = Jede Klasse, jede Schnittstelle oder andere Klassifizierungen (<ocl>self</ocl>), die Teil einer Assoziation ist, sollte sich innerhalb des Namensraumes der Assoziation befinden.\n\nWenn dies nicht der Fall ist, gibt es f�r die Klassen, Schnittstellen oder anderen Klassifizierungen keine M\u00f6glichkeit, die Referenz zu den anderen mit Hilfe der Assoziation zu benennen.\n\nBeachten Sie, da\u00df dieser Hinweis derzeit nicht den hierarchischen Namensraum interpretiert. Er wird ausgel\u00f6st, wenn die abschliessenden Komponenten des Namensraumes unterschiedlich sind, auch wenn sie sich eine gemeinsame Wurzel teilen. Diesen Hinweis sollten Sie in diesem Licht interpretieren.\nZur Problembeseitigung l\u00f6schen Sie die Assoziation und erzeugen Sie diese erneut in einem Diagramm, dessen Namensraum die Klassen, Schnittstellen und Klassifizierungen einschlie\u00dft.

critics.CrDupParamName-head = Der Parametername kommt doppelt vor.
critics.CrDupParamName-desc = Jeder Parameter einer Methode mu\u00df einen eindeutigen Namen haben. \n\nDie klare und unzweideutige Namensgebung ist f�r die Codegenerierung und zum Erreichen eines klaren und wartbaren Entwurfes erforderlich.\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie \u00e4ndern den Namen eines Parameters von Hand.

critics.CrDupRoleNames-head = Duplizieren Sie die Namen der Enden (Rollen) f\u00fcr \"<ocl>self</ocl>\".
critics.CrDupRoleNames-desc = Die Assoziation \"<ocl>self</ocl>\" hat zwei Rollen mit den gleichen Namen. \n\nDie klare und unzweideutige Namensgebung ist ein Schl\u00fcsselelement bei der Codegenerierung, bei der Verst\u00e4ndlichkeit und Wartbarkeit des Entwurfes. \n\nUm dies manuell zu beseitigen, markieren Sie \"<ocl>self</ocl>\" und verwenden Sie das Registerblatt \"Eigenschaften\", um einen oder mehrere der konfliktausl\u00f6senden Rollennamen zu \u00e4ndern.

critics.CrFinalSubclassed-head = Entfernen Sie das  Schl\u00fcsselwort \"Blatt\" oder entfernen Sie die Unterklassen
critics.CrFinalSubclassed-desc = Das Schl\u00fcsselwort \"Blatt\" gibt an, dass eine Klasse keine Unterklassen haben soll. Diese Klasse oder Schnittstelle ist als \"Blatt\" markiert und hat Unterklassen.\n\nEine gut durchdachte Klassenhierachie, die potentielle Erweiterungen transportiert und unterst\u00fctzt, ist ein wichtiger Teil eines verst\u00e4ndlichen und wartbaren Entwurfes.\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren die Klasse von Hand und \u00e4ndern die Basisklasse. Oder, Sie markieren die Basisklasse und benutzen das Registerblatt \"Eigenschaften\", um das Schl\u00fcsselwort \"Blatt\" zu entfernen.

critics.CrIllegalGeneralization-head = Unerlaubte Vererbung
critics.CrIllegalGeneralization-desc = Modell-Elemente k\u00f6nnen nur von Elementen des gleichen Typs erben. \n\nEine g\u00fcltige Vererbungshierachie ist f\u00fcr die Codegenerierung und f\u00fcr die Korrektheit des Entwurfes erforderlich. \n\nZur Problembeseitigung benutzen Sie die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren den Vererbungspfeil und entfernen ihn von Hand.

critics.CrAlreadyRealizes-head = Entfernen Sie die unn\u00f6tige Implementierung von \"<ocl>self</ocl>\"
critics.CrAlreadyRealizes-desc = Die markierte Klasse implementiert bereits indirekt die Schnittstelle {item.extra}. Es gibt keinen Grund, diese nochmals direkt zu implementieren. \n\nEs ist immer eine gute Idee, den Entwurf zu vereinfachen. Sie m\u00f6chten vielleicht dieses \"Zu bearbeiten\"-Element unbearbeitet lassen, wenn Sie es offensichtlich machen wollen, da\u00df die markierte Klasse diese Schnittstelle implementiert.\n\nUm dieses Problem zu beheben, markieren Sie die Implementierung (die punktierte Linie mit der weissen, dreieckigen, Pfeilspitze) und dr\u00fccken die Taste \"Entf\".

critics.CrInterfaceAllPublic-head = Die Methoden in einer Schnittstelle m\u00fcssen \"public\" sein
critics.CrInterfaceAllPublic-desc = Schnittstellen sind dazu gedacht, alle Methoden zu spezifizieren, die von den anderen Klassen implementiert werden m\u00fcssen. Sie m\u00fcssen \"public\" sein. \n\nEine wohldurchdachte Sammlung von Schnittstellen ist ein guter Weg, die denkbaren Erweiterungen eines Klassen-Frameworks zu spezifizieren. \n\nZur Problembeseitigung benutzen Sie die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren die Methoden der Schnittstellen von Hand und benutzen das Registerblatt \"Eigenschaften\", um sie \"public\" zu machen.

critics.CrInterfaceOperOnly-head = Schnittstellen d\u00fcrfen nur Methoden haben
critics.CrInterfaceOperOnly-desc = Schnittstellen sind dazu gedacht, alle Methoden zu spezifizieren, die von den anderen Klassen implementiert werden m\u00fcssen. Sie implementieren diese Methoden nicht selbst und d\u00fcfen keine Attribute haben.\n\nEine wohldurchdachte Sammlung von Schnittstellen ist ein guter Weg, die denkbaren Erweiterungen eines Klassen-Frameworks zu definieren. \n\nZur Problembeseitigung benutzen Sie die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren die Schnittstelle und benutzen das Registerblatt \"Eigenschaften\", um alle Attribute zu entfernen.

critics.CrMultipleAgg-head = Doppelt vorkommende Aggregation
critics.CrMultipleAgg-desc = Nur eine Funktion einer Assoziation kann vom Typ Aggregation oder vom Typ Komposition sein.\n\nEine klare und konsistente Ist-Teil-von-Hierarchie ist ein Schl\u00fcsselelement f\u00fcr einen klaren Entwurf, \nhandhabbarem Objektspeicher und der Implementierung rekursiver Methoden.\nZur Problembeseitigung markieren Sie die Assoziation und setzen einige der \nAggregationen auf \"Keine\".

critics.CrNWayAgg-head = Aggregatfunktion in N-fach Assoziation.
critics.CrNWayAgg-desc = Dreifach- oder Mehrfach-Assoziationen d\u00fcrfen keine Aggregationsenden aufweisen.\n\nEine klare und konsistente Ist-Teil-von-Hierarchie ist ein Schl\u00fcsselelement f\u00fcr einen klaren Entwurf, \nhandhabbarem Objektspeicher und der Implementierung rekursiver Methoden.\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren manuell die Assoziation und \nsetzen alle Aggregatfunktionen auf \"Keine\".

critics.CrNavFromInterface-head = Entfernen Sie die Steuerung aus der Schnittstelle \u00fcber die Assoziation \"<ocl>self</ocl>\"
critics.CrNavFromInterface-desc = Assoziationen, die eine Schnittstelle enthalten, k\u00f6nnen  von der Schnittstelle nicht gesteuert werden. Dies ist so, weil Schnittstellen nur Methodendeklarationen und keine Zeiger auf andere Objekte enthalten k\u00f6nnen.\n\nDieser Teil des Entwurfes sollte ge\u00e4ndert werden, bevor Sie aus diesem Entwurf Code generieren. Wenn Sie den Code generieren, bevor Sie dieses Problem behoben haben, wird der Code nicht mit dem Entwurf \u00fcbereinstimmen.\n\nZur Problembeseitigung markieren Sie die Assoziation und verwenden Sie das Registerblatt \"Eigenschaften\", um alle Assoziationsenden zu markieren, die NICHT mit der Schnittstelle verbunden sind. Entfernen Sie die Eigenschaft \"Steuerbar\" f\u00fcr jedes dieser Enden. \n\nDie Assoziation sollte dann als d\u00fcnne Pfeilspitze auf die Schnittstelle erscheinen.\n\nWARNUNG: Die aktuelle Version von ArgoUML enth\u00e4lt einen bekannten Fehler. Es erzeugt eine Assoziation zwischen einer Klasse und einer Schnittstelle, die entweder in beiden Richtungen steuerbar, oder nur von der Schnittstelle zur Klasse steuerbar ist. Die L\u00f6sung liegt im Entfernen der Eigenschaft \"steuerbar\" aus dem Klassenende der Assoziation und, sofern notwendig, dem Hinzuf\u00fcgen der Eigenschaft \"steuerbar\" zum Schnittstellenende (steuerbar bezieht sich auf die Steuerbarkeit in RICHTUNG des Endes), wenn dieser Hinweis ausgel\u00f6st wird.

critics.CrUnnavigableAssoc-head = Machen Sie \"<ocl>self</ocl>\" steuerbar.
critics.CrUnnavigableAssoc-desc = Die Assoziation \"<ocl>self</ocl>\" ist in keine Richtung steuerbar. Alle Assoziationen sollten mindestens in einer Richtung steuerbar sein.\n\nDie Einstellung der Steuerbarkeit von Assoziationen erlaubt es Ihrem Code auf Daten durch nachfolgenden Zeiger zuzugreifen. \n\nZur Problembeseitigung markieren Sie im Diagramm oder im Navigationsfenster die Assoziation \"<ocl>self</ocl>\", und klicken auf das Registerblatt \"Eigenschaften\". Dann verwenden Sie die unten befindlichen Checkboxen des Eigenschaftsfensters und schalten die Steuerbarkeit ein. 

critics.CrNameConflictAC-head = Der Rollenname widerspricht einem Klassenmerkmal
critics.CrNameConflictAC-desc = Der Rollenname einer Assoziationsklasse darf nicht in Konflikt mit den Namen von Klassenmerkmalen (z.B. Klassenvariablen) stehen.\n

critics.CrMissingClassName-head = W\u00e4hlen Sie einen Namen aus.
critics.CrMissingClassName-desc = Jede Klasse und jede Schnittstelle innerhalb eines Pakets mu\u00df einen Namen haben. \n\nDie klare und unzweideutige Namensgebung ist ein Schl\u00fcsselelement f\u00fcr die Codegenerierung, sowie f\u00fcr die Verst\u00e4ndlichkeit und Wartbarkeit des Entwurfes. \n\nZur Problembeseitigung benutzen Sie die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren die Klasse und benutzen das Registerblatt \"Eigenschaften\", um ihr einen Namen zu geben.

critics.CrMissingAttrName-head = W\u00e4hlen Sie einen Namen aus.
critics.CrMissingAttrName-desc = Jedes Attribut mu\u00df einen Namen haben. \n\nDie klare und unzweideutige Namensgebung ist ein Schl\u00fcsselelement f\u00fcr die Codegenerierung, f\u00fcr die Verst\u00e4ndlichkeit und Wartbarkeit des Entwurfes. \n\nZur Problembeseitigung benutzen Sie die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren das Attribut von Hand und benutzen Sie das Registerblatt \"Eigenschaften\", um ihm einen Namen zu geben

critics.CrMissingOperName-head = W\u00e4hlen Sie einen Namen aus.
critics.CrMissingOperName-desc = Jede Methode mu\u00df einen Namen haben. \n\nDie klare und unzweideutige Namensgebung ist ein Schl\u00fcsselelement f\u00fcr die Codegenerierung, Verst\u00e4ndlichkeit und Wartbarkeit des Entwurfes. \n\nZur Problembeseitigung benutzen Sie die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren die Methode von Hand und benutzen das Registerblatt \"Eigenschaften\", um ihr einen Namen zu geben

critics.CrMissingStateName-head = W\u00e4hlen Sie einen Namen aus.
critics.CrMissingStateName-desc = Jeder Zustand in einem Zustandsautomaten sollte einen Namen haben. \n\nDie klare und unzweideutige Namensgebung ist ein Schl\u00fcsselelement f\u00fcr die Verst\u00e4ndlichkeit und Wartbarkeit des Entwurfes. \n\nZur Problembeseitigung benutzen Sie die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren den Zustand von Hand und benutzen das Registerblatt \"Eigenschaften\", um ihm einen Namen zu geben. Oder, Sie markieren den Zustand und tippen einen Namen ein.

critics.CrNoInstanceVariables-head = F\u00fcgen Sie in \"<ocl>self</ocl>\" Klassenvariablen ein.
critics.CrNoInstanceVariables-desc = Sie haben bis jetzt in \"<ocl>self</ocl>\" noch keine Klassenvariablen spezifiziert. Normalerweise haben Klassen Klassenvariablen, die Zustandsinformationen \u00fcber jede Instanz speichern. Klassen, die nur statische Attribute und Methoden enthalten, sollten das Stereotyp <<utility>> erhalten.\n\nDas Definieren von Klassenvariablen ist erforderlich, um den Informationsteil Ihres Entwurfes zu vervollst\u00e4ndigen. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie f\u00fcgen Klassenvariable durch einen Doppelklick auf \"<ocl>self</ocl>\" im Navigationsfenster hinzu und verwenden das Pop-up-Men\u00fc \"Hinzuf\u00fcgen\", um ein neues Attribut zu erstellen. 

critics.CrNoAssociations-head = F\u00fcgen Sie Assoziationen zu \"<ocl>self</ocl>\" hinzu
critics.CrNoAssociations-desc = Sie haben bis jetzt f\u00fcr \"<ocl>self</ocl>\" keine Assoziationen spezifiziert. Normalerweise sind Klassen, Akteure und Anwendungsf\u00e4lle mit anderen assoziiert. \n\nDas Definieren von Assoziationen zwischen Objekten ist ein wichtiger Teil Ihres Entwurfes. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie f\u00fcgen die Assoziationen von Hand hinzu. Dazu klicken Sie auf das Symbol \"Assoziation\" in der Werkzeugleiste und erzeugen die Assoziationen von und zu \"<ocl>self</ocl>\" per Drag und Drop.

critics.CrNonAggDataType-head = Verpacke Datentyp
critics.CrNonAggDataType-desc = Datentypen sind keine vollst\u00e4ndigen Klassen und d\u00fcrfen nicht mit Klassen assoziiert werden, es sei denn, der Datentyp ist Teil einer Komposition (schwarzer Diamand). \n\nEin gutes OO-Design h\u00e4ngt davon ab, \u00fcber welche Entit\u00e4ten vollst\u00e4ndige Objekte abgebildet, und wie die Attribute von Objekten dargestellt werden.\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie ersetzen den Datentyp von Hand durch eine vollst\u00e4ndige Klasse. Oder, Sie \u00e4ndern die Assoziationsaggregation, um eine vollst\u00e4ndige Klasse zur\u00fcckzuerhalten.\n

critics.CrOppEndConflict-head = Benennen Sie die Assozationsfunktionen um
critics.CrOppEndConflict-desc = In \"<ocl>self</ocl>\" haben zwei Funktionen den gleichen Namen. Funktionen m\u00fcssen unterschiedliche Namen haben.\n\nDie klare und unzweideutige Namensgebung ist ein Schl\u00fcsselelement f\u00fcr die Codegenerierung und f\u00fcr das Erstellen eines verst\u00e4ndlichen und wartbaren Entwurfes.\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren die Funktion am anderen Ende der Assoziation dieser Klasse und \u00e4ndern ihren Namen.

critics.CrParamTypeNotImported-head = Importieren Sie den Parametertyp in die Klasse
critics.CrParamTypeNotImported-desc = Der Typ eines jeden Methodenparameters mu\u00df sichtbar sein und in die Klasse importiert werden, welche die Methode beinhaltet.\n\nDas Importieren von Klassen ist f\u00fcr die Codegenerierung erforderlich. Eine gute Modularisierung von Klassen in Pakete ist ein Schl\u00fcsselelement f\u00fcr einen verst\u00e4ndlichen Entwurf.\n\nZur Problembeseitigung benutzen Sie die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie f\u00fcgen der Klasse, welche die Methode enth\u00e4lt, von Hand eine \"import\"-Anweisung hinzu.

critics.CrUselessAbstract-head = Definieren Sie eine konkrete (Unter-)Klasse
critics.CrUselessAbstract-desc = \"<ocl>self</ocl>\" kann das laufende System niemals beeinflussen, da es selbst und auch keine seiner Unterklassen jemals Instanzen bilden k\u00f6nnen. \n\nProblembeseitigung: (1) Sie definieren konkrete Unterklassen, welche die Schnittstelle der Klasse implementieren; oder (2) Sie konkretisieren \"<ocl>self</ocl>\" oder eine seiner existierenden Unterklassen.

critics.CrUselessInterface-head = Definieren Sie eine Klasse, um \"<ocl>self</ocl>\" zu implementieren
critics.CrUselessInterface-desc = \"<ocl>self</ocl>\" kann niemals verwendet werden, da es keine Klasse implementiert.\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie verwenden zum definieren von Klassen in der Werkzeugleiste die Schaltfl\u00e4che \"Klasse\" und die Schaltfl\u00e4che \"Realisieren\", um eine Beziehung von der Klasse zu der hervorgehobenen Schnittstelle herzustellen.

critics.CrDisambigClassName-head = W\u00e4hlen Sie einen eindeutigen Namen f\u00fcr \"<ocl>self</ocl>\" aus.
critics.CrDisambigClassName-desc = Jede Klasse und jede Schnittstelle innerhalb eines Paketes mu\u00df einen eindeutigen Namen haben. Es gibt mindestens zwei Elemente in diesem Paket mit dem Namen \"<ocl>self</ocl>\".\n\nDie klare und unzweideutige Namensgebung ist ein Schl\u00fcsselelement  f\u00fcr die Codegenerierung, f\u00fcr die Verst\u00e4ndlichkeit und Wartbarkeit des Entwurfes. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren eine der betroffenen Klassen und benutzen das Registerblatt \"Eigenschaften\", um ihren Namen zu \u00e4ndern

critics.CrDisambigStateName-head = W\u00e4hlen Sie einen eindeutigen Namen f\u00fcr \"<ocl>self</ocl>\".
critics.CrDisambigStateName-desc = Jeder Zustand in einer Zustandsmaschine mu\u00df einen eindeutigen Namen haben. Es sind mindestens zwei Zust\u00e4nde in dieser Maschine mit \"<ocl>self</ocl>\" benannt.\n\nDie klare und unzweideutige Benennung ist das Schl\u00fcsselelement f\u00fcr die Codegenerierung, sowie f\u00fcr die Verst\u00e4ndlichkeit und Pflegbarkeit des Entwurfes. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren von Hand einen der konflikttr\u00e4chtigen Zust\u00e4nde und verwenden das Registerblatt \"Eigenschaften\", um den Namen zu \u00e4ndern.

critics.CrConflictingComposites-head = Entfernen Sie die konflikttr\u00e4chtige Komposition
critics.CrConflictingComposites-desc = Die Kompositionsfunktion (schwarzer Diamand) einer Assoziation zeigt, da\u00df Instanzen dieser Klasse Instanzen der assoziierten Klasse enthalten k\u00f6nnen. Da jede Instanz h\u00f6chstens in einem anderen Projekt enthalten sein darf, darf jedes Objekt h\u00f6chstens \"Teil\" einer Ist-Teil-von-Beziehung sein.\n\nGutes OO-Design h\u00e4ngt von der Bildung guter Ist-Teil-von-Beziehungen ab.\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie \u00e4ndern von Hand eine Assoziation, um eine Kardinalit\u00e4t von 0..1 oder 1..1 zu erhalten. Oder, Sie verwenden eine andere Art von Aggregation (z.B.: ist ein wei\u00dfer Diamant weniger streng). Oder, Sie entfernen eine der Assoziationen

critics.CrTooManyAssoc-head = Reduzieren Sie die Assoziationen auf \"<ocl>self</ocl>\"
critics.CrTooManyAssoc-desc = Es gibt zu viele Assoziationen auf die Klasse \"<ocl>self</ocl>\". Immer, wenn eine Klasse im Entwurf zu zentral wird, wird sie zu einem Engpass bei der Pflege und mu\u00df h\u00e4ufig ver\u00e4ndert werden. \n\nDie Definition von Assoziationen zwischen Objekten ist ein wichtiger Teil Ihres Entwurfes. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie entfernen die Assoziationen von Hand durch Anklicken einer Assoziation im Navigationsfenster oder Diagramm und dr\u00fccken der Taste \"Entf\". 

critics.CrTooManyAttr-head = Reduzieren Sie die Anzahl der Attribute in \"<ocl>self</ocl>\"
critics.CrTooManyAttr-desc = In der Klasse \"<ocl>self</ocl>\" gibt es zu viele Attribute.  Immer, wenn eine Klasse im Entwurf zu m\u00e4chtig wird, wird sie zu einem Engpass bei der Pflege und mu\u00df h\u00e4ufig ver\u00e4ndert werden. \n\nDas Definieren von Attributen in Objekten ist ein wichtiger Teil Ihres Entwurfes. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie entfernen Attribute im Diagramm von Hand, durch einen Doppel-Klick auf den Attributbereich der hervorgehobenen Klasse und entfernen der Textzeile des Attributes. 

critics.CrTooManyOper-head = Reduzieren Sie die Anzahl der Methoden in \"<ocl>self</ocl>\".
critics.CrTooManyOper-desc = In der Klasse \"<ocl>self</ocl>\" gibt es zu viele Methoden.  Immer, wenn eine Klasse in Ihrem Entwurf zu m\u00e4chtig wird, wird sie zu einem Pflegeengpass und mu\u00df h\u00e4ufig ver\u00e4ndert werden. \n\nDas Definieren der Objektmethoden ist ein wichtiger Teil Ihres Entwurfes. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie entfernen Methoden im Diagramm von Hand durch einen Doppel-Klick auf den Methodenbereich der hervorgehobenen Klasse und entfernen der Textzeile der Methode. 

critics.CrTooManyStates-head = Reduzieren Sie die Zust\u00e4nde im Zustandsautomaten \"<ocl>self</ocl>\"
critics.CrTooManyStates-desc = Es gibt zu viele Zust\u00e4nde in \"<ocl>self</ocl>\".  Wenn ein Zustandsautomat zu viele Zust\u00e4nde enth\u00e4lt, wird er f\u00fcr Menschen unverst\u00e4ndlich. \n\nDas Definieren eines verst\u00e4ndlichen Satzes von Zust\u00e4nden ist ein wichtiger Teil Ihres Entwurfes. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie entfernen Zust\u00e4nde von Hand durch Anklicken des Zustandes im Navigationsfenster oder im Diagramm und dr\u00fccken der Taste \"Entf\".  Oder, Sie k\u00f6nnen Zust\u00e4nde verschachteln...

critics.CrTooManyTransitions-head = Reduzieren Sie Zustands\u00fcberg\u00e4nge (Transitionen) bei \"<ocl>self</ocl>\"
critics.CrTooManyTransitions-desc = Es gibt zu viele Zustands\u00fcberg\u00e4nge (Transitionen) im Zustand \"<ocl>self</ocl>\". Immer wenn ein Zustand im Zustandsautomaten zu m\u00e4chtig wird, wird er zu einem Pflegeengpass und mu\u00df h\u00e4ufig ver\u00e4ndert werden. \n\nDas Definieren von Zustands\u00fcberg\u00e4nge (Transitionen) zwischen Zust\u00e4nden ist ein wichtiger Teil Ihres Entwurfes. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie entfernen Zustands\u00fcberg\u00e4nge (Transitionen) von Hand durch Anklicken eines Zustands\u00fcberganges im Navigationsfenster oder im Diagramm und dr\u00fccken der Taste \"Entf\". 

critics.CrTooManyClasses-head = Reduzieren Sie die Anzahl der Klassen im Diagramm \"<ocl>self</ocl>\".
critics.CrTooManyClasses-desc = In \"<ocl>self</ocl>\" gibt es zu viele Klassen.  Wenn ein Klassendiagramm zu viele Klassen aufweist, wird es f\u00fcr Menschen unverst\u00e4ndlich. \n\nDas Definieren eines verst\u00e4ndlichen Satzes von Klassendiagrammen ist ein wichtiger Teil Ihres Entwurfes. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie entfernen Klassen von Hand durch das Anklicken einer Klasse im Navigationsfenster oder im Diagramm und dr\u00fccken der Taste \"Entf\".  Oder, Sie k\u00f6nnen ein neues Diagramm erstellen...

critics.CrNoTransitions-head = Zustands\u00fcberg\u00e4nge zu <ocl>self</ocl hinzuf\u00fcgen
critics.CrNoTransitions-desc = Der Zustand \"<ocl>self</ocl>\" hat keine ein- oder ausgehenden Zustands\u00fcberg\u00e4nge. Normalerweise haben Zust\u00e4nde ein- und ausgehende Zustands\u00fcberg\u00e4nge. \n\nDie Definition von vollst\u00e4ndigen Zust\u00e4nden und Zustands\u00fcberg\u00e4ngen ist erforderlich, um das Verhalten Ihres Entwurfs vollst\u00e4ndig zu beschreiben.\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie f\u00fcgen die Zustands\u00fcberg\u00e4nge per Hand hinzu. Dazu klicken Sie auf das Zustands\u00fcbergangssymbol in der Werkzeugleiste und erzeugen die Zustands\u00fcberg\u00e4nge von und zu \"<ocl>self</ocl>\" per Drag und Drop.

critics.CrNoIncomingTransitions-head = Kommende Zustands\u00fcberg\u00e4nge zu \"<ocl>self</ocl>\" hinzuf\u00fcgen.
critics.CrNoIncomingTransitions-desc = Zustand \"<ocl>self</ocl>\" hat keinen kommende Zustands\u00fcbergang. Normalerweise haben Zust\u00e4nde kommende und gehende Zustands\u00fcberg\u00e4nge. \n\nDas Definieren vollst\u00e4ndiger Zustands\u00fcberg\u00e4nge wird f\u00fcr die Spezifikation des Verhaltens Ihres Entwurfes ben\u00f6tigt. Ohne kommenden Zustands\u00fcbergang kann dieser Zustand niemals erreicht werden.\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie f\u00fcgen Transitionen von Hand durch Anklicken des Transitionswerkzeuges in der Werkzeugleiste und ziehen von einem anderen Zustand zu \"<ocl>self</ocl>\" hinzu. 

critics.CrNoOutgoingTransitions-head = Gehende Zustands\u00fcberg\u00e4nge zu \"<ocl>self</ocl>\" hinzuf\u00fcgen.
critics.CrNoOutgoingTransitions-desc = Der Zustand \"<ocl>self</ocl>\" hat keine gehende Zustands\u00fcberg\u00e4nge (Transitionen). Normalerweise haben Zust\u00e4nde kommende und gehende Zustands\u00fcberg\u00e4nge (Transitionen). \n\nDas Definieren vollst\u00e4ndiger Transitionen wird f\u00fcr die Spezifikation des Verhaltens Ihres Entwurfes ben\u00f6tigt. Ohne gehende Transition ist dieser Zustand ein \"toter\" Zustand, der niemals verlassen werden kann.\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie f\u00fcgen Transitionen von Hand durch Anklicken des Transitionswerkzeuges in der Werkzeugleiste und ziehen von einem anderen Zustand zu \"<ocl>self</ocl>\" hinzu. 

critics.CrMultipleInitialStates-head = Entfernen Sie zus\u00e4tzliche Anfangszust\u00e4nde
critics.CrMultipleInitialStates-desc = Es gibt mehrere, mehrdeutige Anfangszust\u00e4nde in diesem Zustandsautomaten. Normalerweise hat jeder Zustandsautomat oder jede Komposition einen Anfangszustand. \n\nDas Definieren eindeutiger Zust\u00e4nde wird ben\u00f6tigt, um die Spezifikation des Verhaltens Ihres Entwurfes zu vervollst\u00e4ndigen.\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren von Hand einen der zus\u00e4tzlichen Anfangszust\u00e4nd und entfernen ihn. 

critics.CrNoInitialState-head = F\u00fcgen Sie einen Anfangszustand hinzu
critics.CrNoInitialState-desc = In diesem Zustandsautomaten oder in dieser Komposition gibt es keinen Anfangszustand. Normalerweise hat jeder Zustandsautomat oder jede Komposition einen Anfangszustand. \n\nDas Definieren eindeutiger Zust\u00e4nde wird ben\u00f6tigt, um das Verhalten Ihres Entwurfes zu spezifizieren.\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie f\u00fcgen einen Anfangszustand von Hand aus der Werkzeugleiste ein und plazieren diesen im Diagramm. 

critics.CrNoTriggerOrGuard-head = Dem Zustands\u00fcbergang ein Signal oder einen W\u00e4chter hinzuf\u00fcgen.
critics.CrNoTriggerOrGuard-desc = Der hervorgehobene Zustands\u00fcbergang (Transition) ist unvollst\u00e4ndig, weil er kein Signal- oder keinen W\u00e4chter aufweist.  Signale sind Ereignisse, die einen Zustands\u00fcbergang ausl\u00f6sen.  W\u00e4chter m\u00fcssen f\u00fcr den Zustands\u00fcbergang wahr sein, damit er ausgef\u00fchrt werden kann.  Wird nur ein W\u00e4chter verwendet, wird der Zustands\u00fcbergang ausgel\u00f6st, wenn die die Bedingung wahr wird.\n\nDieses Problem mu\u00df gel\u00f6st werden, um den Zustandsautomaten zu vervollst\u00e4ndigen.\n\nZur Problembeseitigung markieren Sie den Zustands\u00fcbergang und verwenden das Registerblatt \"Eigenschaften\". Oder, Sie markieren den Zustands\u00fcbergang und geben den folgenden Text ein:\nTRIGGER [GUARD] / ACTION\nDabei ist TRIGGER ein Ereignisname, GUARD ein Ausdruck vom Typ boolean und ACTION eine Aktion, die ausgef\u00fchrt wird, wenn die Transition ausgel\u00f6st wurde.  Alle drei Teile sind optional.

critics.CrNoGuard-head = F\u00fcgen Sie dem Zustands\u00fcbergang einen W\u00e4chter hinzu
critics.CrNoGuard-desc = Der hervorgehobene Zustands\u00fcbergang (Transition) ist unvollst\u00e4ndig, weil er keinen W\u00e4chter aufweist.  W\u00e4chter-Bedingungen m\u00fcssen erf\u00fcllt sein, bevor der Zustands\u00fcbergang erfolgen kann.  Wenn nur ein W\u00e4chter verwendet wird, erfolgt der Zustands\u00fcbergang, wenn die Bedingung wahr wird.\n\nDieses Problem mu\u00df gel\u00f6st werden, um den Zustandsautomaten zu vervollst\u00e4ndigen.\n\nZur Problembeseitigung markieren Sie den Zustands\u00fcbergang und verwenden das Registerblatt \"Eigenschaften\". Oder, Sie markieren den Zustands\u00fcbergang und geben den folgenden Text ein:\nGUARD\nDabei ist GUARD ein Ausdruck vom Typ \"boolean\".

critics.CrInvalidFork-head = \u00c4ndere Verzweigungs-Zustands\u00fcberg\u00e4nge
critics.CrInvalidFork-desc = Dieser Verzweigungszustand weist eine ung\u00fcltige Anzahl von Zustands\u00fcberg\u00e4ngen auf. Normalerweise haben Verzweigungszust\u00e4nde einen kommenden und zwei oder mehrere gehende Zustands\u00fcberg\u00e4nge. \n\nDas Definieren korrekter Zustands\u00fcberg\u00e4nge wird ben\u00f6tigt, um das Verhalten Ihres Entwurfes zu vervollst\u00e4ndigen. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie entfernen Zustands\u00fcberg\u00e4nge von Hand durch Anklicken des Zustands\u00fcberganges im Diagramm und dr\u00fccken der Taste \"Entf\". 

critics.CrInvalidJoin-head = \u00c4ndere Verkn\u00fcpfungs-Zustands\u00fcberg\u00e4nge
critics.CrInvalidJoin-desc = Dieser Verkn\u00fcpfungs-Zustand weist eine ung\u00fcltige Anzahl von Zustands\u00fcberg\u00e4ngen auf. Normalerweise haben Verkn\u00fcpfungszust\u00e4nde zwei oder mehrere kommende und einen gehenden Zustands\u00fcbergang. \n\nDas Definieren korrekter Zustands\u00fcberg\u00e4nge wird ben\u00f6tigt, um das Verhalten Ihres Entwurfes zu vervollst\u00e4ndigen. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie entfernen Zustands\u00fcberg\u00e4nge von Hand durch Anklicken des Zustands\u00fcberganges im Diagramm und dr\u00fccken der Taste \"Entf\". 

critics.CrInvalidBranch-head = \u00c4ndere Verzweigungs-Zustands\u00fcberg\u00e4nge
critics.CrInvalidBranch-desc = Dieser Verzweigungszustand weist eine ung\u00fcltige Anzahl von Zustands\u00fcberg\u00e4ngen auf. Normalerweise haben Verzweigungszust\u00e4nde einen kommenden und zwei oder mehrere gehende Zustands\u00fcberg\u00e4nge. \n\nDas Definieren korrekter Zustands\u00fcberg\u00e4nge wird ben\u00f6tigt, um das Verhalten Ihres Entwurfes zu vervollst\u00e4ndigen. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie entfernen Zustands\u00fcberg\u00e4nge von Hand durch Anklicken des Zustands\u00fcberganges im Diagramm und dr\u00fccken der Taste \"Entf\". Oder, Sie f\u00fcgen Zustands\u00fcberg\u00e4nge mit dem Werkzeug Zustands\u00fcberg\u00e4nge hinzu. 

critics.CrEmptyPackage-head = F\u00fcgen Sie dem Paket \"<ocl>self</ocl>\" Elemente hinzu
critics.CrEmptyPackage-desc = Sie haben bis jetzt noch keine Elemente in das Paket \"<ocl>self</ocl>\" eingef\u00fcgt. Normalerweise enthalten Pakete Gruppen zusammengeh\u00f6render Klassen.\n\nDas Definieren und Verwenden von Paketen ist ein Schl\u00fcsselelement beim Erstellen eines pflegbaren Entwurfes. \n\nUm dieses Problem zu l\u00f6sen, markieren Sie im Navigationsfenster das Paket \"<ocl>self</ocl>\" und f\u00fcgen Diagramme oder Modellelemente, wie Klassen oder Anwendungsf\u00e4lle hinzu. 

critics.CrNoOperations-head = Definieren Sie Methoden f\u00fcr die Klasse \"<ocl>self</ocl>\".
critics.CrNoOperations-desc = Sie haben bis jetzt keine Methoden f\u00fcr \"<ocl>self</ocl>\" spezifiziert. Normalerweise enthalten Klassen Methoden, die deren Verhalten definieren.\n\nDas Definieren von Methoden wird ben\u00f6tigt, um das Verhalten Ihres Entwurfes zu vervollst\u00e4ndigen. \n\nZur Problembeseitigung dr\u00fccken Sie die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie f\u00fcgen Methoden von Hand durch Klicken auf \"<ocl>self</ocl>\" im Navigationsfenster und verwenden des Pop-up-Men\u00fcs \"Hinzuf\u00fcgen\" hinzu.

critics.CrConstructorNeeded-head = Definieren Sie einen Konstruktor f\u00fcr die Klasse \"<ocl>self</ocl>\".
critics.CrConstructorNeeded-desc = Sie haben bis jetzt keinen Konstruktor f\u00fcr die Klasse \"<ocl>self</ocl>\" definiert. Konstruktoren initialisieren neue Instanzen, soda\u00df ihre Attribute g\u00fcltige Werte aufweisen. Diese Klasse ben\u00f6tigt wahrscheinlich einen Konstruktor, weil nicht alle seine Attribute Anfangswerte aufweisen. \n\nDas Definieren guter Konstruktoren ist der Schl\u00fcssel f\u00fcr die Etablierung unver\u00e4nderlicher Klasseninstanzen. Unver\u00e4nderliche Klasseninstanzen sind eine gro\u00dfe Hilfe beim Schreiben stabilen Codes. \n\nZur Problembeseitigung dr\u00fccken Sie die Schaltfl\u00e4che \"N\u00e4chstes >>\" und f\u00fcgen einen Konstruktor mit Hilfe des kontextsensitiven Pop-Up-Men\u00fcs des Registerblattes \"Eigenschaften\" hinzu. Oder, Sie markieren im Klassendiagramm \"<ocl>self</ocl>\" und verwenden den Men\u00fcpunkt \"Methode hinzuf\u00fcgen\".\n\nEin Konstruktor ist eine Methode mit dem Stereotypen <<create>>.\n\nEin Konstruktor hat per Konvention (Java, C++) den gleichen Namen wie die Klasse, ist nicht statisch und gibt keinen R\u00fcckgabewert zur\u00fcck (das bedeutet, Sie m�ssen den return-Parameter, den ArgoUML standardm\u00e4ssig hinzuf\u00fcgt, entfernen). ArgoUML wird jede Methode akzeptieren, die diesen Konventionen folgt, auch wenn er nicht den Sterotyp <<create>> aufweist.

critics.CrNameConfusion-head = \u00c4ndern Sie den Namen um Verwirrung zu vermeiden
critics.CrNameConfusion-desc = Namen sollten klar voneinander unterschieden werden k\u00f6nnen. Diese beiden Namen sind so \u00e4hnlich, da\u00df andere Leser verwirrt sein k\u00f6nnten.\n\nEine klare und eindeutige Namensvergabe ist ein Schl\u00fcsselelement f\u00fcr die Code-Generierung und f\u00fcr die Verst\u00e4ndlichkeit und Pflegbarkeit des Entwurfes. \n\nZur Problembeseitigung verwenden Sie die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren die Elemente von Hand und verwenden das Registerblatt \"Eigenschaften\", um deren Namen zu \u00e4ndern. Vermeiden Sie Namen, die sich von anderen nur durch Gro\u00df-/Kleinschreibung, den Gebrauch von Unterstrichen, oder nur durch ein Zeichen unterscheiden.

critics.CrMergeClasses-head = Sie sollten erw\u00e4gen, die Klassen zusammenzufassen
critics.CrMergeClasses-desc = Die hervorgehobene Klasse \"<ocl>self</ocl>\" nimmt nur an einer Assoziation teil. Und diese Assoziation ist eins-zu-eins mit einer anderen Klasse verbunden.  Da Instanzen dieser beiden Klassen immer gemeinsam erzeugt und gel\u00f6scht werden m\u00fcssen, k\u00f6nnte das Kombinieren dieser Klassen Ihren Entwurf vereinfachen, ohne an Klarheit zu verlieren.  Sie k\u00f6nnten jedoch die kombinierte Klasse als zu gro\u00df und zu komplex empfinden. In diesem Fall ist die Trennung wahrscheinlich besser.\n\nDie Organisation von Klassen zum Managen der Komplexit\u00e4t des Entwurfes ist immer wichtig. Speziell dann, wenn das Design bereits komplex ist. \n\nUm dieses Problem zu l\u00f6sen, klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\", oder f\u00fcgen Sie die Attribute und Methoden der hervorgehobenen Klasse manuell der anderen Klasse hinzu. Dann entfernen Sie die hervorgehobene Klasse aus dem Projekt. 

critics.CrSubclassReference-head = Entfernen Sie die Referenz auf die spezielle Unterklasse
critics.CrSubclassReference-desc = Die Klasse \"<ocl>self</ocl>\" hat eine Referenz auf eine seiner Unterklassen. Normalerweise sollten alle Unterklassen durch Ihre Superklasse \"gleich\" behandelt werden.  Dieses erlaubt das Hinzuf\u00fcgen von Unterklassen ohne Ver\u00e4nderung der Superklasse. \n\nDas Definieren von Assoziationen zwischen Objekten ist ein wichtiger Teil Ihres Entwurfes. Einige Assoziationensmuster sind leichter zu handhaben als andere, je nach Art der k\u00fcnftigen \u00c4nderungen. \n\nZur Problembeseitigung dr\u00fccken Sie die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie entfernen die Assoziation von Hand durch Anklicken im Diagramm und dr\u00fccken der Taste \"Entf\". 

critics.CrComponentWithoutNode-head = Komponenten befinden sich normalerweise innerhalb von Knoten
critics.CrComponentWithoutNode-desc = Es gibt Knoten im Diagramm. So haben Sie ein reelles\n Verteilungsdiagramm erhalten. In Verteilungsdiagrammen befinden sich Komponenten\n normalerweise innerhalb von Knoten.

critics.CrCompInstanceWithoutNode-head = Instanzen von Komponenten befinden sich normalerweise innerhalb von Knoten
critics.CrCompInstanceWithoutNode-desc = Es gibt Knoten-Instanzen im Diagramm. So haben Sie ein reelles\n Verteilungsdiagramm erhalten. In Verteilungsdiagrammen befinden sich Komponenten\n normalerweise innerhalb Knoten-Instanzen.

critics.CrClassWithoutComponent-head = Klassen befinden sich normalerweise innerhalb von Komponenten
critics.CrClassWithoutComponent-desc = In Verteilungsdiagrammen befinden sich Klassen normalerweise innerhalb von Komponenten

critics.CrInterfaceWithoutComponent-head = Schnittstellen befinden sich normalerweise innerhalb von Komponenten
critics.CrInterfaceWithoutComponent-desc = In Verteilungsdiagrammen befinden sich Schnittstellen normalerweise innerhalb von Komponenten

critics.CrObjectWithoutComponent-head = Objekte befinden sich normalerweise innerhalb von Komponenten
critics.CrObjectWithoutComponent-desc = In Verteilungsdiagrammen befinden sich Objekte normalerweise innerhalb von Komponenten oder Instanzen von Komponenten

critics.CrNodeInsideElement-head = Knoten haben normalerweise keine Begrenzungen
critics.CrNodeInsideElement-desc = Knoten befinden sich normalerweise nicht innerhalb anderer Elemente. Sie sind zur Laufzeit physische Objekte mit einem Verarbeitungsteil, haben mindestens einen Speicher und oft auch Verarbeitungsf\u00e4higkeiten.

critics.CrNodeInstanceInsideElement-head = Knoten-Instanzen haben normalerweise keine Begrenzungen
critics.CrNodeInstanceInsideElement-desc = Knoten-Instanzen befinden sich normalerweise nicht innerhalb anderer Elemente. Sie sind zur Laufzeit physische Objekte mit einem Verarbeitungsteil, haben mindestens einen Speicher und oft auch Verarbeitungsf\u00e4higkeiten.

critics.CrWrongLinkEnds-head = Die Enden der Verbindungen haben nicht die gleichen Positionen.
critics.CrWrongLinkEnds-desc = In Verteilungsdiagrammen k\u00f6nnen sich Objekte entweder in Komponenten\n oder in Komponenten-Instanzen befinden. Daher ist es nicht m\u00f6glich, zwei Objekte zu haben, die \u00fcber einen Link verbunden sind, w\u00e4hrend ein sich ein Objekt in einer Komponente und \n das andere Objekt in einer Komponenten-Instanz befindet.\n\n\nZur Problembeseitigung entfernen Sie eines der beiden verbundenen Objekte an dieser Stelle und verbinden Sie es mit einem Element, welches den gleichen Typ aufweist wie das andere Objekt.

critics.CrInstanceWithoutClassifier-head = Setze Klassifizierung.
critics.CrInstanceWithoutClassifier-desc = Instanzen haben eine Klassifizierung.

critics.CrCallWithoutReturn-head = Vermisse return-Aktionen
critics.CrCallWithoutReturn-desc = Jede call- oder send-Aktion erfordert eine return-Aktion.\n Aber diese Verbindung hat keine return-Aktion.\n

critics.CrReturnWithoutCall-head = Vermisse call(send)-Aktion
critics.CrReturnWithoutCall-desc = Jede return-Aktion erfordert eine call- oder send-Aktion.\n Aber diese Verbindung hat keine entsprechende call- or send-Aktion.\n

critics.CrLinkWithoutStimulus-head = Es gibt keine Botschaften f\u00fcr diese Verbindungen
critics.CrLinkWithoutStimulus-desc = In einem Sequenzdiagramm sendet ein Senderobjekt Botschaften\n an ein empfangendes Objekt oder eine empfangende Verbindung. Der Link ist nur die Kommunikationsverbindung, soda\u00df eine Botschaft ben\u00f6tigt wird. 

critics.CrSeqInstanceWithoutClassifier-head = Setze Klassifizierung.
critics.CrSeqInstanceWithoutClassifier-desc = Instanzen haben eine Klassifizierung.

critics.CrStimulusWithWrongPosition-head = Falsche Position dieser Botschaft
critics.CrStimulusWithWrongPosition-desc = In Sequenzdiagrammen ist die Senderseite der Kommunikationsverbindung dieser Botschaft mit dem Beginn einer Aktivit\u00e4t verbunden. Um ein Sender sein zu k\u00f6nnen, mu\u00df ein Objekt zuerst den Fokus erhalten.

critics.CrUnconventionalOperName-head = W\u00e4hlen Sie f\u00fcr diese Methode einen besseren Namen.
critics.CrUnconventionalOperName-desc = Normalerweise beginnen die Namen von Methoden mit einem Kleinbuchstaben. Der Name \"<ocl>self</ocl>\" ist ungew\u00f6hnlich, da er nicht mit einem Kleinbuchstaben beginnt.\n\nDas Einhalten von sinnvollen Konventionen zur Namensgebung hilft, die Verst\u00e4ndlichkeit und Wartbarkeit des Entwurfs zu verbessern. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren \"<ocl>self</ocl>\" von Hand und benutzen das Registerblatt \"Eigenschaften\", um einen anderen Namen zu vergeben.

critics.CrUnconventionalAttrName-head = W\u00e4hlen Sie f\u00fcr das Attribut einen besseren Namen.
critics.CrUnconventionalAttrName-desc = Normalerweise beginnen Namen von Attributen mit einem Kleinbuchstaben. Der Name \"<ocl>self</ocl>\" ist ungew\u00f6hnlich, da es nicht mit einem Kleinbuchstaben beginnt.\n\nDas Einhalten von sinnvollen Konventionen zur Namensgebung hilft, die Verst\u00e4ndlichkeit und Wartbarkeit des Entwurfs zu verbessern. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren \"<ocl>self</ocl>\" von Hand und benutzen das Registerblatt \"Eigenschaften\" um einen anderen Namen zu vergeben.

critics.CrUnconventionalClassName-head = Beginnen Sie den Klassennamen \"<ocl>self</ocl>\" mit einem Gro\u00dfbuchstaben.
critics.CrUnconventionalClassName-desc = Normalerweise beginnen Klassennamen mit einem Gro\u00dfbuchstaben. Der Name \"<ocl>self</ocl>\" ist ungew\u00f6hnlich, da er nicht mit einem Gro\u00dfbuchstaben beginnt.\n\nDas Einhalten von sinnvollen Konventionen zur Namensgebung hilft, die Verst\u00e4ndlichkeit und Wartbarkeit des Entwurfs zu verbessern. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren \"<ocl>self</ocl>\" von Hand und benutzen das Registerblatt \"Eigenschaften\", um einen anderen Namen zu vergeben.

critics.CrUnconventionalPackName-head = W\u00e4hlen Sie f\u00fcr \"<ocl>self</ocl>\" einen anderen Paketnamen 
critics.CrUnconventionalPackName-desc = Normalerweise werden Paketnamen durchg\u00e4ngig klein geschrieben. Mit Punkten werden \"geschachtelte\" Pakete dargestellt. Der Name \"<ocl>self</ocl>\" ist ungew\u00f6hnlich, da er nicht aus kleinen Buchstaben und Punkten besteht.\n\nDas Einhalten von sinnvollen Konventionen zur Namensgebung hilft die Verst\u00e4ndlichkeit und Wartbarkeit des Entwurfs zu verbessern. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren \"<ocl>self</ocl>\" und benutzen das Registerblatt \"Eigenschaften\", um einen anderen Namen zu vergeben.

critics.CrClassMustBeAbstract-head = Die Klasse mu\u00df abstrakt sein
critics.CrClassMustBeAbstract-desc = Klassen, die abstrakte Methoden von Basisklassen oder Schnittstellen enthalten oder vererben, m\u00fcssen als abstrakt gekennzeichnet werden.\n\nDie Entscheidung, welche Klassen abstrakt oder konkret sind, ist ein Schl\u00fcsselelement f\u00fcr den Entwurf der Klassenhierarchie.\n\nZur Problembeseitigung verwenden Sie die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren die Klasse von Hand und verwenden das Registerblatt \"Eigenschaften\", um das Schl\u00fcsselwort \"abstract\" hinzuzuf\u00fcgen. Oder, Sie \u00fcberschreiben jede abstrakte Methode, die von der Basisklasse oder der Schnittstelle vererbt wurde.

critics.CrReservedName-head = \u00c4ndern Sie \"<ocl>self</ocl>\" in ein nicht reserviertes Wort
critics.CrReservedName-desc = \"<ocl>self</ocl>\" ist ein reserviertes Wort, oder einem reservierten Wort sehr \u00e4hnlich. Die Namen von Modellelementen d\u00fcrfen nicht mit reservierten W\u00f6rtern aus Programmiersprachen oder der UML in Konflikt stehen.\n\nDie Verwendung legaler Namen wird ben\u00f6tigt, um kompatiblen Code generieren zu k\u00f6nnen. \n\nZur Problembeseitigung verwenden Sie die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren das hervorgehobene Element von Hand und verwenden das Registerblatt \"Eigenschaften\", um einen unterscheidbaren Namen einzugeben.

critics.CrMultipleInheritance-head = \u00c4ndern Sie Mehrfachvererbungen in Schnittstellen
critics.CrMultipleInheritance-desc = \"<ocl>self</ocl>\" hat mehrere Basisklassen. Java unterst\u00fctzt aber keine Mehrfachvererbung. Sie m\u00fcssen stattdessen Schnittstellen benutzen. \n\nDiese \u00c4nderung ist erforderlich, bevor Sie Java Code generieren k\u00f6nnen.\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie entfernen (1) eine der Basisklassen von Hand, und (2) definieren optional eine neue Schnittstelle mit den selben Methodendeklarationen und (3) f\u00fcgen diese als Schnittstelle von \"<ocl>self</ocl>\" hinzu, und (4) verschieben Sie die Methodenr\u00fcmpfe der alten Basisklasse nach unten in \"<ocl>self</ocl>\".

critics.CrMultipleRealization-head = \u00c4ndern Sie die Mehrfach-Realisierung in <ocl>self</ocl> in eine Vererbungsbeziehung.
critics.CrMultipleRealization-desc = <ocl>self</ocl> implementiert mehrere Schnittstellen. Obwohl dies in UML legal ist, wird dieser Code nicht in Java \u00fcbersetzt werden k�nnen. Ersetzen Sie die Mehrfach-Realisierung durch Vererbungen, wenn Sie kompatiblen und fehlerfreien Code erzeugen wollen.

critics.CrIllegalName-head = W\u00e4hlen Sie einen erlaubten Namen f\u00fcr \"<ocl>self</ocl>\"
critics.CrIllegalName-desc = Die Namen von Modellelementen m\u00fcssen aus Folgen von Buchstaben, Ziffern und Unterstrichen bestehen. Sie d\u00fcrfen keine Satzzeichen enthalten.\n\nZur Generierung von \u00fcbersetzbarem Code sind g\u00fcltige Namen erforderlich. \n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren das hervorgehobene Element und verwenden das Registerblatt \"Eigenschaften\", um einen anderen Namen zu vergeben.

critics.CrUtilityViolated-head = Das Sterotyp <<utility>> wurde verletzt, Instanzen k\u00f6nnen erzeugt werden.
critics.CrUtilityViolated-desc = <ocl>self</ocl> wurde mit dem Stereotyp <<utility>> gekennzeichnet, aber sie stimmt nicht mit den f\u00fcr <<utility>> geltenden Restriktionen \u00fcberein.\nSie enth\u00e4lt Instanz-Attribute oder -Variablen.\n\nWenn Sie wollen, da\u00df diese Klasse nicht l�nger ein <<utility>> ist, entfernen Sie das Stereotyp <<utility>>, indem Sie auf die Klasse klicken und im Registerblatt \"Eigenschaften\" die leere Auswahl in der Stereotyp-Drop-Down-Liste markieren.\n

critics.CrConsiderSingleton-head = Sie sollten dar\u00fcber nachdenken, f\u00fcr \"<ocl>self</ocl>\" das \"Singleton\"-Entwurfsmuster zu verwenden.
critics.CrConsiderSingleton-desc = Diese Klasse hat weder nicht-statische Attribute noch irgendwelche Assoziationen, die von Instanzen dieser Klasse ferngesteuert werden k\u00f6nnen. Das bedeutet, da\u00df jede Instanz dieser Klasse mit jeder anderen Instanz \u00fcbereinstimmen wird (gleich sein), da es nichts \u00fcber die Instanzen geben wird, die sie von anderen Unterscheidbar macht.\n\nUnter diesen Umst\u00e4nden sollten Sie dar\u00fcber nachdenken, da\u00df Sie genau eine Instanz dieser Klasse haben und dies mit Hilfe des \"Singleton\"-Musters ausdr\u00fccklich festlegen sollten. Die Verwendung des \"Singleton\"-Entwurfsmusters kann Zeit und Speicherplatz sparen. In ArgoUML k\u00f6nnen Sie dies erreichen, indem Sie das Stereotyp <<singleton>> f\u00fcr diese Klasse verwenden.\n\nWenn Sie nicht nur eine einzige Instanz haben wollen, sollten Sie Instanzvariablen (z.B. nicht-statische Attribute) und/oder gehende Assoziationen definieren, welche die Unterschiede zwischen den Instanzen repr\u00e4sentieren.\n\nWenn Sie \"<ocl>self</ocl>\" als Singleton spezifiziert haben, m\u00fcssen Sie die Klasse so definieren, da\u00df es nur eine einzige Instanz geben kann. Dies vervollst\u00e4ndigt den Informationsteil Ihres Entwurfes. Um dies zu erreichen, m\u00fcssen Sie folgendes tun.\n\n1. Ein statisches Attribut (eine Klassenvariable) definieren, welches die Instanz aufnimmt. Dieses mu\u00df daher den Typ \"<ocl>self</ocl>\" aufweisen.\n\n2. Erlauben Sie in \"<ocl>self</ocl>\" nur private Konstruktoren, damit von anderem Code keine neuen Instanzen erzeugt werden k\u00f6nnen. Die Erzeugung der einzelnen Instanz k\u00f6nnte durch eine geeignete Hilfs-Operation erfolgen, die diesen privaten Konstruktor genau einmal aufruft.\n\n3. Sorgen Sie daf\u00fcr, da\u00df mindestens ein Konstruktor den Standard-Konstruktor \u00fcberschreibt, soda\u00df der Standardkonstruktor nicht dazu verwendet werden kann, mehrere Instanzen zu erzeugen.\n\nIn Java und C++ haben Konstruktoren per Konvention die gleichen Namen wie die Klasse, sind nicht statisch und geben keinen R\u00fcckgabewert zur\u00fcck. Beachten Sie, da\u00df dies in ArgoUML bedeutet, da\u00df Sie den standardm\u00e4ssig f\u00fcr eine Methode erzeugten R\u00fcckgabewert entfernen m\u00fcssen. ArgoUML wird jede Methode akzeptieren, die diesen Konventionen eines Konstruktors folgen, auch wenn sie nicht mit dem Sterotyp <<create>> oder <<Create>> versehen wurde.

critics.CrSingletonViolatedMissingStaticAttr-head = Sterotyp \"Singleton\" verletzt. In \"<ocl>self</ocl>\" wird ein statisches Attribut vermisst.
critics.CrSingletonViolatedMissingStaticAttr-desc = \"<ocl>self</ocl>\" wurde mit dem Stereotyp <<singleton>> gekennzeichnet, aber es erf\u00fcllt nicht die f�r \"Singletons\" geltenden Restriktionen. \nSie hat kein statisches Attribut (eine Klassenvariable), welches die die Instanz aufnimmt.\n\nImmer, wenn Sie eine Klasse mit einem Stereotypen kennzeichnen, sollte die Klasse allen Restriktionen dieses Stereotyps entsprechen. Dies ist ein wichtiger Teil bei der Erstellung eines in-sich-konsistenten und verst\u00e4ndlichen Entwurfes. Die Verwendung von \"Singleton\"-Entwurfsmustern kann Zeit und Speicherplatz sparen.\n\nWenn Sie nicht l\u00e4nger wollen, da\u00df diese Klasse ein \"Singleton\" ist, entfernen Sie das Stereotyp <<singleton>>, indem Sie auf die Klasse klicken und im Registerblatt \"Eigenschaften\" die leere Auswahl in der Stereotypen-Drop-Down-Liste markieren.\n

critics.CrSingletonViolatedOnlyPrivateConstructors-head = Stereotyp \"Singleton\" verletzt, \"<ocl>self</ocl>\" enth\u00e4lt Konstruktor, der nicht mit \"private\" gekennzeichnet ist.
critics.CrSingletonViolatedOnlyPrivateConstructors-desc = \"<ocl>self</ocl>\" wurde mit dem Stereotyp <<singleton>> gekennzeichnet, aber es erf\u00fcllt nicht die f�r \"Singletons\" geltenden Restriktionen. \nSie darf nur mit \"private\" gekennzeichnete Konstruktoren aufweisen, damit neue Instanzen nicht durch anderen Code erzeugt werden kann.\n\nImmer, wenn Sie eine Klasse mit einem Stereotypen kennzeichnen, sollte die Klasse allen Restriktionen dieses Stereotyps entsprechen. Dies ist ein wichtiger Teil bei der Erstellung eines in-sich-konsistenten und verst\u00e4ndlichen Entwurfes. Die Verwendung von \"Singleton\"-Entwurfsmustern kann Zeit und Speicherplatz sparen.\n\nWenn Sie nicht l\u00e4nger wollen, da\u00df diese Klasse ein \"Singleton\" ist, entfernen Sie das Stereotyp <<singleton>>, indem Sie auf die Klasse klicken und im Registerblatt \"Eigenschaften\" die leere Auswahl in der Stereotypen-Drop-Down-Liste markieren.\n

critics.CrNodesOverlap-head = Diagramm \"<ocl>self</ocl>\" aufr\u00e4umen
critics.CrNodesOverlap-desc = Einige Objekte in diesem Diagramm \u00fcberlappen und verdecken andere Objekte. Dies kann wichtige Informationen verdecken und es f\u00fcr Menschen schwer verst\u00e4ndlich machen.  Eine ordentliche Erscheinung macht Ihr Diagramm auch f\u00fcr andere Designer, Implementierer und Entscheidungstr\u00e4ger wirkungsvoller. \n\nDas Konstruieren eines verst\u00e4ndlichen Satzes von Klassendiagrammen ist ein wichtiger Teil Ihres Entwurfes.  \n\nUm dieses Problem zu beheben, verschieben Sie die hervorgehobenen Knoten im Diagramm.

critics.CrZeroLengthEdge-head = Ecke sichtbar machen
critics.CrZeroLengthEdge-desc = Diese Ecke ist zu klein, um leicht gesehen zu werden. Dies kann wichtige Informationen verdecken und es f\u00fcr Menschen schwer verst\u00e4ndlich machen. Eine ordentliche Erscheinung macht Ihr Diagramm auch f\u00fcr andere Designer, Implementierer und Entscheidungstr\u00e4ger wirkungsvoller. \n\nDas Konstruieren eines verst\u00e4ndlichen Satzes von Diagrammen ist ein wichtiger Teil Ihres Entwurfes.  \n\nUm dieses Problem zu beheben, verschieben Sie eine oder mehrere Knoten, soda\u00df die hervorgehobenen Ecken l\u00e4nger werden. Oder, Sie klicken in die Mitte der Ecke und ziehen diese, um einem neuen Schnittpunkt zu erzeugen.
