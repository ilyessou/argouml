<?xml version="1.0" encoding="ISO-8859-1"?>
<sect1 id="modules_and_plugins">
<!--
<sect1info>
<authorgroup>
<author>
  <firstname>Thierry</firstname>
  <surname>Lach</surname>
  <affiliation>
    <address>
      <email>thierry.lach@pentamark.com</email>
    </address>
  </affiliation>
</author>
<author>
  <firstname>Will</firstname>
  <surname>Howery</surname>
  <affiliation>
    <address>
      <email>whowery@hotmail.com</email>
    </address>
  </affiliation>
</author>
<author>
  <firstname>Thomas</firstname>
  <surname>Neustupny</surname>
  <affiliation>
    <address>
      <email>thn-d@gmx.de</email>
    </address>
  </affiliation>
</author>
</authorgroup>
</sect1info>
-->
<title>Modules and PlugIns</title>
<sect2 id="modules_vs_plugins">
<title>Differences between modules and plugins</title>
<para>
<itemizedlist>
<listitem>
<para>Modules</para>
<para>
The ARGO open source UML tool provides a basis
for UML design and potentially an executable architecture application.
This module system proposes an extension capability to the ARGO UML tool. 
This module extension will give developers the ability to add
additional functionality to the ARGO UML environment
without modifying the base open source ARGO tool.
This flexibility should encourage
additional open source and/or commercial involvement
with the open source UML tool.  
</para>

<para>
The module extensions will load when ARGO UML starts
and receive events from the ARGO system.
When the modules are loaded
they have the capability of attaching
to internal ARGO architectural elements.
They can attach themselves as listeners
on menu popup items for the model contexts.
This module interface is light with interface mechanisms
to notify the extensions of user actions.
The extensions then evaluate these actions and perform accordingly.  
</para>
</listitem>

<listitem>
<para>Plugins</para>
<para>
A plug-in in ArgoUML is a specific type of <classname>ArgoModule</classname>
that implements the
<classname>org.argouml.application.api.Pluggable</classname> interface.
It is supposed to act as a passive dynamic component,
i.e. it provides methods so that the core ArgoUML
application can query its existence and use its
specific functionality.

</para>
</listitem>
</itemizedlist>
</para>

</sect2>


<sect2 id="modules">
<title>Modules</title>

<sect3 id="architecture_modules">
<title>Module Architecture</title>
<para>
The controlling class of the module/plugin extension
is <classname>org.argouml.application.modules.ModuleLoader</classname>.
<classname>ModuleLoader</classname> is a singleton
created in the ARGO UML main initialization routine.
<!--
When the <classname>ModuleLoader</classname> is initialized
it will read a module file passed as an ARGO command parameter.
This module file will contain the fully qualified class names
designating the module to load into ARGO.
-->
</para>
<para>
<classname>ModuleLoader</classname> will:

<itemizedlist>
<listitem>
<para>read in the property file</para>
</listitem>
<listitem>
<para>create the specified classes</para>
</listitem>
<listitem>
<para>call initialize on these classes</para>
</listitem>
<listitem>
<para>place the class objects into the
internal <classname>ModuleLoader</classname> list</para>
</listitem>
</itemizedlist>
</para>

<para>
Each class must derive from the <classname>ArgoModule</classname> interface.
This interface provides the following methods:
<itemizedlist>
<listitem>
<funcsynopsis>
<funcprototype>
<funcdef>
String <function>getModuleName</function>
</funcdef>
<void/>
</funcprototype>
</funcsynopsis>
<para>provides a display name for the ARGO module.  
</para>
</listitem>
<listitem>
<funcsynopsis>
<funcprototype>
<funcdef>
String <function>getModuleDescription</function>
</funcdef>
<void/>
</funcprototype>
</funcsynopsis>
<para>provides a textual description for the ARGO module.  
</para>
</listitem>
<listitem>
<funcsynopsis>
<funcprototype>
<funcdef>
String <function>getModuleVersion</function>
</funcdef>
<void/>
</funcprototype>
</funcsynopsis>
<para>provides the version of the ARGO module.
</para>
</listitem>

<listitem>
<funcsynopsis>
<funcprototype>
<funcdef>
String <function>getModuleAuthor</function>
</funcdef>
<void/>
</funcprototype>
</funcsynopsis>
<para>provides the name of the module author(s).
</para>
</listitem>

<listitem>
<funcsynopsis>
<funcprototype>
<funcdef>
boolean <function>initializeModule</function>
</funcdef>
<void/>
</funcprototype>
</funcsynopsis>
<para><function>initializeModule</function> is called
when the class loader has created the module,
and before it is added into the modules list.
<function>initializeModule</function> should
initialize any required data
and/or attach itself as a listener to ARGO actions.
The <classname>ModuleLoader</classname> is invoked
after the rest of ARGO has been initialized and loaded.
Any menu modifications or system level resources
should already be available
when the module initialization process is called.  
</para>
<para>
<function>initializeModule</function>
should return <returnvalue>true</returnvalue>
if the initialization is successful
(or if no initialization is necessary).
</para>
</listitem>

<listitem>
<funcsynopsis>
<funcprototype>
<funcdef>
void <function>shutdownModule</function>
</funcdef>
<void/>
</funcprototype>
</funcsynopsis>
<para>The <function>shutdownModule</function> method is called
when the <classname>ModuleLoader</classname> is destroyed.
<function>shutdownModule</function> provides each module the capability
to clean up or save any required information
before being cleared from memory.  
</para>
</listitem>

<listitem>
<para>getPopUpActions</para>
<para>The getPopUpActions method is called
when a user right clicks on a context item.
The parameters passed into the pop-up actions method
are the current list of menu items for the context
and the context object that has received the pop-up event.
All popup actions within ARGO UML
will call the <classname>ModuleLoader</classname> doPopupActions event.
When this event is called
with the list of current popup items and the context,
the <classname>ModuleLoader</classname> will iterate
through all loaded modules
and calle their corresponding popup action methods.
The module will test the class type of the context.
If the class type of the context equals a context
where the module will add menu items,
then the module will add its menu items to the pop-up actions vector.
Within UML ARGO all actions are implemented
through a UML actions abstract class.
A module will create its own derived class
for the UML actions and add this menuaction to the pop-up vector.
If that menu item is selected in the pop-up menu
then the actionPerformed method within the UML action will be called.
When the actionPerformed is called the module will do its work.
</para>
</listitem>

<listitem>
<funcsynopsis>
<funcprototype>
<funcdef>
void <function>setModuleEnabled</function>
</funcdef>
<paramdef>boolean <parameter>tf</parameter></paramdef>
<!--
<funcparams>boolean tf</funcparams>
-->
</funcprototype>
</funcsynopsis>
</listitem>

<listitem>
<funcsynopsis>
<funcprototype>
<funcdef>
boolean <function>isModuleEnabled</function>
</funcdef>
<void/>
</funcprototype>
</funcsynopsis>
</listitem>

<listitem>
<funcsynopsis>
<funcprototype>
<funcdef>
Vector <function>getModulePopUpActions</function>
</funcdef>
<void/>
</funcprototype>
</funcsynopsis>
<para>...
</para>
</listitem>

<listitem>
<funcsynopsis>
<funcprototype>
<funcdef>
String <function>getModuleKey</function>
</funcdef>
<void/>
</funcprototype>
</funcsynopsis>
<para>Returns a string that identifies the module.
</para>
</listitem>

</itemizedlist>
</para>

<para>
The basic functionality will provide extensions
the ability to listen for a menu activity by context
within the UML diagramming environment.
When these events are fired,
the extension models can respond accordingly.  
</para>

</sect3>

<sect3 id="using_modules">
<title>Using Modules</title>
<para>...</para>
</sect3>

<sect3 id="howdoi_modules">
<title>How do I ...?</title>
<para>
<itemizedlist>

<listitem><para>...create a module?</para>
<para>
</para>
</listitem>

<listitem><para>...tell when a module is loaded?</para>
<para>
</para>
</listitem>

</itemizedlist>
</para>

</sect3>

</sect2>

<sect2 id="plugins">
<title>Plugins</title>

<sect3 id="architecture_plugins">
<title>Plugin Architecture</title>
<para>
Each class must derive from the <classname>Pluggable</classname> interface.
In addition to the methods declared in <classname>ArgoModule</classname>,
which <classname>Pluggable</classname> extends,
the interface provides the following method:

<itemizedlist>
<listitem>
<funcsynopsis>
<funcprototype>
<funcdef>
boolean <function>inContext</function>
</funcdef>
<paramdef>Object[] <parameter>context</parameter></paramdef>
<!--
<funcparams>boolean tf</funcparams>
-->
</funcprototype>
</funcsynopsis>
<para>
<function>inContext</function> allows a plug-in to decide
if it is available under a specific context. 
</para>
<para>
One example of a plugin with multiple criteria is the PluggableMenu.
PluggableMenu requires the first context to be a JMenuItem
which wants the PluggableMenu attached to as the context,
so that it can determine that it would attach to a menu.  The
second context is an internal (non-localized) description 
of the menu such as "File" or "View"
so that the plugin can further decide.
</para>
<!--
     *  @param context An identification of the context.  
     *                 The interpretation of criteria is specific to
     *                 the plug-in type, but must be consistent
     *                 across that type.  The plug-in must want
     *                 to be exposed to all contexts.
     *
     *  @return True if the plug-in wants to make itself available
     *          for this context, otherwise false.
     */
-->
</listitem>
</itemizedlist>
</para>
<para>
It is useful for those plugins which actually use context
to provide a helper method

<funcsynopsis>
<funcprototype>
<funcdef>
Object[] <function>buildContext</function>
</funcdef>
<paramdef>classtype1 <parameter>parameter1</parameter></paramdef>
<paramdef>classtype2 <parameter>parameter2</parameter></paramdef>
</funcprototype>
</funcsynopsis>
which will serve two purposes.
</para>
<para>
First, it will provide a simple way of creating the Object[] paramter.
</para>
<para>
Second, it helps to document the context parameters within the class itself.
</para>
<para>
Again using <classname>PluggableMenu</classname> as an example,
it contains the function

<programlisting>

    public Object[] buildContext(JMenuItem parentMenuItem, String menuType);

</programlisting>

which can be used as follows:

<programlisting>
    if plugin.inContext(plugin.buildcontext(parent, "Help")) {
        ....
    }
</programlisting>
</para>

</sect3>

<sect3 id="using_plugins">
<title>Using Plugins</title>
<para>...</para>
</sect3>

<sect3 id="howdoi_plugins">
<title>How do I ...?</title>

<para>

<itemizedlist>
<listitem><para>...create a plugin project?</para>
<para>...</para>
</listitem>

<listitem><para>...create a pluggable settings tab?</para>
<para>...</para>
</listitem>

<listitem><para>...create a pluggable menu?</para>
<para>...</para>
</listitem>

<listitem><para>...create a pluggable notation?</para>
<para>...</para>
</listitem>

<listitem><para>...create a pluggable diagram?</para>
<para>...</para>
</listitem>

<listitem><para>...create a pluggable resource bundle?</para>
<para>...</para>
</listitem>

<listitem><para>...create a new pluggable type?</para>
<para>
<itemizedlist>
<listitem>
<para>
Create the plug-ins interface
</para>
<para>

In the package org.argouml.application.api, create an
interface that extends Pluggable (in the same package).
The class name must begin with 'Pluggable'.
<note>
<para>
This is done to ensure that all plugin APIs are defined within Argo itself.
One of the main purposes of a plugin is
to provide the capability to add an externally defined class
that will be used by Argo in the same way as a similar internal class.
</para>
</note>
</para>
<para>
It now inherits from ArgoModule the methods
<programlisting>
    public boolean initializeModule();
    
    public boolean shutdownModule();

    public void setModuleEnabled(boolean tf);
    
    public boolean isModuleEnabled();

    public String getModuleName();

    public String getModuleDescription(); 
    
    public String getModuleVersion(); 
    
    public String getModuleAuthor(); 
    
    public Vector getModulePopUpActions(Vector popUpActions, Object context);

    public String getModuleKey();
</programlisting>

and from Pluggable the methods

<programlisting>

    public boolean inContext(Object[] context);

</programlisting>

and thus provides the mechanism to act like a plug-in.
It can be seen that a plug-in is a module.
<!--
Modules in
ArgoUML can be used to extend the core application at
compile time. Plug-ins additionally can be loaded at
runtime, because they extend modules by the necessary
load mechanism.
-->
</para>
<para>
The newly created plug-in of course should have more
extensions in order to be able to fulfill its purpose.
</para>
<para>
EXAMPLE:
</para>
<para>
Let's say we want to enable new diagram types as plug-ins.
We call the interface PluggableDiagram and add at least a
method that returns an JMenuItem object:

<programlisting>
    public JMenuItem getDiagramMenuItem();
</programlisting>

The returned menu item will be added to the diagrams menu
to allow to open a new diagram of this type.
</para>
</listitem>
<listitem>
<para>
Create implementation(s)
</para>
<para>
We do this by creating a helper class in the package
org.argouml.application.helpers that implements the created
plug-in interface PluggableDiagram, and call it DiagramHelper:

<programlisting>
public abstract class DiagramHelper extends ArgoDiagram
implements PluggableDiagram {

    /** Default localization key for diagrams
     */
    public final static String DIAGRAM_BUNDLE = "DiagramType";

    /** String naming the resource bundle to use for localization.
     */
    protected String _bundle = "";

    public DiagramHelper() {
        _bundle = getDiagramResourceBundleKey();
    }

    public void setModuleEnabled(boolean v) { }

    public boolean initializeModule() { return true; }

    public boolean inContext(Object[] o) { return true; }

    public boolean isModuleEnabled() { return true; }

    public Vector getModulePopUpActions(Vector v, Object o) { return null; }

    public boolean shutdownModule() { return true; }

    public JMenuItem getDiagramMenuItem()
    {
        return new JMenuItem(Argo.localize(_bundle,"diagram_type"));
    }

    public String getDiagramResourceBundleKey() {
        return DIAGRAM_BUNDLE;
    }
}

</programlisting>
The extension of ArgoDiagram is specific to this example;
the plug-in will provide a new ArgoUML diagram.

<important>
<para>
Don't forget to do the localization stuff, because the
plug-in might be used in all languages ArgoUML offers!
</para>
</important>

</para>
</listitem>
<listitem>
<para>
Localization (not plug-in specific, but important)
</para>
<para>
As you can see we defines a constant DIAGRAM_BUNDLE with
the value "DiagramType". This string is used for adding
the language resource.
This is most conveniently done inside of <function>initializeModule</function>.
So we change <function>initializeModule</function> as follows:
<!--
For simplicity, this is done in
ArgoUML's main method in Main.java:
-->

<programlisting>

    public boolean initializeModule() {
        Localizer.addResource("DiagramType",
                              "org.argouml.ui.DiagramResourceBundle");
        return true;
    }
</programlisting>

The resource bundle currently consists of the four classes

<programlisting>
    org.argouml.ui.DiagramResourceBundle
    org.argouml.ui.DiagramResourceBundle_de
    org.argouml.ui.DiagramResourceBundle_es
    org.argouml.ui.DiagramResourceBundle_fr
</programlisting>

which need to be created.
As additional translations are supported,
additional classes should be added.
</para>
</listitem>
</itemizedlist>

</para>
</listitem>

</itemizedlist>

</para>

</sect3>

</sect2>

</sect1>
