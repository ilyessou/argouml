<html><head><title>2.3. UML Based Processes for OOA&amp;D</title><link href="look-and-feel.css" rel="stylesheet" type="text/css"><meta content="DocBook XSL Stylesheets V1.37" name="generator"><link href="index.html" rel="home" title="ArgoUML User Manual"><link href="ch02.html" rel="up" title="Chapter 2. UML Based OOA&amp;D"><link href="ch02s02.html" rel="previous" title="2.2. Background to UML"><link href="ch02s04.html" rel="next" title="2.4. Why ArgoUML is Different"></head><body alink="#0000FF" bgcolor="white" link="#0000FF" text="black" vlink="#840084"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">2.3. UML Based Processes for OOA&amp;D</th></tr><tr><td align="left" width="20%"><a href="ch02s02.html">Prev</a>&nbsp;</td><th align="center" width="60%">Chapter 2. UML Based OOA&amp;D</th><td align="right" width="20%">&nbsp;<a href="ch02s04.html">Next</a></td></tr></table><hr></div><div class="sect1"><a name="Ndaa"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="Ndaa"></a>2.3. UML Based Processes for OOA&amp;D</h2></div></div><p>It is important to understand that UML is a notation for OOA&amp;D. It
     does not prescribe any particular process.</p><p>Whatever process is adopted, it must take the system being
      constructed through a number of phases.</p><div class="orderedlist"><ol type="1"><li><p><a name="Ndbb"></a>Requirements Capture. This is where we identify the
        requirements for the system, using the language of the
        <i>problem domain</i>. In other words we describe the
        problem in the &#8220;customer's&#8221; terms.</p></li><li><p><a name="Ndc5"></a>Analysis. We take the requirements and start to recast
        them in the language of a putative solution&#8212;the
        <i>solution domain</i>. At this stage, although thinking
        in terms of a solution, we ensure we keep things at a high level, away
        from concrete details of a specific solution&#8212;what is known as
        <i>abstraction</i>.</p></li><li><p><a name="Ndcf"></a>Design. We take the specification from the Analysis phase
        and construct the solution in full detail. We are moving from
        <i>abstraction</i> of the problem to its
        <i>realization</i> in concrete terms.</p></li><li><p><a name="Ndd9"></a>Build Phase. We take the actual design and write it in a
        real programming language. This includes not just the programming, but
        the testing that the program meets the requirements
        (<i>verification</i>), testing that the program actually
        solves the customer's problem (<i>validation</i>) and
        writing all user documentation.</p></li></ol></div><div class="sect2"><a name="s2.proctypes"></a><div class="titlepage"><div><h3 class="title"><a name="s2.proctypes"></a>2.3.1. Types of Process</h3></div></div><p>In this section we look at the two main types of process in use for
        software engineering. There are others, but they are less widely
        used.</p><div class="sect3"><a name="Ndf0"></a><div class="titlepage"><div><h4 class="title"><a name="Ndf0"></a>2.3.1.1. The Waterfall Process</h4></div></div><p>In this process, each stage of the process&#8212;requirements,
          analysis, design and build (code and test) is completed before the
          next one starts. This is illustrated in <a href="ch02s03.html#fig.waterfallsteps" title="Figure 2.1. The waterfall process">Figure 2.1. The waterfall process</a>.</p><div class="figure"><p><a name="fig.waterfallsteps"></a><b>Figure 2.1. The waterfall process</b></p><div class="screenshot"><div class="mediaobject"><img align="center" src="images/tutorial/waterfallsteps.png"></div></div></div><p>This is a very satisfactory process where requirements are well
          designed and not expected to change, for example automating a well
          proven manual system.</p><p>The weaknesses of this approach show with less well defined
          problems. Invariably some of the uncertainties in the requirements
          will not be clarified until well into the analysis and design, or
          even code phases, requiring backtracking to redo work.</p><p>The worst aspect of this, is that working code does not become
          available until near the end of the project, and very often it is
          only at this stage that problems with the original requirements (for
          example with the user interface) become apparent.</p><p>This is exacerbated, by each successive stage requiring more
          effort, than the previous, so that the costs of late problem
          discovery are hugely expensive. This is illustrated by the pyramid in
          <a href="ch02s03.html#fig.waterfall" title="Figure 2.2. Effort involved in the steps of the waterfall process">Figure 2.2. Effort involved in the steps of the waterfall process</a>.</p><div class="figure"><p><a name="fig.waterfall"></a><b>Figure 2.2. Effort involved in the steps of the waterfall process</b></p><div class="screenshot"><div class="mediaobject"><img align="center" src="images/tutorial/waterfall.png"></div></div></div><p>The waterfall process is still probably the dominant design
          process. However because of its limitations it is increasingly
          replaced by <i>iterative</i> processes, particularly
          for projects where the requirements are not well defined.</p></div><div class="sect3"><a name="Ne57"></a><div class="titlepage"><div><h4 class="title"><a name="Ne57"></a>2.3.1.2. Iterative Development Processes</h4></div></div><p>In recent years a new approach has been used, which aims to get
          at least part of the code up and running as quickly as possible, to
          bring discovery of problems forward in the development cycle.</p><p>These processes use a series of &#8220;mini-waterfalls&#8221;,
          defining a few requirements (the most important) first, taking them
          through analysis, design and build to get an early version of the
          product, with limited functionality, related to the most important
          requirements. Feedback from this can then be used to refine the
          requirements, spot problems etc before more work is done.</p><p>The process is then repeated for further requirements to
          construct a product with a step up in functionality. Again further
          feedback can be applied to the requirements.</p><p>The process is repeated more times, until eventually all
          requirements have been implemented and the product is complete. It is
          this <i>iteration</i> that gives these processes their
          name. <a href="ch02s03.html#fig.iterative" title="Figure 2.3. Effort involved in the steps of an iterative process">Figure 2.3. Effort involved in the steps of an iterative process</a> shows how this process compares
          to the pyramid structure of the Waterfall Process.</p><div class="figure"><p><a name="fig.iterative"></a><b>Figure 2.3. Effort involved in the steps of an iterative process</b></p><div class="screenshot"><div class="mediaobject"><img align="center" src="images/tutorial/iterative.png"></div></div></div><p>The growth in popularity of iterative processes is closely tied
          to the growth of OOA&amp;D. It is the clean encapsulation of objects
          that allows a part of a system to be built with stubs for the
          remaining code clearly defined.</p><div class="sect4"><a name="Ne96"></a><div class="titlepage"><div><h5 class="title"><a name="Ne96"></a>2.3.1.2.1. The Rational Unified Process</h5></div></div><p>Perhaps the best known Iterative Process is the Rational
            Unified Process (RUP) from Rational Software (<a href="http://www.rational.com" target="_top">www.rational.com</a>.</p><p>This process recognizes that our pyramid view of even slices of
            the waterfall is not realistic. In practice the early iterations
            tend to be heavy on the requirements end of things (you need to
            define a reasonable amount even to get started), whilst the later
            iterations have more of their effort in the design and build
            areas.</p><p>RUP recognizes that iterations can be grouped into a number of
            <i>phases</i> according to their stage in the overall
            project. Each phase may have one or more iterations.</p><div class="itemizedlist"><ul><li><p><a name="Neae"></a>In the <i>inception
              phase</i> iterations tend to be heavy on the
              requirements/analysis end, whilst any build activity may be
              limited to emulation of the design within a CASE
              tool.</p></li><li><p><a name="Neb5"></a>In the <i>elaboration
              phase</i> iterations tend to be completing the
              specification of the requirements, and starting to focus on the
              analysis and design, and possibly the first real built
              code.</p></li><li><p><a name="Nebc"></a>In the <i>construction phase</i>
              iterations are more or less completed with the requirements and
              analysis, and the effort is mostly in design and
              build.</p></li><li><p><a name="Nec3"></a>Finally, in the <i>deployment
              phase</i> iterations are largely about build activity, and
              in particular the testing of the software.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0"><tr><td align="center" rowspan="2" valign="top" width="25"><img src="images/note.png"></td><th><a name="Necb"></a>Note</th></tr><tr><td align="left" colspan="2" valign="top"><p>It should be clear that testing is an integral part of
            all phases. Even in the early phases the requirements and design
            should be tested, and this is facilitated by a good CASE
            tool.</p></td></tr></table></div><p>We shall use an iterative process in this manual, that is
            loosely based on the RUP.</p></div><div class="sect4"><a name="Ned5"></a><div class="titlepage"><div><h5 class="title"><a name="Ned5"></a>2.3.1.2.2. How Big is an Iteration?</h5></div></div><p>A good rule of thumb is that an iteration should take between
            six and ten weeks for typical commercial projects. Any longer and
            you have probably bitten off too many requirements to do in one
            go. You also lose focus on getting the next working iteration
            completed. Any shorter and you probably haven't got enough
            requirements to make a significant advance, and will struggle to
            get all the work done.</p><p>This then begs the question of how many iterations in
            total. This depends on the size of project. Take the estimated time
            (and working out/guessing that is a whole subject on its own), and
            divided it into 8 week chunks. Experience seems to suggest that
            the iterations will divide in the ratio of around 1:2:3:3 into RUP
            style inception, elaboration, construction and deployment
            phases. A project that has great vagueness in its specification
            (some advanced research projects for example) will tend to be
            heavier on the early phases.</p><p>When building a product to contract for a customer the end
            point is well defined. However when developing a new product for
            the market place, a strategy that can be used is to decide the
            product launch date, and hence the end date for completion of
            engineering (some time before). The time is then divided into
            iterations, and as much of the product as can be built in that time
            developed. The iterative process is very effective where time to
            market is more important that the exact functionality.</p></div></div><div class="sect3"><a name="Nee7"></a><div class="titlepage"><div><h4 class="title"><a name="Nee7"></a>2.3.1.3. Recursive Development Processes</h4></div></div><p>Very few software systems are conceived as monolithic
          artifacts. They are broken down into subsystems, modules etc.</p><p>Software processes are the same, with early parts of the process
          defining a top level structure, and the process reapplying to parts
          of the structure in turn to define ever greater details.</p><p>For example the initial design of a telephone system might
          identify objects to i) handle the phone lines, ii) process the calls,
          iii) manage the system and iv) bill the customer. The software
          process can then be reapplied to each of these four components to
          identify their design.</p><p>OOA&amp;D with its clean boundaries to objects, naturally supports
          this approach. Such OOA&amp;D with recursive development is sometimes
          abbreviated as OOA&amp;D/RD.</p><p>Recursive development can be applied equally well to waterfall or
          iterative processes. It is not an alternative to them.</p></div></div><div class="sect2"><a name="Nefd"></a><div class="titlepage"><div><h3 class="title"><a name="Nefd"></a>2.3.2. A Development Process for This Manual</h3></div></div><p>For the purpose of this manual we will use a stripped down
        iterative process with recursive development, loosely akin to RUP. The
        case study will take us through the first iteration, although at the
        end of the tutorial section of the manual we will look at how the
        project will develop to completion.</p><p>Within that first iteration, we will tackle each of the
        requirements capture, analysis, design and build activities in
        turn. Not all parts of the process are based on UML or ArgoUML. We
        will look at what other material is needed outside.</p><div class="sect3"><a name="Nf0a"></a><div class="titlepage"><div><h4 class="title"><a name="Nf0a"></a>2.3.2.1. Requirements Capture</h4></div></div><p>Our requirements capture will use the UML concept of
          <i>Use Cases</i>. Starting with a <i>Vision
          Document</i> we will see how Use Cases can be developed to
          describe all aspects of the system's behavior in the problem
          domain.</p></div><div class="sect3"><a name="Nf1b"></a><div class="titlepage"><div><h4 class="title"><a name="Nf1b"></a>2.3.2.2. Analysis</h4></div></div><p>During the analysis stage, we will introduce the UML concept of
          <i>classes</i> to allow us to build a top level view of
          the objects that will make up the solution&#8212;sometimes known as a
          <i>concept diagram</i>.</p><p>We will introduce the UML <i>sequence diagram</i>
          and <i>state diagram</i> to capture requirements for
          the overall behavior of the system.</p><p>Finally we will take the Use Cases from the requirements capture
          stage, and recast them in the language of the solution domain. This
          will illustrate the UML ideas of <i>stereotyping</i>
          and <i>realization</i>.</p></div><div class="sect3"><a name="Nf3e"></a><div class="titlepage"><div><h4 class="title"><a name="Nf3e"></a>2.3.2.3. Design</h4></div></div><p>We use the UML <i>package diagram</i> to organize
          the components of the project. We then revisit the class diagram,
          sequence diagram and state diagram, to show how they can be used
          recursively to design the complete solution.</p><p>During this part of the process, we need to develop our system
          architecture, to define how all the components will fit together and
          operate.</p><p>Although not strictly part of our process, we'll look at how the
          UML <i>collaboration diagram</i> can be used as an
          alternative to, or to complement the <i>sequence
          diagram</i>. Similarly we will look at the UML
          <i>activity diagram</i> as an alternative or complement
          to the state diagram.</p><p>Finally we shall use the UML <i>deployment
          diagram</i> to specify how the system will actually be
          realized.</p></div><div class="sect3"><a name="Nf61"></a><div class="titlepage"><div><h4 class="title"><a name="Nf61"></a>2.3.2.4. Build</h4></div></div><p>UML is not really concerned with code writing. However at this
          stage we will show how ArgoUML can be used for code
          generation.</p><p>We will also look at how the UML Use Case Diagram and Use Case
          Specification are invaluable tools for a test program.</p></div></div></div><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a href="ch02s02.html">Prev</a>&nbsp;</td><td align="center" width="20%"><a href="index.html">Home</a></td><td align="right" width="40%">&nbsp;<a href="ch02s04.html">Next</a></td></tr><tr><td align="left" width="40%">2.2. Background to UML&nbsp;</td><td align="center" width="20%"><a href="ch02.html">Up</a></td><td align="right" width="40%">&nbsp;2.4. Why ArgoUML is Different</td></tr></table></div></body></html>