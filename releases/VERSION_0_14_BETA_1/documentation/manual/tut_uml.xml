<?xml version="1.0" encoding="ISO-8859-1"?>

<!--

This chapter introduces the user to UML based OOA&D and explains how to get
Argo/UML up and running.


Modifications
=============

30 Nov 2001:  Jeremy Bennett. Broken out as a separate section from the
              original manual by Alejandro, Phillipe and Andreas.

10 Dec 2001:  Jeremy Bennett. Introduction, background to UML and UML based
              processes, introduction to mouse, menus and drawing added for
              0.9.5, draft B.

 4 Apr 2002:  Jeremy Bennett. Added info about using XMI from Gentleware.

18 Apr 2002:  Jeremy Bennett. Incorporated review comments from Bob Marcum.

-->

<chapter id="ch.tut.uml">
  <title>UML Based &ooad;</title>

  <sect1>
    <title>Introduction</title>

    <para>In this chapter, we look at how UML as a notation is used within
      &ooad;.</para>
  </sect1>

  <sect1>
    <title>Background to UML</title>

    <para><emphasis>Object orientation</emphasis> as a concept has been around
      since the 1960's, and as a design concept since 1972. However it was in
      the 1980's that it started to develop as a credible alternative to a
      <emphasis>functional approach</emphasis> in analysis and design. We can
      identify a number of drivers.</para>

    <orderedlist>
      <listitem><para>The emergence of mainstream OO programming languages like
        SmallTalk and particularly C++. C++ was a pragmatic OO language derived
        from C, widely used because of its association with
        Unix.</para></listitem>

      <listitem><para>The development of powerful workstations, and with them
        the emergence into the mainstream of windowing operating user
        environments. Graphical User Interfaces (GUI) have an inherent object
        structure.</para></listitem>

      <listitem><para>A number of very public major project failures,
        suggesting that current approaches were not
        satisfactory.</para></listitem>
    </orderedlist>

    <para>A number of researchers proposed &ooad; processes, and with them
      notations. Those that achieved some success include Coad-Yourdon, Booch,
      Rumbaugh OMT, OOSE/Jacobson, Shlaer-Mellor, ROOM (for real-time design)
      and the hybrid Jackson Structured Development.</para>

    <para>During the early 1990's it became clear that these approaches had
      many good ideas, often very similar. A major stumbling block was the
      diversity of notation, meaning engineers tended to be familiar with one
      &ooad; methodology, rather than the approach in general.</para>

    <para>UML was conceived as a common notation, that would be in the
      interests of all involved. The original standard was driven by Rational
      Software (<ulink url="http://www.rational.com">www.rational.com</ulink>,
      in which three of the key researchers in the field (Booch, Jacobson and
      Rumbaugh were involved). They produced documents describing v0.9 and
      v0.91 during 1996. The effort was taken industry wide through the
      Object Management Group (OMG), already well known for the CORBA
      standard. A first proposal, 1.0 was published in early 1997, with an
      improved version 1.1 approved that autumn.</para>

    <para>&argouml; is based on UML v1.3, which was adopted by OMG in November
      1999. UML v1.4 has recently been approved (2001). A major revision, UML
      v2.0 is planned to be completed in 2002.</para>
  </sect1>

  <!-- Put a process with the notation -->

  <sect1>
    <title>UML Based Processes for &ooad;</title>

    <para>It is important to understand that UML is a notation for &ooad;. It
     does not prescribe any particular process.</para>

    <para>Whatever process is adopted, it must take the system being
      constructed through a number of phases.</para>

    <orderedlist>
      <listitem><para>Requirements Capture. This is where we identify the
        requirements for the system, using the language of the
        <emphasis>problem domain</emphasis>. In other words we describe the
        problem in the <quote>customer's</quote> terms.</para></listitem>

      <listitem><para>Analysis. We take the requirements and start to recast
        them in the language of a putative solution&mdash;the
        <emphasis>solution domain</emphasis>. At this stage, although thinking
        in terms of a solution, we ensure we keep things at a high level, away
        from concrete details of a specific solution&mdash;what is known as
        <emphasis>abstraction</emphasis>.</para></listitem>

      <listitem><para>Design. We take the specification from the Analysis phase
        and construct the solution in full detail. We are moving from
        <emphasis>abstraction</emphasis> of the problem to its
        <emphasis>realization</emphasis> in concrete terms.</para></listitem>

      <listitem><para>Build Phase. We take the actual design and write it in a
        real programming language. This includes not just the programming, but
        the testing that the program meets the requirements
        (<emphasis>verification</emphasis>), testing that the program actually
        solves the customer's problem (<emphasis>validation</emphasis>) and
        writing all user documentation.</para></listitem>
    </orderedlist>

    <!-- Waterfall v Iterative -->

    <sect2 id="s2.proctypes">
      <title>Types of Process</title>

      <para>In this section we look at the two main types of process in use for
        software engineering. There are others, but they are less widely
        used.</para>

      <para>In recent years there has also been a move to reduce the effort
        required in developing software. This has led to the development of a
        number of lightweight variants of processes (often known as
        <emphasis>agile computing</emphasis> or <emphasis>extreme
        programming</emphasis>) that are suited to very small teams of
        engineers.</para>

      <sect3>
        <title>The Waterfall Process</title>

        <para>In this process, each stage of the process&mdash;requirements,
          analysis, design and build (code and test) is completed before the
          next one starts. This is illustrated in <xref
            linkend="fig.waterfallsteps"/>.</para>

        <!-- A diagram showing the waterfall steps leading to each other. -->

        <figure id="fig.waterfallsteps" float="1">
          <title>The waterfall process</title>

          <screenshot><mediaobject>
            <imageobject>
              <imagedata format="PNG" align="center"
                         fileref="images/tutorial/waterfallsteps.png"/>
            </imageobject>
          </mediaobject></screenshot>
        </figure>

        <para>This is a very satisfactory process where requirements are well
          designed and not expected to change, for example automating a well
          proven manual system.</para>

        <para>The weaknesses of this approach show with less well defined
          problems. Invariably some of the uncertainties in the requirements
          will not be clarified until well into the analysis and design, or
          even code phases, requiring backtracking to redo work.</para>

        <para>The worst aspect of this, is that working code does not become
          available until near the end of the project, and very often it is
          only at this stage that problems with the original requirements (for
          example with the user interface) become apparent.</para>

        <para>This is exacerbated, by each successive stage requiring more
          effort, than the previous, so that the costs of late problem
          discovery are hugely expensive. This is illustrated by the pyramid in
          <xref linkend="fig.waterfall"/>.</para>

        <!-- A diagram showing the waterfall process as a pyramid -->

        <figure id="fig.waterfall" float="1">
          <title>Effort involved in the steps of the waterfall process</title>

          <screenshot><mediaobject>
            <imageobject>
              <imagedata format="PNG" align="center"
                         fileref="images/tutorial/waterfall.png"/>
            </imageobject>
          </mediaobject></screenshot>
        </figure>

        <para>The waterfall process is still probably the dominant design
          process. However because of its limitations it is increasingly
          replaced by <emphasis>iterative</emphasis> processes, particularly
          for projects where the requirements are not well defined.</para>
      </sect3>

      <!-- Iterative processes -->

      <sect3>
        <title>Iterative Development Processes</title>

        <para>In recent years a new approach has been used, which aims to get
          at least part of the code up and running as quickly as possible, to
          bring discovery of problems forward in the development cycle.</para>

        <para>These processes use a series of <quote>mini-waterfalls</quote>,
          defining a few requirements (the most important) first, taking them
          through analysis, design and build to get an early version of the
          product, with limited functionality, related to the most important
          requirements. Feedback from this can then be used to refine the
          requirements, spot problems etc before more work is done.</para>

        <para>The process is then repeated for further requirements to
          construct a product with a step up in functionality. Again further
          feedback can be applied to the requirements.</para>

        <para>The process is repeated, until eventually all requirements have
          been implemented and the product is complete. It is this
          <emphasis>iteration</emphasis> that gives these processes their
          name. <xref linkend="fig.iterative"/> shows how this process compares
          to the pyramid structure of the Waterfall Process.</para>

        <!-- A diagram showing an iterative process as a pyramid -->

        <figure id="fig.iterative" float="1">
          <title>Effort involved in the steps of an iterative process</title>

          <screenshot><mediaobject>
            <imageobject>
              <imagedata format="PNG" align="center"
                         fileref="images/tutorial/iterative.png"/>
            </imageobject>
          </mediaobject></screenshot>
        </figure>

        <para>The growth in popularity of iterative processes is closely tied
          to the growth of &ooad;. It is the clean encapsulation of objects
          that allows a part of a system to be built with stubs for the
          remaining code clearly defined.</para>

        <sect4>
          <title>The Rational Unified Process</title>

          <para>Perhaps the best known Iterative Process is the Rational
            Unified Process (RUP) from Rational Software (<ulink
              url="http://www.rational.com">www.rational.com</ulink>).</para>

          <para>This process recognizes that our pyramid view of even slices of
            the waterfall is not realistic. In practice the early iterations
            tend to be heavy on the requirements end of things (you need to
            define a reasonable amount even to get started), while the later
            iterations have more of their effort in the design and build
            areas.</para>

          <para>RUP recognizes that iterations can be grouped into a number of
            <emphasis>phases</emphasis> according to their stage in the overall
            project. Each phase may have one or more iterations.</para>

          <itemizedlist>
            <listitem><para>In the <emphasis>inception
              phase</emphasis> iterations tend to be heavy on the
              requirements/analysis end, while any build activity may be
              limited to emulation of the design within a CASE
              tool.</para></listitem>

            <listitem><para>In the <emphasis>elaboration
              phase</emphasis> iterations tend to be completing the
              specification of the requirements, and starting to focus on the
              analysis and design, and possibly the first real built
              code.</para></listitem>

            <listitem><para>In the <emphasis>construction phase</emphasis>
              iterations are more or less completed with the requirements and
              analysis, and the effort is mostly in design and
              build.</para></listitem>

            <listitem><para>Finally, in the <emphasis>deployment
              phase</emphasis> iterations are largely about build activity, and
              in particular the testing of the software.</para></listitem>
          </itemizedlist>

          <note><para>It should be clear that testing is an integral part of
            all phases. Even in the early phases the requirements and design
            should be tested, and this is facilitated by a good CASE
            tool.</para></note>

          <para>We shall use an iterative process in this manual, that is
            loosely based on the RUP.</para>
        </sect4>

        <!-- Defining the size of an iteration -->

        <sect4>
          <title>How Big is an Iteration?</title>

          <para>A good rule of thumb is that an iteration should take between
            six and ten weeks for typical commercial projects. Any longer and
            you have probably bitten off too many requirements to do in one
            go. You also lose focus on getting the next working iteration
            completed. Any shorter and you probably haven't got enough
            requirements to make a significant advance, and will struggle to
            get all the work done.</para>

          <para>This then begs the question of how many iterations in
            total. This depends on the size of project. Take the estimated time
            (and working out/guessing that is a whole subject on its own), and
            divided it into 8 week chunks. Experience seems to suggest that
            the iterations will divide in the ratio of around 1:2:3:3 into RUP
            style inception, elaboration, construction and deployment
            phases. A project that has great vagueness in its specification
            (some advanced research projects for example) will tend to be
            heavier on the early phases.</para>

          <para>When building a product to contract for a customer the end
            point is well defined. However when developing a new product for
            the market place, a strategy that can be used is to decide the
            product launch date, and hence the end date for completion of
            engineering (some time before). The time is then divided into
            iterations, and as much of the product as can be built in that time
            developed. The iterative process is very effective where time to
            market is more important than the exact functionality.</para>
        </sect4>
      </sect3>

      <!-- Recursive Development Processes -->

      <sect3>
        <title>Recursive Development Processes</title>

        <para>Very few software systems are conceived as monolithic
          artifacts. They are broken down into subsystems, modules etc.</para>

        <para>Software processes are the same, with early parts of the process
          defining a top level structure, and the process reapplying to parts
          of the structure in turn to define ever greater details.</para>

        <para>For example the initial design of a telephone system might
          identify objects to i) handle the phone lines, ii) process the calls,
          iii) manage the system and iv) bill the customer. The software
          process can then be reapplied to each of these four components to
          identify their design.</para>

        <para>&ooad; with its clean boundaries to objects, naturally supports
          this approach. Such &ooad; with recursive development is sometimes
          abbreviated as &ooad;/RD.</para>

        <para>Recursive development can be applied equally well to waterfall or
          iterative processes. It is not an alternative to them.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>A Development Process for This Manual</title>

      <para>For the purpose of this manual we will use a stripped down
        iterative process with recursive development, loosely akin to RUP. The
        case study will take us through the first iteration, although at the
        end of the tutorial section of the manual we will look at how the
        project will develop to completion.</para>

      <para>Within that first iteration, we will tackle each of the
        requirements capture, analysis, design and build activities in
        turn. Not all parts of the process are based on UML or &argouml;. We
        will look at what other material is needed outside.</para>

      <para>Within this process we will have an opportunity to see the various
        UML diagrams in use. The full range of UML diagrams and how they are
        supported is described in the reference manual (see <xref
        linkend="s1.ref.diagram_types"/>).</para>

      <!-- Requirements Capture -->

      <sect3>
        <title>Requirements Capture</title>

        <para>Our requirements capture will use the UML concept of
          <emphasis>Use Cases</emphasis>. Starting with a <emphasis>Vision
          Document</emphasis> we will see how Use Cases can be developed to
          describe all aspects of the system's behavior in the problem
          domain.</para>
      </sect3>

      <!-- Analysis -->

      <sect3>
        <title>Analysis</title>

        <para>During the analysis stage, we will introduce the UML concept of
          <emphasis>classes</emphasis> to allow us to build a top level view of
          the objects that will make up the solution&mdash;sometimes known as a
          <emphasis>concept diagram</emphasis>.</para>

        <para>We will introduce the UML <emphasis>sequence diagram</emphasis>
          and <emphasis>state diagram</emphasis> to capture requirements for
          the overall behavior of the system.</para>

        <para>Finally we will take the Use Cases from the requirements capture
          stage, and recast them in the language of the solution domain. This
          will illustrate the UML ideas of <emphasis>stereotyping</emphasis>
          and <emphasis>realization</emphasis>.</para>
      </sect3>

      <!-- Design -->

      <sect3>
        <title>Design</title>

        <para>We use the UML <emphasis>package diagram</emphasis> to organize
          the components of the project. We then revisit the class diagram,
          sequence diagram and state diagram, to show how they can be used
          recursively to design the complete solution.</para>

        <para>During this part of the process, we need to develop our system
          architecture, to define how all the components will fit together and
          operate.</para>

        <para>Although not strictly part of our process, we'll look at how the
          UML <emphasis>collaboration diagram</emphasis> can be used as an
          alternative to, or to complement the <emphasis>sequence
          diagram</emphasis>. Similarly we will look at the UML
          <emphasis>activity diagram</emphasis> as an alternative or complement
          to the state diagram.</para>

        <para>Finally we shall use the UML <emphasis>deployment
          diagram</emphasis> to specify how the system will actually be
          realized.</para>
      </sect3>

      <!-- Build -->

      <sect3>
        <title>Build</title>

        <para>UML is not really concerned with code writing. However at this
          stage we will show how &argouml; can be used for code
          generation.</para>

        <para>We will also look at how the UML Use Case Diagram and Use Case
          Specification are invaluable tools for a test program.</para>
      </sect3>
    </sect2>
  </sect1>

  <!-- What Argo/UML is different to other UML CASE tools -->

  <sect1>
    <title>Why &argouml; is Different</title>

    <para>In the introduction, we listed the four key things that make
    &argouml; different: i) it makes use of ideas from cognitive psychology,
    ii) it is based on open standards; iii) it is 100% pure Java; and iv) it is
    an open source project.</para>

    <sect2>
      <title>Cognitive Psychology</title>

      <!-- The theory -->

      <sect3>
        <title>Theory</title>

        <para>&argouml; is particularly inspired by three theories within
        cognitive psychology: i) reflection-in-action, ii) opportunistic design
        iii) and comprehension and problem solving.</para>

        <!-- A bit on reflection-in-action -->

        <sect4>
          <title>Reflection-in-Action</title>

          <para>This theory observes that designers of complex systems do not
            conceive a design fully-formed. Instead, they must construct a
            partial design, evaluate, reflect on, and revise it, until they are
            ready to extend it further.</para>

          <para>As developers work hands-on with the design, their mental model
            of the problem situation improves, hence improving their
            design.</para>
        </sect4>

        <!-- A bit on Opportunistic Design -->

        <sect4>
          <title>Opportunistic Design</title>

          <para>A theory within cognitive psychology suggesting that although
            designers plan and describe their work in an ordered, hierarchical
            fashion, in reality, they choose successive tasks based on the
            criteria of cognitive cost.</para>

          <para>Simply stated, designers do not follow even their own plans in
            order, but choose steps that are mentally least expensive among
            alternatives.</para>
        </sect4>

        <!-- A bit on comprehension and problem solving -->

        <sect4>
          <title>Comprehension and Problem Solving</title>

          <para>A design visualization theory within cognitive psychology. The
            theory notes that designers must bridge a gap between their mental
            model of the problem or situation and the formal model of a
            solution or system.</para>

          <para>This theory suggests that programmers will benefit from:</para>

          <orderedlist>
            <listitem><para>Multiple representations such as program syntactic
              decomposition, state transitions, control flow, and data
              flow. These allow the programmer to better identify elements and
              relationships in the problem and solution and thus more readily
              create a mapping between their situation models and working
              system models.</para></listitem>

            <listitem><para>Familiar aspects of a situation model, which
              improve designers' abilities to formulate
              solutions.</para></listitem>
          </orderedlist>
        </sect4>
      </sect3>

      <!-- The practice -->

      <sect3>
        <title>Practical Application in &argouml;</title>

        <para>The implementation of these theories within &argouml; is through
         a number of techniques.</para>

        <orderedlist>
          <listitem><para>The design of a user interface which allows the user
            to view the design from a number of different perspectives, and
            allows the user to achieve goals through a number of alternative
            routes.</para></listitem>

          <listitem><para>The the use of processes running in parallel with the
            design tool, evaluating the current design against models of how
            <quote>best practice</quote> design might work. These processes are
            known as <emphasis>design critics</emphasis>.</para></listitem>

          <listitem><para>The use of <emphasis>to-do lists</emphasis> to convey
            suggestions from the design critics to the user, as well as
            allowing the user to record areas for future
            action.</para></listitem>

          <listitem><para>The use of checklists, to guide the user through a
            complex process.</para></listitem>
        </orderedlist>
      </sect3>
    </sect2>

    <!-- Open Standards -->

    <sect2>
      <title>Open Standards</title>

      <para>UML is itself an open standard. &argouml; throughout has tried to
        use open standards for all its interfaces.</para>

      <para>The key advantage of open standards is that it permits easy
        inter-working between applications, and the ability to move from one
        application to another as necessary.</para>

      <para>It is this very flexibility that means some commercial software is
        not built to use standards. In a monopolistic strategy, non-standard
        interfaces lock your customer to you.</para>

      <para>This is a two-edged sword. Customers are not stupid, and are
        reluctant to buy non-standard software, because of the danger of
        lock-in.</para>

      <para>The open source movement, is inherently about avoiding monopolistic
        control of software. Open standards are a natural direction for such
        software&mdash;including &argouml;.</para>

      <!-- XMI -->

      <sect3>
        <title>XML Metadata Interchange (XMI)</title>

        <para><emphasis>XML Metadata Interchange (XMI)</emphasis> is the
          standard for saving the meta-data that make up a particular UML
          model. In principle this will allow you to take the model you have
          created in &argouml; and import it into another tool.</para>

        <para>This clearly has advantages in allowing UML to meet its goal of
          being a standard for communication between designers.</para>

        <para>The reality is not quite this good. XMI is a recent standard, and
          &argouml; is one of the few tools to implement it. Furthermore it
          says nothing about the graphical representation of the models, so
          diagram layout is lost. &argouml; gets round this by saving graphical
          information with the model (see <xref
            linkend="s3.tut.loadsave"/>).</para>
      </sect3>

      <!-- SVG -->

      <sect3>
        <title>Scalable Vector Graphics (SVG)</title>

        <para><emphasis>Scalable Vector Graphics (SVG)</emphasis> is a recent
          standard proposed to the W3C Standardization body (<ulink
            url="http://www.w3c.org">www.w3c.org</ulink>) by Adobe (<ulink
            url="http://www.adobe.com">www.adobe.com</ulink>). As yet it is not
          widely adopted, but is likely to become the standard for graphical
          data that is based on vectors (i.e. lines) rather than
          bitmaps.</para>

        <para>For now &argouml; saves diagrams using an earlier proposed
          standard, <emphasis>Portable Graphics Markup Language
          (PGML)</emphasis>. However it has the option to export graphical data
          as SVG for those who can make use of it.</para>
      </sect3>

      <!-- OCL -->

      <sect3>
        <title>Object Constraint Language (OCL)</title>

        <para><emphasis>Object Constraint Language (OCL)</emphasis> is the
          UML standard for expressing constraints within diagrams that express
          the dynamic behavior of a design.</para>

        <para>At present OCL is quite new and not widely available. &argouml;
          is one of the few CASE tools to provide comprehensive support.</para>
      </sect3>
    </sect2>

    <!-- Why it is in pure Java -->

    <sect2>
      <title>100% Pure Java</title>

      <para>Java was conceived as an interpreted language. It doesn't have a
        compiler to produce code for any particular target machine. It compiles
        code for its own target, the <emphasis>Java Virtual Machine
        (JVM)</emphasis>.</para>

      <para>Writing an interpreter for a JVM is much easier than writing a
        compiler, and such machines are now incorporated into almost every Web
        Browser. As a result most machines can run Java, with no further
        work.</para>

      <para>(In case you wonder why all languages aren't like this, it is
        because interpreted languages tend to be slower than compiled
        languages. However with the high performance of modern PCs, the
        trade-off for portability is worthwhile for many
        applications. Furthermore modern multi-level caches can mean that
        interpreted languages, which produce denser code, may actually not be
        that much slower anyway.)</para>

      <para>By choosing to write &argouml; in pure Java, it is immediately made
        available to the maximum number of users with the minimum amount of
        effort.</para>
    </sect2>

    <!-- Open Source -->

    <sect2>
      <title>Open Source</title>

      <para>&argouml; is an <emphasis>open source</emphasis> project. That
        means anyone can have a free copy of the source code, change it, use it
        for new purposes and so on. The only (major) obligation is that you
        pass your code on in the same way to others. The precise nature of what
        you can and can't do varies from project to project, but the principle
        is the same.</para>

      <para>The advantage is that a small project like &argouml; suddenly is
        open to a lot of additional help from those who can chip in their ideas
        for how the program might be improved. At any one time their may be 10,
        15, 20 or more people making significant contributions to &argouml;. To
        do that commercially would cost $1m+ per year.</para>

      <para>Its not just a spirit of pure altruism. Contributing is a way of
        learning <quote>hands-on</quote> about leading edge software. Its a way
        of getting a lot of visibility (over 100,000 people had downloaded
        &argouml; by the spring of 2001). That's a lot of good experience on a
        resum&eacute; and a lot of potential employers seeing you!</para>

      <para>And its great for the ego!</para>

      <para>Open Source doesn't preclude making money. Gentleware <ulink
        url="http://www.gentleware.com">www.gentleware.com</ulink> sell a
        commercial version of &argouml;, Poseidon. Their value proposition is
        not a piece of private code. Its the commercial polish and support that
        take risk out of using &argouml; in a commercial development, allowing
        customers to take advantage of &argouml;'s leading edge
        technology.</para>
    </sect2>
  </sect1>

  <!-- Get started with Argo/UML -->

  <sect1>
    <title>&argouml; Basics</title>

    <para>The aim of this section is to get you started with &argouml;. It
      takes you through obtaining the code and getting it running.</para>

    <sect2>
      <title>Getting Started</title>

      <para>You have three options for obtaining &argouml;.</para>

      <orderedlist>
        <listitem><para>Run &argouml; directly from the Web Site using Java
          Web Start. This is the easiest option.</para></listitem>

        <listitem><para>Download the binary code. This is the right option if
          you intend using &argouml; regularly and is not that
          difficult.</para></listitem>

        <listitem><para>Download the source code using CVS and build your own
          version. Choose this option if you want to look at the internal
          workings of &argouml;, or want to join in as a
          developer.</para></listitem>
      </orderedlist>

      <para>All three options are freely available through the project web
        site,
        <ulink url="http://argouml.tigris.org">argouml.tigris.org</ulink>.
      </para>

      <para>If you choose to download the binary, you will have a choice of
        downloading the latest stable version of the code (which will be more
        reliable, but not have all the latest features), or the current version
        (which will be less reliable, but have more features). Choose according
        to your own situation.</para>

      <!-- Using Java Web Start -->

      <sect3>
        <title>&argouml; using Java Web Start</title>

        <para>There are two steps to this.</para>

        <orderedlist>
          <listitem><para>Install Java Web Start on your machine. This is
            available from <ulink
            url="http://java.sun.com/products/javawebstart">
            java.sun.com/products/javawebstart</ulink>, or via the
            <literal>Java Web Start</literal> link on the &argouml; <ulink
              url="http://argouml.tigris.org">home
            page</ulink>.</para></listitem>

          <listitem><para>
Click on the
<literal>Launch latest stable release</literal> 
link on the &argouml; 
<ulink url="http://argouml.tigris.org">home page</ulink>.
</para>
          </listitem>
        </orderedlist>

        <para>Java Web Start will download ArgoUML, cache it and start it the
          first time, then on subsequent starts, check if ArgoUML is updated
          and only download any updated parts and then start it. The &argouml;
          <ulink url="http://argouml.tigris.org">home page</ulink> also
          provides details on starting &argouml; from the Java Web Start
          console.
        </para>

      </sect3>

      <!-- How to download the files -->

      <sect3>
        <title>Downloading &argouml;</title>

        <para>Since &argouml; is written in 100% pure Java, it should run on
          any machine with a Java Engine. Java2, version 1.3 or later is
          needed. You may have this in place, but if not it can be downloaded
          free from Sun MicroSystems
          (<ulink url="http://www.sun.com">www.sun.com</ulink>). Note that you
          only need the Java Runtime Environment (JRE), there is no need to
          download the whole Java Development Kit (JDK).</para>

        <para>&argouml; needs a reasonable amount of computing resource. A PC
          with 300MHz processor, 64Mb RAM and 10Mb of disk should be
          adequate. Download the code from Download section of the project
          website
          <ulink url="http://argouml.tigris.org">argouml.tigris.org</ulink>.
          Choose the version that suits your needs as described in the section
          above.</para>

        <para>&argouml; comes in <literal>.zip</literal> or
          <literal>tar.gz</literal> flavors. Choose the former if you are a
          Microsoft Windows user, and the latter if you are running some
          flavor of Unix. Unpacking is as follows.</para>

        <itemizedlist>
          <listitem><para>On Windows. Unzip the <literal>.zip</literal> file
            with WinZip, or on later versions of Windows (ME, XP) copy the
            files out of the compressed folder and put them into a directory of
            your choosing.</para></listitem>

          <listitem><para>Use GNU tar to unzip and break out the files to a
            directory of your choice
            <literal>tar&nbsp;zxvf&nbsp;&lt;file&gt;.tar.gz</literal>. If you
            have an older version of tar, the <literal>z</literal> option may
            not be available, so use
            <literal>gunzip&nbsp;&lt;&nbsp;file.tar.gz&nbsp;|&nbsp;tar&nbsp;xvf&nbsp;-</literal>.
          </para></listitem>
        </itemizedlist>

        <para>You should have a directory containing the following files:
          <literal>antlrall.jar</literal>, <literal>gef.jar</literal>,
          <literal>nsuml.jar</literal>, <literal>README.txt</literal>,
          <literal>argouml.jar</literal>, <literal>log4j.jar</literal>,
          <literal>ocl-argo.jar</literal> and
          <literal>xerces.jar</literal>. To run &argouml; depends on whether
          you are a Microsoft Windows or Unix user.</para>

        <itemizedlist>
          <listitem><para>On Windows. Start a MSDOS shell window. Use Start/Run
            with the default <quote>command</quote>. In the window change to
            the directory holding your &argouml; files and type
            <literal>java&nbsp;-jar&nbsp;argouml.jar</literal>
          </para></listitem>

          <listitem><para>Start a shell window and type
            <literal>java&nbsp;-jar&nbsp;argouml.jar</literal>
          </para></listitem>
        </itemizedlist>

        <!-- Possible Problems downloading -->

        <sect4 id="s4.probsolving">
          <title>Problems Downloading</title>

          <para>If you get completely stuck and you have no local assistance,
          try the web site, particularly the
          <ulink
            url="http://argouml.tigris.org/faqs/users.html">
            FAQ</ulink>. If this still doesn't solve the problem, try the
          &argouml; users' mailing list.</para>

          <para>You can subscribe through the mailing lists section of the
            project web site
            <ulink url="http://argouml.tigris.org">argouml.tigris.org</ulink>,
            or send an empty message to
            <ulink url="mailto:users@argouml.org">users@argouml.org</ulink>
            with the subject line <literal>subscribe</literal>.</para>

          <para>You can then send your problem to 
            <ulink url="mailto:users@argouml.org">users@argouml.org</ulink> and
            see how other users are able to help.</para>

          <para>The users' mailing list is an excellent introduction to the
            live activity of the project. If you want to get further involved
            there are additional mailing lists that cover the development of
            the product and issues in the current and future releases.</para>
        </sect4>

        <!-- Possible Problems running -->

        <sect4>
          <title>Problems Running &argouml;</title>

          <para>It's unusual to encounter problems if you have made a
            successful download. Most common issue is not having a new enough
            Java Runtime Environment (it must be 1.2 or later).</para>

          <para>If you can't solve the problem. Try the users' mailing list
            (see <xref linkend="s4.probsolving"/>).</para>
        </sect4>
      </sect3>
    </sect2>

    <!-- Now give an outline of the User Interface -->

    <sect2>
      <title>The &argouml; User Interface</title>

      <para><xref linkend="fig.tut.guioverview"/> shows the main &argouml;
        window.</para>

      <!-- A big diagram with all the bits pointed out. At the moment its
           just a plane screenshot, but it would be nice to float in some
           bubbles pointing out things. -->

      <figure id="fig.tut.guioverview" float="1">
        <title>Overview of the &argouml; window</title>

        <screenshot><mediaobject>
          <imageobject>
            <imagedata format="GIF" align="center"
                       fileref="images/tutorial/guioverview.gif"/>
          </imageobject>
        </mediaobject></screenshot>
      </figure>

      <para>
At the top of screen is a <emphasis>menu bar</emphasis>.
Under that there are Toolbars.
Then the bulk
        of the window comprises four sub-windows or
        <emphasis>Panes</emphasis>. Clockwise from top left these are the
        <emphasis>Explorer</emphasis>, <emphasis>Editing
        Pane</emphasis>, <emphasis>Details Pane</emphasis> and
<emphasis>To-Do Pane</emphasis>.
At the top of the Editing Pane is another <emphasis>toolbar</emphasis>
called the Edit Pane Toolbar.
Finally at the bottom of the window is
        a <emphasis>status bar</emphasis>.</para>

      <!-- Subsection describing the Explorer -->

      <sect3>
        <title>The Explorer</title>

        <para>
<xref linkend="fig.tut.exploreroverview"/> shows the Explorer.
</para>

        <figure id="fig.tut.exploreroverview" float="1">
          <title>Overview of the Explorer</title>

          <screenshot><mediaobject>
            <imageobject>
              <imagedata format="GIF" align="center"
                         fileref="images/tutorial/exploreroverview.gif"/>
            </imageobject>
          </mediaobject></screenshot>
        </figure>

        <para>
This is the explorer, where we can navigate through our model.
This pane list all the classes, interfaces and data types of
our model as a tree view.
</para>
      </sect3>

      <!-- Subsection describing the Editing Pane -->

      <sect3>
        <title>The Editing Pane</title>

        <para><xref linkend="fig.tut.editoverview"/> shows the Editing
          Pane.</para>

        <figure id="fig.tut.editoverview" float="1">
          <title>Overview of the Editing Pane</title>

          <screenshot><mediaobject>
            <imageobject>
              <imagedata format="GIF" align="center"
                         fileref="images/tutorial/editoverview.gif"/>
            </imageobject>
          </mediaobject></screenshot>
        </figure>

        <para>
This is the Editing Pane, where we can edit our diagram in 
a graphical way.
</para>
      </sect3>

      <!-- Subsection describing the Details Pane -->

      <sect3>
        <title>The Details Pane</title>

        <para><xref linkend="fig.tut.detailsoverview"/> shows the Details
          Pane.</para>

        <figure id="fig.tut.detailsoverview" float="1">
          <title>Overview of the Details Pane</title>

          <screenshot><mediaobject>
            <imageobject>
              <imagedata format="GIF" align="center"
                          fileref="images/tutorial/detailsoverview.gif"/>
            </imageobject>
          </mediaobject></screenshot>
        </figure>

        <para>
This is the Details Pane, 
that allows us to edit various details of our model.
</para>
      </sect3>

      <!-- Subsection describing the To-Do Pane -->

      <sect3>
        <title>The To-Do Pane</title>

        <para><xref linkend="fig.tut.todooverview"/> shows the To-Do
          Pane.</para>

        <figure id="fig.tut.todooverview" float="1">
          <title>Overview of the To-Do Pane</title>

          <screenshot><mediaobject>
            <imageobject>
              <imagedata format="GIF" align="center"
                         fileref="images/tutorial/todooverview.gif"/>
            </imageobject>
          </mediaobject></screenshot>
        </figure>

        <para>
The To-Do Pane displays the items on the models to-do list in a tree
which sorts the list in a number of different ways.  
A drop down selection box at the top of the pane determines the layout
of the tree.
</para>
      </sect3>

      <!-- More about the Menu Bar -->

      <sect3>
        <title>The Menu Bar and Toolbars</title>
	<indexterm>
	  <primary>Menu Bar</primary>
	</indexterm>
	<indexterm>
	  <primary>Toolbars</primary>
	</indexterm>

        <para>
The menu bar and toolbars gives access to all the main features of
&argouml;. 
As is conventional, menu options and toolbar options that are not available
          are grayed out and menu items that invoke a dialog box are followed
          by an ellipsis (&hellip;).</para>

        <itemizedlist>
          <listitem>
	    <indexterm>
	      <primary>File menu</primary>
	    </indexterm>
	    <para>
<emphasis>File</emphasis> menu. 
This allows you to
            create a new project, save and open projects, import sources from
            elsewhere, load and save the model to and from a database, print
            the model, save the graphics of the model, save the configuration
            of the model and exit &argouml;</para></listitem>

          <listitem>
	    <indexterm>
	      <primary>Edit menu</primary>
	    </indexterm>
	    <para>
<emphasis>Edit</emphasis> menu. 
This allows you to
            select one or more UML items on a diagram, undo and redo edits,
            remove items from diagrams or the whole model, empty the trash and
            change settings.</para></listitem>

          <listitem>
	    <indexterm>
	      <primary>View menu</primary>
	    </indexterm>
	    <para>
<emphasis>View</emphasis> menu. 
This allows you to
            switch between diagrams, find artifacts in the model, zoom in a
            diagram, select a particular diagram representation (although at
            present there is only one), select a particular tab in the details
            menu, adjust the grid, view buttons on a selection, and switch
            between UML and Java notation.</para></listitem>

          <listitem>
	    <indexterm>
	      <primary>Create Diagram menu</primary>
	    </indexterm>
	    <para>
<emphasis>Create Diagram</emphasis> menu. 
This allows
            you to create any one of the seven UML diagram types (class, use
            case, state, activity, collaboration, deployment and sequence)
            supported by &argouml;.</para>

	    <para>
State and activity diagrams can only be created when
            a class or actor is selected, even though the relevant menu entries
            are <emphasis>not</emphasis> grayed out if this has not been done
            (nothing will happen under this
circumstance).
</para>
	  </listitem>

          <listitem>
	    <indexterm>
	      <primary>Arrange menu</primary>
	    </indexterm>
	    <para>
<emphasis>Arrange</emphasis> menu.
This allows you to
            align, distribute, reorder and nudge artifacts on a diagram and set
            the layout strategy for the diagram.</para></listitem>

          <listitem>
	    <indexterm>
	      <primary>Generation menu</primary>
	    </indexterm>
	    <para>
<emphasis>Generation</emphasis> menu. 
This allows you
            to generate Java code for selected classes or all
            classes.</para></listitem>

          <listitem>
	    <indexterm>
	      <primary>Critique menu</primary>
	    </indexterm>
	    <para>
<emphasis>Critique</emphasis> menu. 
This allows you
            to toggle the auto-critique on and off, set the level of importance
            of design issues and design goals and browse the critics
            available.</para></listitem>

          <listitem>
	    <indexterm>
	      <primary>Tools menu</primary>
	    </indexterm>
	    <para>
<emphasis>Tools</emphasis> menu. 
This menu is permanently grayed out unless there is some tool available
in your version of &argouml;.
</para>
	  </listitem>

          <listitem>
	    <indexterm>
	      <primary>Help menu</primary>
	    </indexterm>
	    <para>
<emphasis>Help</emphasis> menu. 
This menu gives
            access to details of those who authored the system, and where
            additional help may be found.</para></listitem>

	  <listitem>
	    <indexterm>
	      <primary>File Toolbar</primary>
	    </indexterm>
	    <para>
File Toolbar.
This toolbar contains some of the tools from the File menu.
</para>
	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>Edit Toolbar</primary>
	    </indexterm>
	    <para>
Edit Toolbar.
This toolbar contains some of the tools from the Edit menu.
</para>
	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>View Toolbar</primary>
	    </indexterm>
	    <para>
View Toolbar.
This toolbar contains some of the tools from the View menu.
</para>
	  </listitem>

	  <listitem>
	    <indexterm>
	      <primary>Create Diagram Toolbar</primary>
	    </indexterm>
	    <para>
Create Diagram Toolbar.
This toolbar contains some of the tools from the Create Diagram menu.
</para>
	  </listitem>

        </itemizedlist>
      </sect3>

      <!-- More about mice. Note this is linked to the section "General Mouse
           Behavior in the reference chapter "Top Level Artifact Reference" -->

      <sect3 id="s3.tut.mouse">
        <title>The Mouse</title>

        <para>The mouse and mouse buttons (or their equivalent with alternative
          tracking devices) are used in a wide variety of ways. In this section
          we look at the common modes of use. </para>

        <para>&argouml; assumes a two button mouse. We will refer to the
          buttons as <quote>&button1;</quote> and <quote>button
          2</quote>. &Button1; is the leftmost button on a right-handed
          mouse, and sometimes referred to as the <quote>select</quote>
          button. &Button2; is sometimes referred to as the
          <quote>adjust</quote> button.</para>

        <orderedlist>
          <listitem><para><emphasis>&Button1; click</emphasis>. This action
            is generally used to select an item for subsequent operations. If
            the item is an artifact in the explorer or the editing pane it
            will be highlighted.</para>

          <para>
In the case of the Edit Pane Toolbar, that artifact is
            selected as the next to be added to the diagram (but only
            once&mdash;see double clicking for adding multiple artifacts). The
            adding to the diagram is achieved by moving the mouse to the
            editing area and clicking again.</para></listitem>

          <listitem><para><emphasis>&Button1; double click</emphasis>. This
            action is identical to a single click <emphasis>except</emphasis>,
when it is used with the edit pane toolbar. 
Under these
            circumstances the selected artifact will be added multiple times to
            the drawing area, once for each further button click, until the
            tool is again selected or another tool chosen.</para></listitem>

          <listitem><para><emphasis>&Button2; click</emphasis>. When used
            over text items in the the explorer or details panes, or
            graphical artifacts in the editing pane, this will display a context
            dependent drop-down menu.</para>

          <para>If the item has not yet been selected it will also be
            selected.</para></listitem>

          <listitem><para><emphasis>&Button1; motion</emphasis>. Where
            &button1; click has been used to pull down a menu from the menu
            bar, &button1; motion is used to select items on that
            menu.</para>

          <para>&Button1; motion also has an effect in the editing
            pane. Over graphical artifacts it will move the artifact to a new
            position. Graphical artifacts that are selected show handles, and
            these can be used for re-sizing.</para>

          <para>Where the artifact is some form of connector between other items,
            &button1; motion other than at a handle will cause a new handle
            to be created, allowing the connector to be articulated at that
            point. Such new handles can be removed by moving them to the end of
            the connector.</para></listitem>

          <listitem><para><emphasis>&Button2; motion</emphasis>. This is
            used to select items in a context sensitive menu popped up by use
            of &button2; click.</para></listitem>
        </orderedlist>

        <para>There are other more specific behaviors that will be encountered
          under the specific cases where they are used.</para>
      </sect3>

      <!-- How to draw -->

      <sect3>
        <title>Drawing Diagrams</title>

        <para>
In general diagrams are drawn by using the edit pane toolbar
          to select the artifact desired and clicking in the diagram at the
          position required as described in <xref linkend="s3.tut.mouse"/>. That
          section also explains the use of the mouse for re-sizing
          artifacts.</para>

        <para>Artifacts that are already in the model, but not on a diagram, may
          be added to a diagram by selecting the artifact in the explorer,
          using <literal>Add&nbsp;to&nbsp;Diagram</literal> from the drop down
          menu (&button2;) over that artifact, and then clicking
          &button1; at the desired location on the diagram.</para>

        <para>
As well as UML artifacts, the Edit pane toolbar provides for general drawing
          artifacts (rectangles, circles, lines, polygons, curves, text) to
          provide supplementary information on diagrams.</para>

        <!-- Moving diagram elements about -->

        <sect4>
          <title>Moving Diagram Elements</title>

          <para>There are several ways to move diagram elements.</para>

          <!-- Using mouse keys -->

          <sect5>
            <title>Using the Mouse Keys</title>

            <para>Select the elements you want to move. By holding down the
              control key you can select several.</para>

            <para>Now hit your arrow keys. Your elements move a little with
              every key stroke.</para> 

            <para>If you also hold down the shift key, they move a bit
              faster.</para>
          </sect5>

          <!-- Using the toolbar -->

          <sect5>
            <title>Using the Edit Pane Toolbar</title>

            <para>
Click on the broom button on the toolbar. 
Move your mouse to
             the diagram pane, right click and hold. Now moving your mouse will
             align elements.</para>
          </sect5>
        </sect4>

        <!-- Arranging Elements -->

        <sect4>
          <title>Arranging Elements</title>  

          <para>The menu item <literal>Arrange</literal> allows you to align,
            group, or nudge elements.</para>
        </sect4>
      </sect3>

      <sect3>
        <title>Working with Projects</title>

        <!-- Thanks to Alejandro, Philippe and Andreas for this text -->

        <sect4>
          <title>The Start-up Window</title>

          <para><xref linkend="fig.tut.startup"/> shows the &argouml; main window
            as it appears as right after start-up</para>

          <!-- A figure of the Argo/UML start-up window -->

          <figure id="fig.tut.startup" float="1">
            <title>&argouml; window at start-up</title>

            <screenshot><mediaobject>
              <imageobject>
                <imagedata format="GIF" align="center"
                           fileref="images/tutorial/startup.gif"/>
              </imageobject>
            </mediaobject></screenshot>
          </figure>

          <para>
The main window's client area, below the menu and toolbar, is
            subdivided into four panes. Starting at the leftmost top pane, and
            working around the clock, you can see the Explorer, showing
a tree view of your UML model, 
the Editing Pane with its toolbar, 
two scroll bars and gray drawing area, 
the Details
            Pane with the ToDoItem tab selected, and the To-Do Pane with a tree
            view of the to do items, 
ranked in various ways selected via the drop down list 
at the top of the pane.
</para>

<!-- The title bar does not seem to contain the project name anymore.
     Where is it? Issue: 493
          <para>Notice that the title bar says
            <literal>&argouml;&nbsp;-&nbsp;Untitled</literal>. The
            <quote>Untitled</quote> means that the current project has not yet
            been saved. After saving the current project, the
            <quote>Untitled</quote> will be replaced by the file name of the
            current project.</para>
 -->

          <para>Each time &argouml; is started up without a project file as an
            argument, a new blank project is created. This project contains a
            model called <literal>untitledModel</literal>. This model contains
            a blank Class Diagram, called
            <literal>class&nbsp;diagram&nbsp;1</literal>, and a blank Use 
            Case Diagram called
            <literal>use&nbsp;case&nbsp;diagram&nbsp;1</literal>.</para>

          <para>The model and both empty diagrams can be seen in the explorer,
            which is the main tool for you to navigate through your
            model.</para>

          <para>Let's assume for a moment that this is the point where you want
            to start modeling a new purchasing system. You want to give the
            name <quote>purchasingmodel</quote> to your model, and you want to
            store it in a file called <literal>FirstProject</literal>.</para>
        </sect4>

        <sect4>
          <title>Saving a project - The File Menu</title>

          <para>First, let's save the model in it's current (empty and unnamed)
            state. On the menu bar, click on <literal>File</literal>, then on
            <literal>Save&nbsp;Project&nbsp;As&hellip;</literal> as shown in
            <xref linkend="fig.tut.saveas"/>.</para>

          <!-- A figure of the Argo/UML Save Project As drop down menu
               option. -->

          <figure id="fig.tut.saveas" float="1">
            <title>Invoking
              <literal>Save&nbsp;Project&nbsp;As&hellip;</literal></title>

            <screenshot><mediaobject>
              <imageobject>
                <imagedata format="GIF" align="center"
                           fileref="images/tutorial/saveas.gif"/>
              </imageobject>
            </mediaobject></screenshot>
          </figure>

          <para>Please notice that the File menu contains the usual options for
            creating a new project, for opening an existing project, for saving
            a project under a new name, for printing the currently displayed
diagram,
for saving the
            currently displayed diagram as a file, and for program Exit.</para>

          <para>Some of these menu commands can be invoked by pressing key
            combinations, as indicated on the drop-down menu. For instance,
            holding down the <quote>Ctrl</quote> key, and pressing
            <quote>N</quote>, will create a new project.</para>

          <para>In the current version, &argouml; can only contain one active
            project at a time. In addition, a project can only contain one UML
            model. Since an UML model can contain an unlimited number of
            elements and diagrams, this should not present any serious
            limitations, even for modeling quite large and complex
            systems.</para>

        </sect4>

        <!-- Choosing the file to save as -->

        <sect4>
          <title>The File Chooser Dialog</title>

          <para>But let's go back to saving our project. After clicking on the
            <literal>Save&nbsp;Project&nbsp;As&hellip;</literal> menu command,
            we get the file chooser dialog to enter the file name we wish to
            use as shown in <xref linkend="fig.tut.filechoose"/>.</para>

          <!-- A figure of the Argo/UML file choice dialog -->

          <figure id="fig.tut.filechoose" float="1">
            <title>File chooser dialog</title>

            <screenshot><mediaobject>
              <imageobject>
                <imagedata format="GIF" align="center"
                           fileref="images/tutorial/filechoose.gif"/>
              </imageobject>
            </mediaobject></screenshot>
          </figure>

          <para>This is a standard Java FileChooser. Let's go over it in some
            detail.</para>

          <para>The main, outstanding feature, is the scrollable folders list
            in the center of the dialog. By using the scroll bar on the right,
            you can move up and down in the list of folders contained inside
the currently selected folder.
If it is scrollable or not depends on the amount of files and folders shown 
and also how they are shown.
If everything fits the window is not scrollable as seen in the picture.
</para>

          <para>Double-clicking on one of the displayed folders navigates you
            into that folder, allowing you to quickly navigate down into the
            folders hierarchy on your hard disk.</para>

          <para>Notice that only folder names, and no file names are displayed
            in the scrollable area. Indeed, the dialog is currently set up in
            order to show only &argouml; project files with an extension of
<literal>.zargo</literal>, as can be seen on the lower drop-down
control labeled <literal>Files&nbsp;of&nbsp;Type:</literal>.
</para>

          <para>Also notice that the currently selected folder's name is
            displayed in the upper drop-down control labeled
            <literal>Look&nbsp;in:</literal>. A single click on a folder inside
            the scrollable area does select that folder on screen but does not
            select the folder for saving.</para>

          <para>At the top of the dialog, above the scrollable folder chooser
          area, there are a few more folder navigation tools.</para>

          <itemizedlist>
            <listitem><para>
              <guiicon>
                <inlinegraphic format="GIF"
                              fileref="images/tutorial/guifolderdropdown.gif"/>
              </guiicon> The Folder drop-down control. Clicking on the
              down-arrow displays a tree view of the folder hierarchy,
              allowing you to navigate quickly up the hierarchy, and at
              the same time to quickly determine where in the hierarchy
we are currently positioned.
</para>
	    </listitem>

            <listitem><para>
              <guiicon>
                <inlinegraphic format="GIF"
                  fileref="images/tutorial/guifolderupicon.gif"/>
              </guiicon>
The Folder-Up icon. 
Clicking on this icon will bring us to 
the parent folder of the current folder.
</para>
	    </listitem>

            <listitem><para>
              <guiicon>
                <inlinegraphic format="GIF"
                  fileref="images/tutorial/guihomefoldericon.gif"/>
              </guiicon> The Home Folder icon. Clicking on this icon will bring
us to our home directory.
</para>
	    </listitem>

            <listitem><para>
              <guiicon>
                <inlinegraphic format="GIF"
                  fileref="images/tutorial/guinewfoldericon.gif"/>
              </guiicon> The New Folder icon. Clicking on this icon will create
a new folder called "New Folder" under the current folder.
After the folder is created selecting it an clicking in the name
allows us to select the name of our choice.
</para>
	    </listitem>

            <listitem><para>
              <guiicon>
                <inlinegraphic format="GIF"
                  fileref="images/tutorial/guifolderspresentationicon.gif"/>
                </guiicon>
The Folders Presentation Icon.
</para>
	    </listitem>
          </itemizedlist>

          <para>
OK, now we navigate to the directory where we want to save our
            &argouml; project, fill in the <literal>File&nbsp;name:</literal>
            with an appropriate name, such as <quote>FirstProject</quote> and
            click on the <literal>Save</literal> button.</para>

          <para>You have now an active project called
            <literal>FirstProject</literal>, connected to the file
<literal>FirstProject.zargo</literal>.
</para>
        </sect4>
      </sect3>
    </sect2>

    <!-- Output from Argo/UML. Taken from Alejandro, Philippe and Andreas -->

    <sect2>
      <title>Output</title>
      
      <!-- Loading and Saving Files -->

      <sect3 id="s3.tut.loadsave">
        <title>Loading and Saving</title>

        <!-- Saving XMI files -->

        <sect4>
          <title>Saving XMI files in ArgoUML</title>

          <para>&argouml; saves the diagram information in a PGML file (with
            extension <literal>.pgml</literal>, the model information in an XMI
            file (with extension <literal>.xmi</literal> and information about
            the project in a file with extension <literal>.argo</literal>. See
            <xref linkend="s4.tut.pgml"/> and <xref linkend="s3.tut.xmi"/> for more
            about PGML and XMI respectively.</para>

          <para>All of these are then zipped to a file with extension
            <literal>.zargo</literal>. You can easily extract the
            <literal>.xmi</literal> file from the <literal>.zargo</literal>
            file using any old generic <application>ZIP</application>
            application. Give it a try and look into the magic of Argo.</para>

          <warning>
	    <!-- This is not an issue for ArgoUML but 
	    for the windows explorer.
	    -->
	    <para>
Be aware that double clicking will launch a
<literal>ZIP utility</literal>, if one is installed, and NOT
Argo.
</para>
	  </warning>
        </sect4>
      </sect3>

      <!-- All about Graphics and Printing -->

      <sect3>
        <title>Graphics and Printing</title>

        <!-- The Graph Editing Framework -->

        <sect4>
          <title>The Graph Editing Framework (GEF)</title>

          <para>
GEF is the software package that is 
the foundation of the diagrams 
that appear in the Editing Pane.  
GEF was an integral part of ArgoUML but has been separated.
Like ArgoUML it is an open source project available via 
<ulink url="http://www.tigris.org">Tigris</ulink>.
</para>
        </sect4>

        <!-- PGML -->

        <sect4 id="s4.tut.pgml">
          <title>Precision Graphics Markup Language (PGML)</title>

          <para>PGML is the saving format for diagram information used in
            &argouml;. Although this is outdated a little, it shows why we
            chose PGML in the first place. In the future, PGML will be replaced
            by an extended XMI format which will include graphical
            representation.</para>

          <para>In April 1998 Adobe Systems proposed a new Standard for Vector
            Graphics to the World Wide Web Consortium (W3C), which should
            facilitate the creation and usage of image material in the World
            Wide Web. It will be replaced by SVG. We will support SVG by
            generating it from the XMI in the future.</para>
        </sect4>

        <!-- Using PGML -->

        <sect4>
          <title>Applications Which Open PGML</title>

          <para>PGML is a predecessor of SVG (see
            <xref linkend="s4.tut.svg"/>. It was dropped by the W3C
            Consortium.</para>  

          <para>Currently there are no other tools that we know of working on
PGML.
</para>
        </sect4>

        <!-- Printing Diagrams -->
        
        <sect4>
          <title>Printing Diagrams</title>

          <para>Select a diagram, then go to
          <literal>File</literal>&rarr;<literal>Export&nbsp;Diagrams</literal>.
            You can generate GIF, PostScript, Encapsulated PostScript or SVG
            format.</para>

        </sect4>

        <!-- What is SVG -->

        <sect4 id="s4.tut.svg">
          <title>Scalable Vector Graphics (SVG)</title>

          <para>A super cool vector graphics format (like MM Flash) that is
            totally open and is gaining enormous ground in the graphics
            world. Find out more at
            <ulink url="http://www.w3c.org">www.w3c.org</ulink>.</para>

          <para>As well visit
            <ulink url="http://www.adobe.com">adobe.com</ulink> for the plugin
            for Netscape Navigator and Internet Explorer.</para> 
        </sect4>

        <!-- Saving diagrams using SVG -->

        <sect4>
          <title>Saving Diagrams as SVG</title>

          <orderedlist>
            <listitem><para>Select <literal>.svg</literal> as the file
              type.</para></listitem>

            <listitem><para>Type the name of the file as you like with the
              <literal>.svg</literal> tag at the end. Example
              <literal>myumldiagram.svg</literal></para>
	    </listitem>
          </orderedlist>

          <para> Et viola! SVG! Give it a try and zoom around a little&hellip;
            They are not pretty though, so if you know anything about rendering
            beautiful SVG let us know!</para>

          <para>Oh, and by the way, you'll need a browser that can read
            SVG. See <ulink url="http://www.adobe.com">adobe.com</ulink> for
            the plugin for Netscape Navigator and Internet Explorer</para>

          <para>There are a few browsers that read SVG natively:
            <application>Amaya</application>,
            <application>X-Smiles</application>, and a rudimentary version of
            <application>Mozilla.</application></para> 

          <note><para>You will not have scroll bars for your SVG unless it is
            embedded into an HTML! Good luck and let us know what you
            find!</para></note>
        </sect4>
      </sect3>

      <!-- XMI -->

      <sect3 id="s3.tut.xmi">
        <title>XMI</title>

        <para>There is now a tool available which supports various dialects of
          XMI and their interconversion. This should make portability of
different models in to ArgoUML considerably easier.
Any work on using this with &argouml; would be much appreciated.
</para>

        <para>There is also a tool that converts XMI to HTML. For more
          information, see <ulink
          url="http://www.objectsbydesign.com/projects/xmi_to_html_2.html">
          http://www.objectsbydesign.com/projects/xmi_to_html_2.html</ulink>.
        </para>

        <!-- Using Rational Rose XMI -->

        <sect4>
          <title>Using XMI from Rational Rose</title>

          <para>It is probably not possible to take a model generated by
            Rational Rose in XMI format and put it into &argouml;
            directly.</para>

          <para>The conversion tool identified above will probably solve the
            problem. If you can document how this is done, you'd make a lot of
            friends in a hurry!</para>
        </sect4>

        <!-- Using Gentleware XMI -->

        <sect4>
          <title>Using Models Created by Gentleware</title>

          <para>Gentleware is a commercial development based on &argouml;. It
            diverged a little while ago and the XMI representations are no
            longer full compatible.</para>

          <para>Eugenio Alvarez suggests the following procedure to convert a
            Gentleware project for use with &argouml;. It works if there are no
            sequence diagrams in the project.</para>

          <orderedlist>
            <listitem><para>Make sure to backup your project
              first.</para></listitem>

            <listitem><para>Unpackage the Gentleware project Project.zargo. For
              example <literal>unzip&nbsp;Project.zargo</literal> or
              <literal>jar&nbsp;xvf&nbsp;Project.zargo</literal>.
            </para></listitem>

            <listitem><para>Then try reading and then saving the project with
UMLTool (Contact Eugenio Alvarez to get this tool).
</para>
	    </listitem>

            <listitem><para>Repackage the project. For example
              <literal>zip&nbsp;NewProject.zargo&nbsp;*.xmi&nbsp;*.pgml&nbsp;*.argo</literal>
              or <literal>jar&nbsp;cvf&nbsp;NewProject.zargo&nbsp;*</literal>.
            </para></listitem>

            <listitem><para>Try reading the project with
              ArgoUML.</para></listitem> 
          </orderedlist>
        </sect4>

        <!-- Interchangeability of Argo/UML XMI between versions -->

        <sect4>
          <title>XMI Interchangeability between &argouml; 0.8.1a and
0.10, 0.12, and 0.14
</title>

          <para>
This depends on the version of NSUML 
(the UML engine underlying &argouml;) you are using. 
Look in the start-up messages on the console for 
the entry for Novosoft UML Library for the version number.
Using version 0.4.19 is OK, and the XMI files should
be interchangeable.
</para>
        </sect4>

        <!-- Importing XMI into ArgoUML -->

        <sect4>
          <title>Importing Other XMI Formats into &argouml;</title>

          <para>Because of the variety of XMI formats being generated you will
            encounter problems using XMI files generated from other
            applications.  &argouml;'s native storage format is another
            implementation of XMI (Curt Arnold believes that it has been hacked
            so it can also read the Unisys variant).  He recommends that if you
            are comfortable with XSLT, you can typically transform one variant
            of UML and XMI to another, plus MetaIntegrations
            <ulink
              url="http://www.metaintegrations.net">www.metaintegrations.net
              </ulink> makes a version of their
            <application>Bridge</application> product available to transform
            between XMI flavors.</para>
        </sect4>

        <!-- Generating the XMI format -->

        <sect4>
          <title>Generating XMI Format</title>

          <para>
Select the command 
<literal>Tools</literal>&rarr;<literal>Export&nbsp;as&nbsp;XMI</literal>
and choose a filename.
</para>
        </sect4>
      </sect3>

      <!-- All about code generation -->

      <sect3>
        <title>Code Generation</title>

        <!-- What sort of code is generated -->

        <sect4>
          <title>Code Generated by &argouml;</title>

          <para>It is possible to compile your generated code with &argouml;,
            you still need to implement method bodies, though, to get usable
            results.</para>
        </sect4>

        <!-- Generating Code for methods -->

        <sect4>
          <title>Generating Code for Methods</title>

          <para>At the moment you cannot write code for methods (operations)
            within &argouml;. The source pane is editable, but the changes are
            ignored.  ArgoUML is a pure design tool for now, no IDE
            functionality but the desire is there. You might consider using
            Forte and ArgoUML together&mdash;it's a good work around!</para>
 
          <para>You can help us out there if you'd like!</para>
        </sect4>
      </sect3>
    </sect2>

    <!-- Working with design critics. Taken from Alejandro, Philippe and
         Andreas -->

    <sect2>
      <title>Working With Design Critics</title>

      <sect3>
        <title>The To-Do Pane&mdash;Messages From the Design Critics</title>

        <para>Where do we stand now? A new project has been created, and is
          connected to the file <literal>FirstProject.argo</literal>.
          <xref linkend="fig.tut.critstart"/> shows how your &argouml; window
          should look at this stage.</para>

        <!-- A figure of the Argo/UML window having saved the project. -->

        <figure id="fig.tut.critstart" float="1">
          <title>&argouml; window having saved
            <literal>FirstProject.argo</literal></title>

          <screenshot><mediaobject>
            <imageobject>
              <imagedata format="GIF" align="center"
                fileref="images/tutorial/critstart.gif"/>
            </imageobject>
          </mediaobject></screenshot>
        </figure>

	<para>
<!--
The project filename is displayed in the title bar, 
-->
The project contains a top-level package, called
          <literal>untitledModel</literal>, which contains a class diagram and
          a use case diagram.</para>

        <para>If we look carefully at the screen, we can see that the "Medium"
          folder in the To Do pane (the lower left pane) must contain some
          items, since its activation icon
          <guiicon><inlinegraphic format="GIF"
            fileref="images/tutorial/guitreefoldercloseicon.gif"/></guiicon> is
          displayed.</para>

        <para>Clicking on this icon will open the "Medium" folder. An open
          folder is indicated by the
          <guiicon><inlinegraphic format="GIF"
            fileref="images/tutorial/guitreefolderopenicon.gif"/></guiicon>
          icon.</para>

        <para>But what is this <quote>To-Do</quote> Pane anyway. You haven't
        recorded anything yet that has to be done, so where do these to do
        items originate.</para>

        <para>The answer is simple, and is at the same time one of the strong
          points of &argouml;. While you are working on your UML model, your
          work is monitored continuously and invisibly by a piece of code
          called a <emphasis>design critic</emphasis>. This is like a personal
          mentor that watches over your shoulder and notifies you each time he
          sees something questionable in your design.</para>

        <para>Critics are quite unobtrusive. They give you a friendly warning,
          but they do not force you into design principles that you don't want
          or like to follow.  Let us take a look at what the critics are
          telling us. Click on the
            <guiicon><inlinegraphic format="GIF"
              fileref="images/tutorial/guitreefoldercloseicon.gif"/></guiicon>
          icon next to the <literal>Medium</literal> folder, and click on the
          <literal>Revise&nbsp;Package&nbsp;Name&nbsp;UntitledModel</literal>
          item.</para>

        <para><xref linkend="fig.tut.critrevname"/> shows how your screen should
          now look.</para>

        <!-- A figure of the Argo/UML showing a critic item. -->

        <figure id="fig.tut.critrevname" float="1">
          <title>&argouml; window showing the critic item
            <literal>Revise&nbsp;Package&nbsp;Name&nbsp;UntitledModel</literal>
          </title>

          <screenshot><mediaobject>
            <imageobject>
              <imagedata format="GIF" align="center"
                fileref="images/tutorial/critrevname.gif"/>
            </imageobject>
          </mediaobject></screenshot>
        </figure>

        <para>Notice that your selection is highlighted in red in the To-Do
          Pane, and that a full explanation appears now in the Details Pane
          (the lower right pane). You may have to re-size your Details Pane or
          to scroll down in order to see the full message as displayed in our
          example.</para>

        <para>What &argouml; is trying to tell you is that usually, package
          names are written in lower cases. The default top level package
          created by &argouml; is called <literal>untitledModel</literal> and
          therefore violates a sound design principle. (Actually, this could be
          considered as a bug within &argouml;, but it comes in handy to
          demonstrate the working of critics).</para>

        <para>At this point, you can choose to change the package name
          manually, to impose silence on the design critic for some time or
          permanently, or to request a more comprehensive explanation by Email
          from an expert.</para>

        <para>We will do nothing of this (we'll come back to it when we talk
          about the design critics in more detail) but we'll use another handy
          feature of ArgoUML&mdash;an auto-correct feature.</para>

        <para>In order to do that, just click on the <literal>Next</literal>
          button on the Details Pane. This will cause a renaming wizard to be
          displayed inside the properties panel, proposing to use the name
          <literal>untitledmodel</literal> (all in lower case).</para>
      </sect3>

      <!-- The Design Critic being used -->

      <sect3>
        <title>Design Critics at Work: The Rename Package Wizard</title>

        <para>Replace the name <literal>untitledmodel</literal> with
          <literal>purchasingmodel</literal>, and click on the
          <literal>Finish</literal> button. <xref linkend="fig.tut.critwiz"/>
          shows how the &argouml; window will now look.</para>

        <!-- A figure of the Argo/UML showing a critic wizard -->

        <figure id="fig.tut.critwiz" float="1">
          <title>&argouml; window showing the critic wizard to rename the
            package</title>

          <screenshot><mediaobject>
            <imageobject>
              <imagedata format="GIF" align="center"
                fileref="images/tutorial/critwiz.gif"/>
            </imageobject>
          </mediaobject></screenshot>
        </figure>

        <para>Watch now how the design critic note in the To Do panel
          disappears, leaving only the
          <literal>Add&nbsp;Elements&nbsp;to&nbsp;Package&nbsp;purchasingmodel
          </literal> note in the To-Do list.</para>

        <para>If this doesn't happen at once, wait for a few seconds. &argouml;
          makes heavy use of several threads of execution that execute in
          parallel. This can cause delays of a few seconds before the
          information gets updated on the screen.</para>

        <para>
The package name change should also be reflected in the
          explorer, in the top left corner of your &argouml;
          window.</para>

        <para>We are now ready to create our first UML diagram, a Use Case
        diagram, but first let's save what we've done so far.</para>

        <para>Click on the <literal>File</literal> menu item, and select
          <literal>Save&nbsp;Project</literal>. You can now safely exit
          &argouml; without losing your work so far, or go on creating your
          first diagram.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>The Case Study (To be written)</title>

    <remark>To be written&hellip;</remark>
  </sect1>
</chapter>

<!-- Local stuff for Emacs - please do not delete

Local Variables:
mode: xml
sgml-doctype: "argomanual.xml"
sgml-parent-document: ("argomanual.xml" "chapter" nil)
sgml-validate-command: "nsgmls -wxml -sv ../docbook-setup/xml.dcl \
  argomanual.xml"
End:

-->
