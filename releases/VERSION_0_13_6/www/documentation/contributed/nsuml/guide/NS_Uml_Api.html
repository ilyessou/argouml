<H3 align=center>Copyright &#169; 1999 by Novosoft Inc.
  All rights reserved</H3>

<p>

<title> NovoSoft UML API Programmer's Guide</title>
 
<H1 align=center>NovoSoft UML API Programmer's Guide </H1>
 
<H1>Contents </H1><A href="#tth_sEc1"
>1&nbsp; Introduction</A><br>
<A href="#tth_sEc2"
>2&nbsp; UML metamodel</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc2.1"
>2.1&nbsp; UML 1.3 metamodel</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc2.2"
>2.2&nbsp; UML 1.3 physical metamodel</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc2.3"
>2.3&nbsp; NOVOSOFT UML metamodel</A><br>
<A href="#tth_sEc3"
>3&nbsp; Object model</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc3.1"
>3.1&nbsp; Primitives</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc3.2"
>3.2&nbsp; Enumerations</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc3.3"
>3.3&nbsp; Datatypes</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc3.4"
>3.4&nbsp; Elements</A><br>
<A href="#tth_sEc4"
>4&nbsp; Access to attributes and associations</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.1"
>4.1&nbsp; Access to attributes</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.2"
>4.2&nbsp; Access to association</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.2.1"
>4.2.1&nbsp; Example</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.2.2"
>4.2.2&nbsp; Reference role</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.2.3"
>4.2.3&nbsp; List role</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.2.4"
>4.2.4&nbsp; Bag role</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.2.5"
>4.2.5&nbsp; Role classification principles</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.3"
>4.3&nbsp; Reflective API</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.4"
>4.4&nbsp; Removing elements </A><br>
<A href="#tth_sEc5"
>5&nbsp; Event notification support</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc5.1"
>5.1&nbsp; Types of events</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc5.2"
>5.2&nbsp; Listener interface</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc5.3"
>5.3&nbsp; Factory class</A><br>
&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc5.4"
>5.4&nbsp; Event interpretation</A><br>
<A href="#tth_sEc6"
>6&nbsp; Undo/redo support</A><br>
 
<p>
<P><BR CLEAR="ALL"><HR>

        <H2><A NAME="tth_sEc1">
1</A>&nbsp;&nbsp;Introduction</H2>

<p>
The <font color="#FF0000"><i><b>Unified Modeling Language</b></i></font> (UML) is a language for specifying,
visualizing, constructing, and documenting the artifacts of software
systems, as well as for business modeling and other non-software systems.
The <font color="#FF0000"><i><b>UML </b></i></font>represents a collection of the best engineering practices that
have proven successful in the modeling of large and complex systems. The
main creator and developer of <font color="#FF0000"><i><b>UML </b></i></font>is <a href="http://www.omg.org">OMG</a>.

<p>
<font color="#0000FF"><i>Novosoft UML API </i></font>is a modern, high-quality Java-based software, supporting user's
<font color="#FF0000"><i><b>UML </b></i></font>models. It organizes compact storage of model, provides fast and
convenient access to its features (attributes and opposite roles in
associations). It allows all conceivable kind of work with models, such as
generating and serialization of <font color="#FF0000"><i><b>UML </b></i></font>models, organizing of access to model
elements, modifying, adding and deleting of features. <font color="#0000FF"><i>Novosoft UML API </i></font>supports
integrity and reliability of the model.

<p>
<font color="#0000FF"><i>Novosoft UML API </i></font>satisfies all of specifications of <font color="#FF0000"><i><b>OMG/UML</b></i></font>, it implements all
elements of <font color="#FF0000"><i><b>UML </b></i></font>: packages, datatypes, classes, their methods and
associations. Besides, <font color="#0000FF"><i>Novosoft UML API </i></font>contains many other useful methods not
specified by OMG.

<p>
<font color="#0000FF"><i>Novosoft UML API </i></font>contains <font color="#0000FF"><i>Reflective API</i></font>. Together with standard access
methods, it gives to the developer alternative orthogonal possibilities
for accessing to features of <font color="#FF0000"><i><b>UML </b></i></font>model elements. Sometimes this
significantly simplifies work with <font color="#FF0000"><i><b>UML </b></i></font>model.

<p>
<font color="#0000FF"><i>Novosoft UML API </i></font>has its own Event Notification Support. <font color="#0000FF"><i>Novosoft UML API </i></font>realizes supporting of
undo/redo policy. This is made to simplify the work of a programmer, who needs
such possibilities.

<p>
<font color="#0000FF"><i>Novosoft UML API </i></font>supports XMI standard. It can read and write model according to XMI
format.

<p>
<font color="#0000FF"><i>Novosoft UML API </i></font>is widely used inside NOVOSOFT for constructing code generators, mapped
various UML models to programming languages: Java, C++, SQL, etc. Also it can
be very useful for tool builders, developing facilities of visual work with
models of object-oriented program software.

<p>
<P><BR CLEAR="ALL"><HR>

        <H2><A NAME="tth_sEc2">
2</A>&nbsp;&nbsp;UML metamodel</H2>
<font color="#FF0000"><i><b>UML </b></i></font>is the language for supporting software systems creation, but it does
not look like ordinary programming language. It has its own lexicon, but
it does not contains rules for construction strictly right sentences. Its
semantics can be expressed on English languages or on the language of
diagrams.

<p>
<font color="#0000FF"><i>Novosoft UML API </i></font>is an implementation of <font color="#FF0000"><i><b>UML metamodel</b></i></font>, based of Java
language. It consists of interfaces, classes, attributes and methods,
which supports notions of UML. There exist a simple correspondence between
the names of <font color="#FF0000"><i><b>UML </b></i></font>metaobjects, types and roles and the names of <font color="#0000FF"><i>NSUML </i></font>
Java types, interfaces, classes and methods.

<p>
      <H3><A NAME="tth_sEc2.1">
2.1</A>&nbsp;&nbsp;UML 1.3 metamodel</H3>
<font color="#FF0000"><i><b>UML </b></i></font>presents not only tools for describing software artifacts, but <font color="#FF0000"><i><b>UML </b></i></font>
itself can be expressed with the help of these tools. <font color="#FF0000"><i><b>UML </b></i></font>is expressed by
<font color="#FF0000"><i><b>UML </b></i></font>diagrams of various types and by other facilities (English language,
OCL expressions, etc.) Description of <font color="#FF0000"><i><b>UML </b></i></font>with the help of <font color="#FF0000"><i><b>UML </b></i></font>is called
<font color="#FF0000"><i><b>UML metamodel</b></i></font>.

<p>
The last official version of <font color="#FF0000"><i><b>UML metamodel</b></i></font> is <font color="#FF0000"><i><b>UML 1.3
metamodel</b></i></font>. Its conceptions and semantic constructions are described in
Chapter 2 "UML semantics" of the following document:

<p>

<blockquote>
     <a href="http://jnt/OO/OMG/ooad/uml/1.3/OMG_UML_1_3.pdf">OMG Unified Modeling Language Specification, Version 1.3, June 1999</a><br>
</blockquote>
<p>
      <H3><A NAME="tth_sEc2.2">
2.2</A>&nbsp;&nbsp;UML 1.3 physical metamodel</H3>

<p>
In addition to UML metamodel <font color="#FF0000"><i><b>OMG</b></i></font> proposed <font color="#FF0000"><i><b>UML 1.3 physical
metamodel</b></i></font>, which is more clear for realization and more practical. The
specifications of the physical metamodel are described in Chapter 6 "UML
XMI DTD" of the above mentioned document "OMG Unified Modeling Language
Specification, Version 1.3, June 1999".

<p>
UML 1.3 physical metamodel, simplifies UML 1.3 metamodel. It contains only
bidirectional associations, it does not contain association classes, and
is more closely aligned to XMI.  The most part of the Chapter 6 contains
the text of the document "UML XMI DTD".

<p>
We remind some of the distinctions of <font color="#FF0000"><i><b>UML 1.3 physical metamodel</b></i></font>
from <font color="#FF0000"><i><b>UML 1.3 metamodel</b></i></font>.

<p>
Names:

<UL>
<p>

<li> Changed spaces in package names to '_'.

<li> Added names for association ends that did not have them.
  Convention: the name of the adjoining class with the first letter
              in lower case. If this resulted in a name duplication,
              then a numbered suffix was added.
</UL>
<p>
Additions:

<UL>
<p>

<li> Added enumeration literals as attributes of the enumeration classes for
      enumeration data types.

<li> Added 'sorted' enumeration literal to OrderingKind.

<li> Added inheritance link from Message to ModelElement.
</UL>
<p>
Association Classes:

<UL>
<p>

<li> Made ElementOwnership AssociationClass attributes by moving the visibility and
      isSpecification attributes to the ModelElement class.

<li> Removed the attribute "visiblity" from classes AssociationEnd and Feature.

<li> Made the AssociationClass ElementResidence a class by removing the association
      between   Component and ModelElement and adding associations between
      ElementResidence and Component and between
      ElementResidence and ModelElement.

<li> Made the AssociationClass ElementImport a class by removing the association
      between ModelElement and Package and adding associations between ModelElement
      and ElementImport and between ElementImport and Package.

<li> Made the AssociationClass TemplateParameter a class by removing
      the association between ModelElement and ModelElement for template parameters
      and added associations between ModelElement and TemplateParameter and between
      TemplateParameter and ModelElement.
</UL>
<p>
      <H3><A NAME="tth_sEc2.3">
2.3</A>&nbsp;&nbsp;NOVOSOFT UML metamodel</H3>
<font color="#0000FF"><i>Novosoft UML metamodel</i></font> is a base for creation <font color="#0000FF"><i>Novosoft UML API </i></font>. It is
reproduced in the Rose format file <font color="#0000FF"><i>xmi.mdl</i></font>, which is contained in
delivery package of <font color="#0000FF"><i>Novosoft UML API </i></font>.

<p>
<font color="#0000FF"><i>Novosoft UML metamodel</i></font> has minor differences from  <font color="#FF0000"><i><b>UML 1.3
physical metamodel</b></i></font>. We produced such modification to allow the model to
be mapped unambiguously to Java language. We follow UML physical metamodel
very closely. There are five exceptions that are introduced to fix
problems with metamodel. We:

<p>

<OL type="1">
<li> Renamed partition to partition1 in association
   contents(ModelElement)/partition(Partition)
   because of conflict with
   activityGraph(ModelElement)/partition(Partition).

<p>

<li> Renamed collaboration to collaboration1 in association
   constrainingElement(ModelElement)/collaboration(Collaboration)
   because of conflict with
   representedOperation(Operation)/collaboration(Collaboration).

<p>

<li> Renamed classifierRole to classifierRole1 in association
   availableContents(ModelElement)/classifierRole(ClassifierRole)
   because of conflict with
   base(Classifier)/classifierRole(ClassifierRole).

<p>

<li> Renamed elementImport to elementImport2 in association
   modelElement(ModelElement)/elementImport(ElementImport)
   because of conflict with
   package(Package)/elementImport(ElementImport).

<p>

<li> Changed multiplicity of binding end in association
   binding(Binding)/argument(ModelElement)
   because in phisical MM an item cannot be argument of more
   then one template which is wrong because there may be
   set&lt;int&#62; and map&lt;int,int&#62; and this is not allowed by this
   metamodel.
</OL>
<p>
<P><BR CLEAR="ALL"><HR>

        <H2><A NAME="tth_sEc3">
3</A>&nbsp;&nbsp;Object model</H2>
<font color="#0000FF"><i>Novosoft UML API </i></font>object model contains objects the following four types:
<font color="#0000FF"><i>primitives</i></font>, <font color="#0000FF"><i>enumerations</i></font>, <font color="#0000FF"><i>datatypes</i></font> and <font color="#0000FF"><i>elements</i></font>. They
correspond to <font color="#FF0000"><i><b>UML </b></i></font>types and metaobjects. The classification is based on
<font color="#FF0000"><i><b>UML </b></i></font>stereotypes of the objects and the ways of <font color="#0000FF"><i>NSUML </i></font>mapping of these
objects to Java constructions.

<p>
<font color="#0000FF"><i>Primitives</i></font> have stereotype <font color="#FF0000"><i><b>primitive</b></i></font>. <font color="#0000FF"><i>Enumerations</i></font> have
stereotype <font color="#FF0000"><i><b>enumeration</b></i></font>. <font color="#0000FF"><i>Datatypes</i></font> and <font color="#0000FF"><i>elements</i></font> have no
stereotypes. Distinction between <font color="#0000FF"><i>datatypes</i></font> and <font color="#0000FF"><i>elements</i></font> is
concluded in two things. First, any <font color="#0000FF"><i>datatype</i></font> is mapped only to one
Java class of <font color="#0000FF"><i>NSUML </i></font>, any <font color="#0000FF"><i>element</i></font> is mapped to one Java class and one
Java interface. Secondly, <font color="#0000FF"><i>datatype</i></font> classes are created manually, but
<font color="#0000FF"><i>element</i></font> classes and interfaces are created with the help of a
generator program.

<p>
<font color="#0000FF"><i>Novosoft UML API </i></font>contains also auxiliary classes, which provide additional
possibilities (events, undo/redo). All auxiliary interfaces and classes are
created manually.

<p>
      <H3><A NAME="tth_sEc3.1">
3.1</A>&nbsp;&nbsp;Primitives</H3>
<font color="#0000FF"><i>Primitives</i></font> are the <font color="#FF0000"><i><b>UML </b></i></font>objects, which have stereotype <font color="#FF0000"><i><b>primitive</b></i></font>.
There are no special classes <font color="#0000FF"><i>NSUML </i></font>, which correspond to them. <font color="#0000FF"><i>NSUML </i></font>maps
such objects to ordinary Java types, according to the following table.

<p>

<TaBle border>
<tr><td>&nbsp;<font color="#FF0000"><i><b>UML primitives</b></i></font></td><td>&nbsp;<font color="#0000FF"><i>Java types</i></font></td>
<tr><td>&nbsp;Boolean                 </td><td>&nbsp;boolean</td>
<tr><td>&nbsp;Name                    </td><td>&nbsp;String</td>
<tr><td>&nbsp;Integer                 </td><td>&nbsp;int</td>
<tr><td>&nbsp;UnlimitedInteger        </td><td>&nbsp;int</td>
<tr><td>&nbsp;LocationReference &nbsp;&nbsp;</td><td>&nbsp;String</td>
<tr><td>&nbsp;Geometry                </td><td>&nbsp;String</td></TaBle>


<p>
      <H3><A NAME="tth_sEc3.2">
3.2</A>&nbsp;&nbsp;Enumerations</H3>
<font color="#0000FF"><i>Enumerations</i></font> are the <font color="#FF0000"><i><b>UML </b></i></font>objects, which have stereotype
<font color="#FF0000"><i><b>enumeration</b></i></font>. <font color="#0000FF"><i>NSUML </i></font>realizes enumerations as final Java classes with
private constructors only. Names of enumerations begins with letter
<font color="#0000FF"><i>M</i></font>, prefixed to original <font color="#FF0000"><i><b>UML </b></i></font>name. Below all enumeration classes are
indicated:

<p>

<TaBle border>
<tr><td>&nbsp;<font color="#FF0000"><i><b>UML enumerations&nbsp;&nbsp;</b></i></font></td><td>&nbsp;<font color="#0000FF"><i>NSUML Java classes</i></font></td>
<tr><td>&nbsp;AggregationKind </td><td>&nbsp;MAggregationKind</td>
<tr><td>&nbsp;CallConcurrencyKind </td><td>&nbsp;MCallConcurrencyKind</td>
<tr><td>&nbsp;ChangeableKind </td><td>&nbsp;MChangeableKind</td>
<tr><td>&nbsp;MessageDirectionKind </td><td>&nbsp;MMessageDirectionKind</td>
<tr><td>&nbsp;OperationDirectionKind </td><td>&nbsp;MOperationDirectionKind</td>
<tr><td>&nbsp;OrderingKind </td><td>&nbsp;MOrderingKind</td>
<tr><td>&nbsp;ParameterDirectionKind&nbsp;&nbsp;</td><td>&nbsp;MParameterDirectionKind&nbsp;</td>
<tr><td>&nbsp;PseudostateKind </td><td>&nbsp;MPseudostateKind</td>
<tr><td>&nbsp;ScopeKind </td><td>&nbsp;MScopeKind</td>
<tr><td>&nbsp;VisibilityKind </td><td>&nbsp;MVisibilityKind</td></TaBle>


<p>
During initialization of <font color="#0000FF"><i>enumeration</i></font> classes there are constructed
several predefined final static public instances in according with <font color="#FF0000"><i><b>UML </b></i></font>
specifications. For example, there are 3 available instances of the class
<font color="#0000FF"><i>MVisibilityKind</i></font>: <font color="#0000FF"><i>MVisibilityKind.PRIVATE</i></font>,
<font color="#0000FF"><i>MVisibilityKind.PROTECTED</i></font>, <font color="#0000FF"><i>MVisibilityKind.PUBLIC</i></font>. In addition,
the class contains 3 integer attributes which correspond to the above-mentioned
instances (see the following table).

<p>

<TaBle border>
<tr><td colspan="2" align="center"><font color="#0000FF"><i>MVisibilityKind</i></font> </td>
<tr><td>&nbsp;<font color="#0000FF"><i>Predefined Instances</i></font>  </td><td>&nbsp;<font color="#0000FF"><i>Corresponding class attributes</i></font>&nbsp;</td>
<tr><td>&nbsp;MVisibilityKind.PRIVATE    </td><td>&nbsp;MVisibilityKind._PRIVATE  </td>
<tr><td>&nbsp;MVisibilityKind.PROTECTED&nbsp;</td><td>&nbsp;MVisibilityKind._PROTECTED</td>
<tr><td>&nbsp;MVisibilityKind.PUBLIC     </td><td>&nbsp;MVisibilityKind._PUBLIC   </td></TaBle>


<p>
The instances are created in according with <font color="#FF0000"><i><b>UML </b></i></font>specifications,
the corresponding integer class attributes are created for simpler
organization of Java switches.

<p>
      <H3><A NAME="tth_sEc3.3">
3.3</A>&nbsp;&nbsp;Datatypes</H3>
<font color="#0000FF"><i>Datatypes</i></font> have no stereotypes. Each <font color="#0000FF"><i>datatype</i></font> is mapped exactly
to one <font color="#0000FF"><i>NSUML </i></font>Java class. The creation of <font color="#0000FF"><i>NSUML </i></font>names for <font color="#0000FF"><i>datatypes</i></font>
is the same as for <font color="#0000FF"><i>enumerations</i></font>. Below all <font color="#0000FF"><i>datatype</i></font>
classes are presented.

<p>

<TaBle border>
<tr><td colspan="2" align="center"><font color="#0000FF"><i>NSUML datatype classes</i></font> </td>
<tr><td>&nbsp;MExpression        </td><td>&nbsp;MMultiplicity      </td>
<tr><td>&nbsp;MActionExpression  </td><td>&nbsp;MMultiplicityRange </td>
<tr><td>&nbsp;MArgListsExpression </td>
<tr><td>&nbsp;MBooleanExpression</td>
<tr><td>&nbsp;MIterationExpression</td>
<tr><td>&nbsp;MMappingExpression</td>
<tr><td>&nbsp;MProcedureExpression</td>
<tr><td>&nbsp;MTimeExpression</td>
<tr><td>&nbsp;MTypeExpression</td>
<tr><td></td></TaBle>


<p>
Class <font color="#0000FF"><i>MExpression</i></font> is the superclass for all the group of
<font color="#0000FF"><i>Expression</i></font> classes.

<p>
Class <font color="#0000FF"><i>MMultiplicity</i></font> is intended for description of role multiplicities. There
are four predefined instances of this class. They correspond to the most
widespread types of UML multiplicities:

<p>

<TaBle border>
<tr><td colspan="2" align="center"><font color="#0000FF"><i>MMultiplicity</i></font> </td>
<tr><td>&nbsp;<font color="#0000FF"><i>Predefined Instances</i></font>&nbsp;</td><td>&nbsp;<font color="#FF0000"><i><b>Corresponding UML multiplicities</b></i></font>&nbsp;</td>
<tr><td>&nbsp;MMultiplicity.M0_1         </td><td>&nbsp;0..1</td>
<tr><td>&nbsp;MMultiplicity.M1_1         </td><td>&nbsp;1   </td>
<tr><td>&nbsp;MMultiplicity.M0_N         </td><td>&nbsp;*   </td>
<tr><td>&nbsp;MMultiplicity.M1_N         </td><td>&nbsp;1..n</td></TaBle>


<p>
With the help of this class you can create arbitrary possible UML
multiplicitities, invoking the constructor with the string parameter like this
"1,3..5,7,9,10..n".

<p>
All <font color="#0000FF"><i>enumeration</i></font> and <font color="#0000FF"><i>datatype</i></font> classes are contained in the package
<font color="#0000FF"><i>ru/novosoft/uml/foundation/datatypes</i></font>.

<p>
      <H3><A NAME="tth_sEc3.4">
3.4</A>&nbsp;&nbsp;Elements</H3>
<font color="#0000FF"><i>Elements</i></font> form the biggest object class. <font color="#FF0000"><i><b>UML </b></i></font>elements are structured
in packages (<font color="#FF0000"><i><b>Foundation</b></i></font>, <font color="#FF0000"><i><b>Core</b></i></font>, <font color="#FF0000"><i><b>Behavior</b></i></font>, etc.).
The typical <font color="#0000FF"><i>elements</i></font> of <font color="#FF0000"><i><b>UML </b></i></font>are <font color="#FF0000"><i><b>Package</b></i></font>, <font color="#FF0000"><i><b>Classifier</b></i></font>,
<font color="#FF0000"><i><b>Attribute</b></i></font>, <font color="#FF0000"><i><b>Method</b></i></font>, <font color="#FF0000"><i><b>Operation</b></i></font>, etc.
Each <font color="#0000FF"><i>element</i></font> is mapped exactly to one interface and one class of <font color="#0000FF"><i>Novosoft UML API </i></font>.
There exists a simple names' correspondence between <font color="#FF0000"><i><b>UML </b></i></font>elements and
<font color="#0000FF"><i>NSUML </i></font>Java interfaces and classes. See the following table, illustrating
names' correspondence.

<p>

<TaBle border>
<tr><td colspan="3" align="center"><font color="#0000FF"><i>Names' correspondence</i></font> </td>
<tr><td>&nbsp;<font color="#FF0000"><i><b>UML element</b></i></font>&nbsp;</td><td>&nbsp;<font color="#0000FF"><i>NSUML interface</i></font>&nbsp;</td><td>&nbsp;<font color="#0000FF"><i>NSUML class</i></font>&nbsp;</td>
<tr><td></td>
<tr><td>&nbsp;<font color="#FF0000"><i><b>Package</b></i></font>       </td><td>&nbsp;&nbsp;<font color="#0000FF"><i>MPackage</i></font>      </td><td>&nbsp;<font color="#0000FF"><i>MPackageImpl</i></font>      </td>
<tr><td>&nbsp;<font color="#FF0000"><i><b>Classifier</b></i></font>    </td><td>&nbsp;&nbsp;<font color="#0000FF"><i>Mclassifier</i></font> &nbsp;</td><td>&nbsp;<font color="#0000FF"><i>MClassifierImpl</i></font> &nbsp;</td>
<tr><td>&nbsp;...                 </td><td>&nbsp;&nbsp;...                </td><td>&nbsp;...                    </td></TaBle>


<p>
<font color="#0000FF"><i>Novosoft UML API </i></font>contains one important class which is the superclass for all the
<font color="#0000FF"><i>element</i></font> Java classes. This is the class <font color="#0000FF"><i>MBaseImpl</i></font>, which
implements interface <font color="#0000FF"><i>MBase</i></font>. Many interesting additional possibilities
of <font color="#0000FF"><i>NSUML </i></font><font color="#0000FF"><i>elements</i></font> are realized due to the methods defined in the
base class.  It is supposed you need not in creation of instances of this
class, but you will create instances of its successors. For example,
<font color="#0000FF"><i>NSUML </i></font>Java class <font color="#0000FF"><i>MClassImpl</i></font> implementing <font color="#FF0000"><i><b>UML </b></i></font>metaclass <font color="#FF0000"><i><b>Class</b></i></font>
is a successor of the base class. You can create new instances of the
metaclass <font color="#FF0000"><i><b>Class</b></i></font>, choosing any variant from the following

<p>
<font color="#0000FF">
<pre>
MBase  cls0 = new MClassImpl();
MClass cls1 = new MClassImpl();
</pre>
</font>
<p>
We remark, that the user have to operate with interface references only,
and using the following code

<p>
<font color="#0000FF">
<pre>
MClassImpl cls = new MClassImpl(); // Error! Do not use similar references
</pre>
</font>
<p>
is not allowed and can further lead to mistakes.

<p>
Note also, that interface <font color="#0000FF"><i>MBase</i></font> contains overridden in all successors
method <font color="#0000FF"><i>getUMLClassName()</i></font>, returning real <font color="#FF0000"><i><b>UML </b></i></font>name of the metaclass,
which is implemented in <font color="#0000FF"><i>NSUML </i></font>. See the following fragment:
<font color="#0000FF">

<pre>
public class MStereotypeImpl extends    MGeneralizableElementImpl
                             implements MStereotype
{
  // ------------ code for class Stereotype -----------------
  ...
  public String getUMLClassName()
  {
    return "Stereotype";
  }
  ...
}
</pre>
</font>
<p>
So, if you have a reference to interface <font color="#0000FF"><i>MBase</i></font>, you can easy recognize
which <font color="#FF0000"><i><b>UML </b></i></font>metaobject corresponds to this reference.

<p>
<P><BR CLEAR="ALL"><HR>

        <H2><A NAME="tth_sEc4">
4</A>&nbsp;&nbsp;Access to attributes and associations</H2>
<font color="#0000FF"><i>Element</i></font> objects may contain attributes, whose types are
<font color="#0000FF"><i>primitive</i></font>, <font color="#0000FF"><i>enumeration</i></font> or <font color="#0000FF"><i>datatype</i></font>. Two <font color="#0000FF"><i>element</i></font>
metaclasses can be connected with the help of an association.

<p>
Each attribute and role (in association) is mapped to a set of <font color="#0000FF"><i>NSUML </i></font>
public user methods of <font color="#0000FF"><i>element</i></font> interfaces (and classes). These
methods support access to an attribute or role, possibilities of
modifications of their values. There is a simple correspondence between
the names of attributes or roles in <font color="#FF0000"><i><b>UML </b></i></font>and the names of <font color="#0000FF"><i>NSUML </i></font>methods.
This section contains classification of the user methods for accessing to
attributes and associations, description of rules for naming of the
methods and semantic of these methods.

<p>
Attributes are divided on two types: <font color="#0000FF"><i>boolean</i></font> and <font color="#0000FF"><i>non-boolean</i></font>.  A
set of methods for access to <font color="#0000FF"><i>boolean</i></font> and <font color="#0000FF"><i>non-boolean attributes</i></font>
is the same, but there exists a minor difference in naming the methods.

<p>
Roles in associations are divided on three types: <font color="#0000FF"><i>reference</i></font>, <font color="#0000FF"><i>bag</i></font>
and <font color="#0000FF"><i>list roles</i></font>. <font color="#0000FF"><i>Reference roles</i></font> have multiplicities <font color="#0000FF"><i>1</i></font> or
<font color="#0000FF"><i>0..1</i></font>. Roles with other multiplicities belong to <font color="#0000FF"><i>bag</i></font> (unordered
multiplicities) or <font color="#0000FF"><i>list roles</i></font> (ordered multiplicities).

<p>
Some methods of <font color="#0000FF"><i>NSUML </i></font>element interfaces are public, but designed for
internal use only. You are not allowed to invoke them. The names of all of
them begin with the word <font color="#0000FF"><i>internal</i></font>.

<p>
      <H3><A NAME="tth_sEc4.1">
4.1</A>&nbsp;&nbsp;Access to attributes</H3>
<font color="#0000FF"><i>NSUML </i></font><font color="#0000FF"><i>element</i></font> class stores attributes as private objects. Access to
object attributes is organized with the help of so-called Setter and
Getter methods, declared in corresponding interface and implemented in
class. Semantic of the methods is the following: Getter is the method,
which returns value of the attribute, Setter sets the value of this
attribute. For example, <font color="#FF0000"><i><b>UML </b></i></font>metaclass <font color="#FF0000"><i><b>Abstraction</b></i></font> has the attribute
<font color="#FF0000"><i><b>mapping</b></i></font>, which belongs to the metaclass <font color="#FF0000"><i><b>MappingExpression</b></i></font>.

<p>

    

<center><IMG src="Abstraction.gif" ALT="Metaclass Abstraction">
</center>
<p>
<font color="#0000FF"><i>NSUML </i></font>interface <font color="#0000FF"><i>MAbstraction</i></font> corresponding to the metaclass has the
next form:

<p>
<font color="#0000FF">
<pre>
public interface MAbstraction extends MDependency {
  // generating attributes
  // attribute: mapping
  MMappingExpression getMapping();
  void setMapping(MMappingExpression __arg);
  ...
  // generating associations
  ...
}
</pre>
</font>
<p>
Method <font color="#0000FF"><i>getMapping()</i></font> is the Getter method, method <font color="#0000FF"><i>setMapping(...)</i></font>
is the Setter method. These methods are implemented in class
<font color="#0000FF"><i>MAbstractionImpl</i></font>. The rule for naming of Getter and Setter methods
for <font color="#0000FF"><i>non-boolean attribute</i></font> is generally used: name of the Getter is
created by capitalization of first letter of attribute name with addition
to it the prefix <font color="#0000FF"><i>get</i></font>, name of the Setter is formed in the same manner
with addition to the attribute name the prefix <font color="#0000FF"><i>set</i></font>.

<p>
A distinction arises for <font color="#0000FF"><i>boolean attributes</i></font>. In this case an interface
looks like the following:

<p>
<font color="#0000FF">
<pre>
public interface MAssociationEnd extends MModelElement {
  // generating attributes
  ...
  // attribute: isNavigable
  boolean isNavigable();
  void setNavigable(boolean __arg);
  ...
}
</pre>
</font>
<p>
Here the name of the <font color="#FF0000"><i><b>UML </b></i></font>attribute is <font color="#FF0000"><i><b>isNavigable</b></i></font>. To form the
names for Getter and Setter method <font color="#0000FF"><i>NSUML </i></font>deletes the prefix <font color="#FF0000"><i><b>is</b></i></font> from
the attribute's name. Then it uses the custom rule for forming name of
Setter method, but Getters begins with the prefix <font color="#0000FF"><i>is</i></font>.

<p>
      <H3><A NAME="tth_sEc4.2">
4.2</A>&nbsp;&nbsp;Access to association</H3>
Each association in <font color="#0000FF"><i>Novosoft UML metamodel</i></font> is an unnamed association
between two <font color="#0000FF"><i>elements</i></font>. An association have two roles (or ends), each
role has name and multiplicity. The role attached to an element is the
direct role, other role is called the opposite role.

<p>
<font color="#0000FF"><i>Novosoft UML API </i></font>has not special objects for association. It maps association to
fields and methods of <font color="#0000FF"><i>element</i></font> classes.  Primitively, you can
consider, that class contains and treats information about the opposite
association end of the association to which it belongs.

<p>
       <H4><A NAME="tth_sEc4.2.1">
4.2.1</A>&nbsp;&nbsp;Example<A NAME="Example3">
</A></H4>
See the following class diagram.

<p>

    

<center><IMG src="Image5.gif" ALT="Project Interaction Scheme">
</center>
<p>
Here your can see two <font color="#FF0000"><i><b>UML </b></i></font>metaclasses: <font color="#FF0000"><i><b>Feature</b></i></font>, <font color="#FF0000"><i><b>Classifier</b></i></font>
and an unnamed association between them.

<p>

<OL type="1">
<li> The role with the name <font color="#FF0000"><i><b>owner</b></i></font> is the opposite role for metaclass
<font color="#FF0000"><i><b>Feature</b></i></font> and has the multiplicity <font color="#FF0000"><i><b>0..1</b></i></font>.

<p>

<li> The role with the name <font color="#FF0000"><i><b>feature</b></i></font> is the opposite role for metaclass
<font color="#FF0000"><i><b>Classifier</b></i></font> and has the ordered multiplicity <font color="#FF0000"><i><b>*</b></i></font>.

<p>

<li> The association is read as "<font color="#0000FF"> any <font color="#FF0000"><i><b>Classifier</b></i></font>
contains arbitrary number of <font color="#FF0000"><i><b>Features</b></i></font>, which are ordered. Any
<font color="#FF0000"><i><b>Feature</b></i></font> can be attached to one <font color="#FF0000"><i><b>Classifier</b></i></font> only</font>".
</OL>
<p>
Role <font color="#FF0000"><i><b>owner</b></i></font> is a <font color="#0000FF"><i>reference</i></font> role, role <font color="#FF0000"><i><b>feature</b></i></font>
is a <font color="#0000FF"><i>list</i></font> role, because it is ordered. <font color="#0000FF"><i>NSUML </i></font>maps this
roles to next private fields:

<p>

<TaBle border>
<tr><td>&nbsp;Additional field          </td><td>&nbsp;Java Class        </td>
<tr><td>&nbsp;<font color="#0000FF"><i>MClassifier _owner;</i></font>&nbsp;</td><td>&nbsp;<font color="#0000FF"><i>MFeatureImpl</i></font>     </td>
<tr><td>&nbsp;<font color="#0000FF"><i>List _feature;</i></font>       </td><td>&nbsp;<font color="#0000FF"><i>MClassifierImpl</i></font>&nbsp;</td></TaBle>


<p>
Now, it is provided that <font color="#FF0000"><i><b>Feature</b></i></font> contains the information about it
owner <font color="#FF0000"><i><b>Classifier</b></i></font> in the field <font color="#0000FF"><i>_owner</i></font>, <font color="#FF0000"><i><b>Classifier</b></i></font>
contains the list of <font color="#FF0000"><i><b>Feature</b></i></font> in the field <font color="#0000FF"><i>_feature</i></font>. You have
not direct access to these fields, this is provided through Getter, Setter
and other methods.

<p>
       <H4><A NAME="tth_sEc4.2.2">
4.2.2</A>&nbsp;&nbsp;Reference role</H4>
Remind, that <font color="#0000FF"><i>reference role</i></font> is the role which have multiplicity
<font color="#0000FF"><i>1</i></font> or <font color="#0000FF"><i>0..1</i></font>. On the example of <font color="#0000FF"><i>reference role</i></font> <font color="#FF0000"><i><b>owner</b></i></font>, we
show which new methods a <font color="#0000FF"><i>reference role</i></font> generates and explain their
semantic. See the syntax of the methods for role <font color="#FF0000"><i><b>owner</b></i></font> from Java
interface, corresponding to metaclass <font color="#FF0000"><i><b>Feature</b></i></font>.

<p>
<font color="#0000FF">
<pre>
public interface MFeature extends MModelElement
{
  ...
  // opposite role: owner this role: feature
  MClassifier getOwner();
  void setOwner(MClassifier __arg);
  ...
}
</pre>
</font>
<p>
Analyzing interface you can see that the <font color="#0000FF"><i>reference role</i></font> generates the
same Getter and Setter methods, as we saw any attribute generated. The
difference is in semantic of Setter method in <font color="#0000FF"><i>MFeatureImpl</i></font>. In the
case of attribute access a Setter simply refreshes private field with a
new value of the attribute. Now Setter have to support correctness of the
model, that is bilateral <font color="#FF0000"><i><b>UML </b></i></font>semantic of the association. So, it

<UL>
<p>

<li> memorizes old value of the field <font color="#0000FF"><i>_owner</i></font> in temporary variable
      <font color="#0000FF"><i>old</i></font>;

<li> updates field <font color="#0000FF"><i>_owner</i></font> to <font color="#0000FF"><i>__arg</i></font>;

<li> adds the <font color="#00FF00"><i>this</i></font> object to the List <font color="#0000FF"><i>__arg._feature</i></font>;

<li> deletes <font color="#00FF00"><i>this</i></font> object from the List <font color="#0000FF"><i>old._feature</i></font>;

<li> makes another specific actions, when <font color="#0000FF"><i>__arg</i></font> or <font color="#0000FF"><i>old</i></font> are
      null references.
</UL>
<p>
       <H4><A NAME="tth_sEc4.2.3">
4.2.3</A>&nbsp;&nbsp;List role</H4>
<font color="#0000FF"><i>List role</i></font> is the role which have ordered multiplicity different
from <font color="#0000FF"><i>1</i></font> or <font color="#0000FF"><i>0..1</i></font>.

<p>
Now we consider again our example, the <font color="#0000FF"><i>list role</i></font>  <font color="#FF0000"><i><b>feature</b></i></font>. This
role is opposite to metaclass <font color="#FF0000"><i><b>Classifier</b></i></font>. See the code from Java
interface, which supports operation with this role.
<font color="#0000FF">

<pre>
public interface MClassifier extends MNamespace, MGeneralizableElement
{
...
  // opposite role: feature this role: owner
  List getFeatures();
  void setFeatures(List __arg);
  void addFeature(MFeature __arg);
  void removeFeature(MFeature __arg);
  void addFeature(int __pos, MFeature __arg);
  void removeFeature(int __pos);
  void setFeature(int __pos, MFeature __arg);
  MFeature getFeature(int __pos);
  ...
}
</pre>
</font>
<p>
Again you can see the well-known Setter and Getter and additional six
methods too. Setter and Getter have semantics different from previous
cases.

<p>

<UL>
<li> Getter <font color="#0000FF"><i>getFeatures()</i></font> does not return reference
      <font color="#0000FF"><i>_feature</i></font>. Instead, it returns a copy of the List,
      which is unmodifiable.

<li> Setter <font color="#0000FF"><i>setFeatures(List __arg)</i></font> memorize
      copy of our List, after the Setter termination your <font color="#0000FF"><i>__arg</i></font>
      is available for modifications.
      Setter analyzes how does your <font color="#0000FF"><i>List __arg</i></font> differ from
      <font color="#0000FF"><i>List _feature</i></font>, refreshes <font color="#0000FF"><i>List _feature</i></font> with new elements,
      deletes from <font color="#0000FF"><i>List _feature</i></font> elements not presented
      in <font color="#0000FF"><i>List __arg</i></font>.
</UL>
<p>
Semantics of rest six methods are clear from their syntax. They present
few functions, that are allowed for the Java interface List.

<UL>
<p>

<li> Adder <font color="#0000FF"><i>addFeature(MFeature __arg)</i></font> adds new feature
      <font color="#0000FF"><i>__arg</i></font> to the end of <font color="#0000FF"><i>List _feature</i></font>.

<li> Remover <font color="#0000FF"><i>removeFeature(MFeature __arg)</i></font> seeks feature
      <font color="#0000FF"><i>__arg</i></font> in the <font color="#0000FF"><i>List _feature</i></font> and deletes it
      from the List.

<li> Adder <font color="#0000FF"><i>addFeature(int __pos, MFeature __arg)</i></font> adds new feature
      <font color="#0000FF"><i>__arg</i></font> in the specified position <font color="#0000FF"><i>__pos</i></font>
      of the <font color="#0000FF"><i>List _feature</i></font>.

<li> Remover <font color="#0000FF"><i>removeFeature(int __pos)</i></font> remove the feature being
      located in the specified position <font color="#0000FF"><i>__pos</i></font>
      of the <font color="#0000FF"><i>List _feature</i></font>.

<li> Setter <font color="#0000FF"><i>setFeature(int __pos, MFeature __arg)</i></font> change
      old feature in the specified position <font color="#0000FF"><i>__pos</i></font>
      of the <font color="#0000FF"><i>List _feature</i></font> with new value <font color="#0000FF"><i>__arg</i></font>.

<li> Getter <font color="#0000FF"><i>getFeature(int __pos)</i></font> returns
      the feature in the specified position <font color="#0000FF"><i>__pos</i></font>
      of the <font color="#0000FF"><i>List _feature</i></font>.

<p>
</UL>All methods support semantic of association: the <font color="#FF0000"><i><b>Feature</b></i></font> deleted
from <font color="#0000FF"><i>List _feature</i></font> changes its owner to <font color="#00FF00"><i>null</i></font>, the
<font color="#FF0000"><i><b>Feature</b></i></font> added to <font color="#0000FF"><i>List _feature</i></font> changes its owner to
reference to the current object of the class <font color="#0000FF"><i>MClassifierImpl</i></font>.

<p>
       <H4><A NAME="tth_sEc4.2.4">
4.2.4</A>&nbsp;&nbsp;Bag role</H4>
<font color="#0000FF"><i>Bag role</i></font> is the role which have unordered multiplicity different
from <font color="#0000FF"><i>1</i></font> or <font color="#0000FF"><i>0..1</i></font>.

<p>
Now we consider again our example <A href="#Example3">4.2.1</A>, but suppose that the
role  <font color="#FF0000"><i><b>feature</b></i></font> is not ordered, and change the name of metaclass
<font color="#FF0000"><i><b>Classifier</b></i></font> to abstract name <font color="#FF0000"><i><b>Something</b></i></font>. Then <font color="#0000FF"><i>NSUML </i></font>classes
have to contain the following additional fields.

<p>

<TaBle border>
<tr><td>&nbsp;Additional field          </td><td>&nbsp;NSUML Java Classes&nbsp;</td>
<tr><td>&nbsp;<font color="#0000FF"><i>Something _owner;</i></font>&nbsp;</td><td>&nbsp;<font color="#0000FF"><i>MFeatureImpl</i></font>     </td>
<tr><td>&nbsp;<font color="#0000FF"><i>Collection _feature;</i></font>&nbsp;</td><td>&nbsp;<font color="#0000FF"><i>MSomethingImpl</i></font>&nbsp;</td></TaBle>


<p>
See how could be looked Java interface, supporting operations with the
<font color="#0000FF"><i>bag role</i></font> <font color="#FF0000"><i><b>feature</b></i></font>.

<p>
<font color="#0000FF">
<pre>
public interface MSomething ...
{
...
  Collection getFeatures();
  void setFeatures(Collection __arg);
  void addFeature(MFeature __arg);
  void removeFeature(MFeature __arg);
  ...
}
</pre>
</font>
<p>
We can see only four methods instead of eight ones, which we saw for
<font color="#0000FF"><i>list role</i></font>. Their semantic is similar to previous, but interface
List is changed to interface Collection.

<p>

<UL>
<li> Getter <font color="#0000FF"><i>getFeatures()</i></font> returns a copy of
      the <font color="#0000FF"><i>Collection _feature</i></font>, which is unmodifiable.

<li> Setter <font color="#0000FF"><i>setFeatures(Collection __arg)</i></font> memorize
      copy of our Collection, after the Setter termination your <font color="#0000FF"><i>__arg</i></font>
      is available for modifications.
      Setter analyzes how does your <font color="#0000FF"><i>Collection __arg</i></font> differ from
      <font color="#0000FF"><i>Collection _feature</i></font>, refreshes <font color="#0000FF"><i>Collection _feature</i></font> with new elements,
      deletes from <font color="#0000FF"><i>Collection _feature</i></font> elements not presented
      in <font color="#0000FF"><i>Collection __arg</i></font>.

<li> Adder <font color="#0000FF"><i>addFeature(MFeature __arg)</i></font> adds new feature
      <font color="#0000FF"><i>__arg</i></font> to the end of <font color="#0000FF"><i>Collection _feature</i></font>.

<li> Remover <font color="#0000FF"><i>removeFeature(MFeature __arg)</i></font> seeks feature
      <font color="#0000FF"><i>__arg</i></font> in the <font color="#0000FF"><i>Collection _feature</i></font> and deletes it
      from the Collection.
</UL>
<p>
       <H4><A NAME="tth_sEc4.2.5">
4.2.5</A>&nbsp;&nbsp;Role classification principles</H4>
Here we specify, which role multiplicities exist in <font color="#0000FF"><i>NOVOSOFT
UML metamodel</i></font>, and how <font color="#0000FF"><i>NSUML </i></font>divides them on three types:
<font color="#0000FF"><i>reference</i></font>, <font color="#0000FF"><i>bag</i></font>, <font color="#0000FF"><i>list roles</i></font>. See the following table:

<p>

<TaBle border>
<tr><td colspan="3" align="center"><font color="#0000FF"><i>Role classification</i></font> </td>
<tr><td>&nbsp;<font color="#0000FF"><i>NS role names</i></font>&nbsp;</td><td>&nbsp;<font color="#FF0000"><i><b>Base multiplicity</b></i></font>&nbsp;</td><td>&nbsp;<font color="#FF0000"><i><b>Supported Multiplicities</b></i></font>&nbsp;</td>
<tr><td></td>
<tr><td>&nbsp;<font color="#0000FF"><i>Reference</i></font>&nbsp;</td><td>&nbsp;&nbsp;<font color="#FF0000"><i><b>(0..1)</b></i></font>         </td><td>&nbsp;<font color="#FF0000"><i><b>(0..1), (1)</b></i></font>      </td>
<tr><td>&nbsp;<font color="#0000FF"><i>Bag</i></font>        </td><td>&nbsp;&nbsp;<font color="#FF0000"><i><b>(0..*)</b></i></font>         </td><td>&nbsp;<font color="#FF0000"><i><b>(2..*), (1..*), (0..*), (*)</b></i></font> &nbsp;</td>
<tr><td>&nbsp;<font color="#0000FF"><i>List</i></font>       </td><td>&nbsp;&nbsp;<font color="#FF0000"><i><b>(0..*)ordered</b></i></font>&nbsp;</td><td>&nbsp;<font color="#FF0000"><i><b>all previous ordered</b></i></font>      </td></TaBle>


<p>
The third column indicate the types of multiplicities existing in
<font color="#0000FF"><i>NOVOSOFT UML metamodel</i></font>. It easy to understand that <font color="#0000FF"><i>reference</i></font>,
<font color="#0000FF"><i>bag</i></font>, and <font color="#0000FF"><i>list roles</i></font> is a sufficient set for supporting all kinds
of role multiplicities. If your association role have complicated
multiplicity, for example, <font color="#0000FF"><i>(1,4..6,8..*)</i></font>, you can refer it to <font color="#0000FF"><i>bag
roles</i></font>, because it is unordered and contain more than one element. On the
finish step, after modifying your model, you can simply verify if the
collection's (bag's) size keeps within limits <font color="#0000FF"><i>(1,4..6,8..*)</i></font>.

<p>
In conclusion remember main methods for accessing associations.

<p>
If a metaclass has opposite <font color="#0000FF"><i>reference role</i></font>, then corresponding <font color="#0000FF"><i>NSUML </i></font>
interface(class) has only two users methods (Getter and Setter), whose
names begin from <font color="#0000FF"><i>get</i></font> and <font color="#0000FF"><i>set</i></font>.

<p>
If a metaclass has opposite <font color="#0000FF"><i>bag role</i></font>, then corresponding <font color="#0000FF"><i>NSUML </i></font>
interface(class) has four users methods, Getter, Setter, Adder and Remover
methods, whose names begin from <font color="#0000FF"><i>get</i></font>, <font color="#0000FF"><i>set</i></font>, <font color="#0000FF"><i>add</i></font>, <font color="#0000FF"><i>remove</i></font>.

<p>
If a metaclass has opposite <font color="#0000FF"><i>list role</i></font>, then corresponding <font color="#0000FF"><i>NSUML </i></font>
interface(class) has eight users methods, two Getter, two Setter, two
Adder and two Remover methods, whose names begin from <font color="#0000FF"><i>get</i></font>, <font color="#0000FF"><i>set</i></font>,
<font color="#0000FF"><i>add</i></font>, <font color="#0000FF"><i>remove</i></font>.

<p>
      <H3><A NAME="tth_sEc4.3">
4.3</A>&nbsp;&nbsp;Reflective API</H3>
This Section explains syntax and semantic of <font color="#0000FF"><i>Reflective API</i></font> methods,
builded in <font color="#0000FF"><i>Novosoft UML API </i></font>. These facilities give orthogonal possibilities of
invoking the access methods to <font color="#0000FF"><i>features</i></font> (attributes and roles) by
attribute's or role's names. Reflective API works slower then the earlier
described API, but it significantly reduces the space of method's names,
it contains only eight methods, which syntax is the same for all
<font color="#0000FF"><i>elements</i></font>. To illustrate this, one can consider any <font color="#0000FF"><i>element</i></font>
interface. For example, see an extract from the interface <font color="#0000FF"><i>MBase</i></font>.

<p>
<font color="#0000FF">
<pre>
public interface MBase {
  ...
  // Reflective API

  public Object reflectiveGetValue(String feature);
  public void reflectiveSetValue(String feature, Object obj);
  public void reflectiveAddValue(String feature, Object obj);
  public void reflectiveRemoveValue(String feature, Object obj);
  public Object reflectiveGetValue(String feature, int pos);
  public void reflectiveSetValue(String feature, int pos, Object obj);
  public void reflectiveAddValue(String feature, int pos, Object obj);
  public void reflectiveRemoveValue(String feature, int pos);
  ...
}
</pre>
</font>
<p>
Reflective methods begins with the prefix <font color="#0000FF"><i>reflective</i></font>. These methods
are overridden in all successors of <font color="#0000FF"><i>NSUML </i></font>class <font color="#0000FF"><i>MBaseImpl</i></font>. Argument
<font color="#0000FF"><i>feature</i></font> is an <font color="#FF0000"><i><b>UML </b></i></font>name of attribute, opposite reference, bag or list
role. The main sense of reflective methods is the access to features by
their names, instead of invocation of explicit Setter, Getter, Adder or
Remover methods.

<p>
As you can easy to see it, there exists a strict correspondence of
reflective methods to the Setter, Getter, Adder or Remover methods,
described earlier. First two methods provide access to <font color="#0000FF"><i>attribute</i></font> or
opposite <font color="#0000FF"><i>reference role</i></font>. Next two methods are possible for
<font color="#0000FF"><i>feature</i></font>, which is the name of an opposite <font color="#0000FF"><i>bag role</i></font>. Last four
methods is intended for access to <font color="#0000FF"><i>list roles</i></font>.

<p>
To clear the semantic of the methods, consider, for example, the
implementation of the method <font color="#0000FF"><i>reflectiveGetValue</i></font> in the class
<font color="#0000FF"><i>MElementResidenceImpl</i></font>:

<p>
<font color="#0000FF">
<pre>
public class MElementResidenceImpl extends MBaseImpl
                                   implements MElementResidence
{
  ...
  // Reflective API

  public Object reflectiveGetValue(String feature)
  {
    if ("visibility".equals(feature))
    {
      return getVisibility();
    }
    if ("resident".equals(feature))
    {
      return getResident();
    }
    if ("implementationLocation".equals(feature))
    {
      return getImplementationLocation();
    }

    return super.reflectiveGetValue(feature);
  }
  ...
}
</pre>
</font>
<p>
You can see that the class <font color="#0000FF"><i>MElementResidenceImpl</i></font> owns 3 features, not
inherited from superclass. This 3 features: <font color="#FF0000"><i><b>visibility</b></i></font>,
<font color="#FF0000"><i><b>resident</b></i></font>, <font color="#FF0000"><i><b>implementationLocation</b></i></font>. The object <font color="#FF0000"><i><b>visibility</b></i></font>
is an attribute of the metaclass <font color="#FF0000"><i><b>ElementResidence</b></i></font>, and
<font color="#FF0000"><i><b>resident</b></i></font>, <font color="#FF0000"><i><b>implementationLocation</b></i></font> are opposite roles of this
metaclass. The method <font color="#0000FF"><i>reflectiveGetValue()</i></font> verifies, that input field
<i>feature</i> coincides with one of the existing features and invokes
corresponding Getter method. If this feature does not belong to features'
set of this class, then the method invokes the method with the same name
from the superclass. If feature does not belong any of <font color="#0000FF"><i>element</i></font>
superclasses, then the base class <font color="#0000FF"><i>MBaseImpl</i></font> throws
<font color="#00FF00"><i>IllegalArgumentException</i></font>.

<p>
This example has explained only the semantic of the first reflective
method. Semantics of other methods can be easily guessed by a user with
the help of <font color="#0000FF"><i>NSUML </i></font>Java codes for <font color="#0000FF"><i>element classes</i></font>.

<p>
      <H3><A NAME="tth_sEc4.4">
4.4</A>&nbsp;&nbsp;Removing elements <A NAME="remove">
</A></H3>
One important method for any <font color="#0000FF"><i>element</i></font> object is its removing from
user's model. Each <font color="#0000FF"><i>element class</i></font> contains the public method
<font color="#0000FF"><i>remove()</i></font>, producing this action.

<p>
Remark, that <font color="#0000FF"><i>element</i></font> can participate in different associations. So during
the removing of <font color="#0000FF"><i>element</i></font> <font color="#0000FF"><i>NSUML </i></font>can invoke many methods of this class
and many methods of opposite classes in associations to support
correctness of the user's model.

<p>
<P><BR CLEAR="ALL"><HR>

        <H2><A NAME="tth_sEc5">
5</A>&nbsp;&nbsp;Event notification support</H2>
This section describes NSUML classes and interfaces, which
support event policy.

<p>
      <H3><A NAME="tth_sEc5.1">
5.1</A>&nbsp;&nbsp;Types of events</H3>
The events, which can be generated by <font color="#0000FF"><i>Novosoft UML API </i></font>, belong to the class
<font color="#0000FF"><i>MElementEvent</i></font>. <font color="#0000FF"><i>NSUML </i></font>classes, inherited <font color="#0000FF"><i>MBaseImpl</i></font> can generate
such event, when Setter, Adder or Remover methods for attributes or roles
are invoked (including corresponding methods from Reflective API).
Besides, event is generated by class <font color="#0000FF"><i>remove</i></font> method <A href="#remove">4.4</A>,
and by internal methods which restore removed element. Below we give the
list of all types of possible events.

<p>
<font color="#0000FF">
<pre>
public class MElementEvent extends java.util.EventObject
{
  ...
  public final static int ELEMENT_REMOVED = 0;
  public final static int ELEMENT_RECOVERED = 1;
  public final static int ATTRIBUTE_SET = 2;
  public final static int REFERENCE_SET = 3;
  public final static int BAG_ROLE_SET = 4;
  public final static int BAG_ROLE_ADDED = 5;
  public final static int BAG_ROLE_REMOVED = 6;
  public final static int LIST_ROLE_SET = 7;
  public final static int LIST_ROLE_ADDED = 8;
  public final static int LIST_ROLE_ITEM_SET = 9;
  public final static int LIST_ROLE_REMOVED = 10;
  ...
}
</pre>
</font>
<p>
Static fields describes types of situations generating events. Their
meanings are clear from their names. First event reports, that user
invoked method <font color="#0000FF"><i>remove</i></font> for some element. Second event reports, that
API recovered previously removed element in the model.

<p>
      <H3><A NAME="tth_sEc5.2">
5.2</A>&nbsp;&nbsp;Listener interface</H3>

<p>
If a user of <font color="#0000FF"><i>NSUML </i></font>want to listen events, going from model elements,
he/she have to

<UL>
<p>

<li> Create a listener class(es) implementing interface <font color="#0000FF"><i>MElementListener</i></font>;

<li> Create a listener object(s) - new instance(s) of the listener class(es);

<li> Register the listener object(s) in model element(s);
</UL>
<p>
Below we give description of the listener interface.

<p>
<font color="#0000FF">
<pre>
public interface MElementListener
{
  void propertySet(MElementEvent e);
  void roleAdded(MElementEvent e);
  void roleRemoved(MElementEvent e);
  void listRoleItemSet(MElementEvent e);
  void removed(MElementEvent e);
  void recovered(MElementEvent e);
}
</pre>
</font>
<p>
Next example illustrate, how to create class EventTest implementing
interface MElementListener (we omit implementation details). Method main()
creates new listener instance <font color="#0000FF"><i>listener</i></font> and new model element
<font color="#FF0000"><i><b>Class</b></i></font>, which registers the <font color="#0000FF"><i>listener</i></font>.

<p>
<font color="#0000FF">
<pre>
public class EventTest implements MElementListener
{
  public static void main (String args[])
  {
      EventTest listener = new EventTest();
      MClass cls = new MClassImpl();
      cls.addMElementListener(listener);
  }
  ...
}
</pre>
</font>
<p>
      <H3><A NAME="tth_sEc5.3">
5.3</A>&nbsp;&nbsp;Factory class</H3>
Public class <font color="#0000FF"><i>MFactory</i></font> manages by the line of events. All model
element initially fire events to this class. You need not create instances
of this class, only have to use its static methods. It support 3 kind of
event policy, see below.

<p>
<font color="#0000FF">
<pre>
  static int event_policy = EVENT_POLICY_DISABLED;

  public static final int EVENT_POLICY_DISABLED  = 0;
  public static final int EVENT_POLICY_IMMEDIATE = 1;
  public static final int EVENT_POLICY_FLUSH     = 2;
</pre>
</font>
<p>
Default state of <font color="#0000FF"><i>event_policy</i></font> is disable, so listeners will not get
events by default. To set the event policy you have to invoke its method
<font color="#0000FF"><i>setEventPolicy(...)</i></font>, for example

<p>
<font color="#0000FF">
<pre>
   MFactory.setEventPolicy(MFactory.EVENT_POLICY_IMMEDIATE);
</pre>
</font>
<p>
Explain the sense of these polices.

<UL>
<p>

<li>    Policy <font color="#0000FF"><i>MFactory.EVENT_POLICY_DISABLED</i></font>.
         Event transfer to the listeners is stopped.

<li>    Policy <font color="#0000FF"><i>MFactory.EVENT_POLICY_FLUSH</i></font> invokes
         transfer all stored events.

<li>    Policy <font color="#0000FF"><i>MFactory.EVENT_POLICY_IMMEDIATE</i></font>.
         In this case all events will transfer to listener immediately.
</UL>
<p>
      <H3><A NAME="tth_sEc5.4">
5.4</A>&nbsp;&nbsp;Event interpretation</H3>
Previously you can see that the class <font color="#0000FF"><i>MElementEvent</i></font> support 11 types of
events, and the interface MElementListener contains 5 methods. The following
code shows the correspondence between the events and the methods, which are
invoked by this events.
<font color="#0000FF">

<pre>
  MElementEvent evt ;
  MElementListener l;
  ...
  switch (evt.getType())
  {
  case MElementEvent.ELEMENT_REMOVED:
    l.removed(evt);
    break;
  case MElementEvent.ELEMENT_RECOVERED:
    l.recovered(evt);
    break;
  case MElementEvent.ATTRIBUTE_SET:
  case MElementEvent.REFERENCE_SET:
  case MElementEvent.BAG_ROLE_SET:
  case MElementEvent.LIST_ROLE_SET:
    l.propertySet(evt);
    break;
  case MElementEvent.BAG_ROLE_ADDED:
  case MElementEvent.LIST_ROLE_ADDED:
    l.roleAdded(evt);
    break;
  case MElementEvent.BAG_ROLE_REMOVED:
  case MElementEvent.LIST_ROLE_REMOVED:
    l.roleRemoved(evt);
    break;
  case MElementEvent.LIST_ROLE_ITEM_SET:
    l.listRoleItemSet(evt);
    break;
  default:
    System.err.println("bad event: "+evt.getType());
  }
  ...
</pre>
</font>
<p>
<P><BR CLEAR="ALL"><HR>

        <H2><A NAME="tth_sEc6">
6</A>&nbsp;&nbsp;Undo/redo support</H2>
User interface of <font color="#0000FF"><i>NSUML </i></font>, allowing realization of undo/redo operations,
consists of two classes: <font color="#0000FF"><i>MCheckPointUndoManager</i></font> and <font color="#0000FF"><i>MCheckPoint</i></font>.
Concept of redo/undo policy is based on the notion of CheckPoint.
CheckPoint is a state of the model fixed by <font color="#0000FF"><i>NSUML </i></font>in the moment of method
<font color="#0000FF"><i>getCheckPoint()</i></font> invocation. User have to remember these states as
instances of the class <font color="#0000FF"><i>MCheckPoint</i></font>. If the user produced some
modification of the model, then it can return to the state of the model in
CheckPoint with the help of <font color="#0000FF"><i>undo</i></font> or <font color="#0000FF"><i>redo</i></font> methods.

<p>
Class <font color="#0000FF"><i>MCheckPointUndoManager</i></font> has the next form:
<font color="#0000FF">

<pre>
public class MCheckPointUndoManager
{
  ...
  static int undo_policy = UNDO_POLICY_DISABLED;
  public static final int UNDO_POLICY_DISABLED = 0;
  public static final int UNDO_POLICY_ENABLED = 1;

  public static void setUndoPolicy(int policy)
  ...
  public static MCheckPoint getCheckPoint()
  ...
  public static void undo(MCheckPoint c)
  ...
  public static void redo(MCheckPoint c)
  ...
}
</pre>
</font>
<p>
Explain the sense of methods.

<UL>
<p>

<li> Method getCheckPoint() returns new CheckPoint
      and remember current model state in invocation time.

<li> Methods undo(), redo() restore model to the state in given CheckPoint.

<li> Method <font color="#0000FF"><i>setUndoPolicy(UNDO_POLICY_DISABLED)</i></font> clear undo/redo stack.
      Restoring of the model is impossible, till the invocation
      the method <font color="#0000FF"><i>setUndoPolicy(UNDO_POLICY_ENBLED)</i></font> and creating new
      CheckPoints.
</UL>
<p>
Below see a simple example of the program, illustrating work with
undo/redo methods.

<p>
<font color="#0000FF">
<pre>
  MCheckPointUndoManager.setUndoPolicy(MCheckPointUndoManager.UNDO_POLICY_ENABLED);
  MCheckPoint c1 = MCheckPointUndoManager.getCheckPoint();
  MClass cls = new MClassImpl();
  cls.addMElementListener(l);
  cls.setName("Test");
  cls.setName("Test2");
  MAttribute attr = new MAttributeImpl();
  attr.setType(cls);
  attr.setName("test");
  cls.addFeature(attr);
  cls.remove();
  MCheckPoint c4 = MCheckPointUndoManager.getCheckPoint();
  System.out.println("Doing full undo ...");
  MCheckPointUndoManager.undo(c1);
  System.out.println("Doing full redo ...");
  MCheckPointUndoManager.redo(c4);
</pre>
</font>
<p>
Following diagram illustrates possible variant of time evolution of some
program.

<p>
 
    

<center><IMG src="Image4.gif" ALT="Project Interaction Scheme">
</center>
<p>
The program

<p>

<UL>
<li> started execution In the the point <font color="#0000FF"><i>start</i></font>;

<li> modified model till the point <font color="#0000FF"><i>c0</i></font>;

<li> enabled undo/redo policy in the point <font color="#0000FF"><i>c0</i></font> and
      generated CheckPoint <font color="#0000FF"><i>c0</i></font>;

<li> modified model till the point <font color="#0000FF"><i>c1</i></font>,
      generated CheckPoint <font color="#0000FF"><i>c1</i></font>;

<li> modified model till the point <font color="#0000FF"><i>c2</i></font>,
      generated CheckPoint <font color="#0000FF"><i>c2</i></font>;

<li> evaluated current model, and returned it to the state
      in CheckPoint <font color="#0000FF"><i>c0</i></font> with the help of <font color="#0000FF"><i>undo(c0)</i></font> method;

<li> evaluated current model, and returned it to the state
      in CheckPoint <font color="#0000FF"><i>c1</i></font> with the help of <font color="#0000FF"><i>redo(c1)</i></font> method.

<li> here it decided to reduce overhead charges for realizing
      undo/redo policy and disabled undo/redo policy.
      (In fact beginning from this point after any model modification,
      stack supporting undo/redo will delete information
      about model modification between CheckPoints <font color="#0000FF"><i>c1</i></font> and <font color="#0000FF"><i>c2</i></font>,
      and returning to the state in point <font color="#0000FF"><i>c2</i></font> becomes impossible.)

<li> modified model till the point <font color="#0000FF"><i>c3</i></font>.
      Enabled undo/redo policy in the point <font color="#0000FF"><i>c3</i></font>,
      generated CheckPoint <font color="#0000FF"><i>c3</i></font>;

<li> modified model till the point <font color="#0000FF"><i>c4</i></font>;

<li> returned model to the state in CheckPoint <font color="#0000FF"><i>c3</i></font>
      with the help of <font color="#0000FF"><i>undo(c3)</i></font> method;

<li> modified model till the point <font color="#0000FF"><i>finish</i></font> and
      finished program execution.
</UL>
<p>
<font size="-2">Copyright &#169; 1999 by Novosoft Inc.
  All rights reserved
</font>
<p><hr><small>File translated from T<sub><font size="-1">E</font></sub>X by <a href="http://hutchinson.belmont.ma.us/tth/">T<sub><font size="-1">T</font></sub>H</a>, version 2.25.<br>On 13 Jan 2000, 11:33.</small>
