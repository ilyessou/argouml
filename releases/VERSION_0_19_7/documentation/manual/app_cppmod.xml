<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Id$ -->
<!--
// Copyright (c) 1996-2005 The Regents of the University of California. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies.  This software program and
// documentation are copyrighted by The Regents of the University of
// California. The software program and documentation are supplied "AS
// IS", without any accompanying services from The Regents. The Regents
// does not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason.  IN NO EVENT SHALL THE
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
-->

<!--

C++ Module.

-->

<appendix id="app.cppmod">
  <title>C++ Module</title>
  <para>The &argouml; C++ Module (C++ Mod.) provides C++ code generation 
    functionalities and C++ notation within ArgoUML. 
    It works the same way as the other languages' modules.</para>
  <sect1>
    <title>Modeling for C++</title>

    <para>The C++ programming language has constructs that aren't contained by 
      default in UML. 
      Examples are pointers, global functions and variables, references and 
      operator overloading. 
      To enable us to apply these 
      constructs in our models and be capable of taking advantage of it for 
      code generation and C++ notation in UML diagrams, the C++ module uses 
      conventions in the use of the extension features of UML, tagged 
      values and stereotypes.</para>
    <para>Since UML and C++ are object oriented, there is an obvious 
      correspondence between the UML model elements and C++ structural 
      constructs, e.g, the UML <literal>Class</literal> is related to the 
      C++ <literal>class</literal>. 
      These obvious relations will not be described here, since it is assumed 
      that an ArgoUML user that wants to model for C++ has basic knowledge of 
      both C++ and UML.
    </para>
    <para>Tagged values are one of the main means by 
      which we can define code generation behavior. 
      They have a name &ndash; the tag &ndash; and a value, and are applied to 
      model elements.</para>
    <para>The tagged values in use for the C++ module have two 
      categories:</para>
    <itemizedlist>
      <listitem><para>free format values &ndash; any <literal>String</literal> 
        is valid, except the empty <literal>String</literal></para></listitem>
      <listitem><para>formated values &ndash; the value must obey some 
        restrictions, e.g., be one of <literal>true</literal> or 
        <literal>false</literal> (abbreviated to <literal>true || 
        false</literal>)</para></listitem>
    </itemizedlist>
    
    <para>For <literal>Boolean</literal> tagged values, only the values 
      "<literal>true</literal>" or "<literal>false</literal>" are applicable. 
      If a <literal>Boolean</literal> tagged value does not exist or is invalid 
      for one model element, a default value is assumed by the code generator. 
      In the bellow documentation the default value is marked.</para>
    <para>Free format tagged values are only significant if present and if the 
      value isn't an empty <literal>String</literal>. 
      When the value must follow some sort of format, that is explicitly 
      stated. 
      In this case, there is the chance that the value is invalid.
      If the value is invalid, no assumptions are made; the generator will 
      trace the problem and ignore the tagged value.</para>
      
    <sect2>
      <title><literal>Class</literal> tagged values</title>
      <variablelist>
        <!-- Entry for constructor -->
        <varlistentry>
          <term><literal>constructor</literal></term>

          <listitem>
            <para><literal>true</literal> &ndash; generates a default 
              constructor for the <literal>class</literal>.</para>
            <para><literal>false</literal> (default) &ndash; no default 
              constructor is generated, unless it is explicitly modeled with 
              the <literal>&laquo;create&raquo;</literal> stereotype.</para>
          </listitem>
        </varlistentry>

        <!-- Entry for header_incl -->
         <varlistentry>
          <term><literal>header_incl</literal></term>

          <listitem>
            <para>Name of the file to include in the header.</para>
             <warning>
              <para>This limits the number of possible included headers to one! 
                It is a severe limitation in most common uses and an issue will 
                be created (2005-09-16) for its removal.</para>
              <para>Other tagged values used for C++ modeling 
                are affected by this problem. 
                This warning won't be repeated in those cases.</para>
              <para>TODO: create an issue for this and include here a link to 
                it.</para>
            </warning>
          </listitem>
        </varlistentry>
       
        <!-- Entry for source_incl -->
        <varlistentry>
          <term><literal>source_incl</literal></term>

          <listitem>
            <para>Name of the file to include in the source 
            (<literal>.cpp</literal> file).</para>
          </listitem>
        </varlistentry>
       
        <!-- Entry for typedef_public -->
        <varlistentry>
          <term><literal>typedef_public</literal></term>

          <listitem>
            <para><literal>&lt;source type&gt; &lt;type_name&gt;</literal> 
              &ndash; creates <literal>typedef</literal> line in the public 
              area of the <literal>class</literal> with 
            <literal>typedef &lt;source type&gt; &lt;type name&gt;</literal>.
            </para>
          </listitem>
        </varlistentry>
       
        <!-- Entry for typedef_protected -->
        <varlistentry>
          <term><literal>typedef_protected</literal></term>

          <listitem>
            <para>Same as <literal>typedef_public</literal>, but, in 
              <literal>protected</literal> area.</para>
          </listitem>
        </varlistentry>
       
        <!-- Entry for typedef_private -->
        <varlistentry>
          <term><literal>typedef_private</literal></term>

          <listitem>
            <para>Same as <literal>typedef_public</literal>, but, in the 
              <literal>private</literal> area.</para>
          </listitem>
        </varlistentry>
       
        <!-- Entry for typedef_global_header -->
        <varlistentry>
          <term><literal>typedef_global_header</literal></term>

          <listitem>
            <para>Same as <literal>typedef_public</literal>, but, in the 
            global area of the header.</para>
          </listitem>
        </varlistentry>
         
        <!-- Entry for typedef_global_source -->
        <varlistentry>
          <term><literal>typedef_global_source</literal></term>

          <listitem>
            <para>Same as <literal>typedef_global_source</literal>, but, in 
            the source file.</para>
          </listitem>
        </varlistentry>
      
        <!-- Entry for TemplatePath -->
        <varlistentry>
          <term><literal>TemplatePath</literal></term>

          <listitem>
            <para><literal>Directory</literal> &ndash; 
              will search in the specified directory for the template files 
              "header_template" and "cpp_template" which are placed in top 
              of the corresponding file. 
              The following tags in the template file are 
              replaced by model values: |FILENAME|, |DATE|, |YEAR|, |AUTHOR|, 
              |EMAIL|.
              If no such tag is specified, the templates are searched in the 
              subdirectory of the root directory for the code generation.
            </para>
          </listitem>
        </varlistentry>
        
        <!-- Entry for email -->
        <varlistentry>
          <term><literal>email</literal></term>

          <listitem>
            <para><literal>name@domain.country</literal> &ndash; replaces the 
            tag |EMAIL| of the template file.</para>
          </listitem>
        </varlistentry>
     
        <!-- Entry for author -->
        <varlistentry>
          <term><literal>author</literal></term>

          <listitem>
            <para><literal>name</literal> &ndash; replaces the tag |AUTHOR| of 
              the template file.</para>
            <note><para>You may simply use the Author property in the 
            documentation property panel.</para></note>
          </listitem>
        </varlistentry>
     
      </variablelist>
    </sect2>
      
    <sect2>
      <title><literal>Attribute</literal> tagged values</title>
      <para>UML <literal>Attributes</literal> are mapped to <literal>class 
          member variables</literal>.</para>
      <variablelist>

         <!-- Entry for pointer -->
        <varlistentry>
          <term><literal>pointer</literal></term>

          <listitem>
            <para><literal>true</literal> &ndash; the type of the member 
              variable will be a pointer to the attribute type.</para>
            <para>For example, if you have the UML <literal>Attribute</literal>: 
              <literal>name: std::string</literal>, with the 
              <literal>pointer</literal> tagged value 
              set to true, the generated member variable would be: 
              <literal>std::string* name;</literal></para>
            <para><literal>false</literal> (default) &ndash; no pointer 
              modifier is applied.</para>
          </listitem>
        </varlistentry>
     
        <!-- Entry for reference -->
        <varlistentry>
          <term><literal>reference</literal></term>

          <listitem>
            <para><literal>true</literal> &ndash; the type of the member 
              variable will be a reference to the attribute type.</para>
            <para><literal>false</literal> (default) &ndash; no reference 
              modifier is applied.</para>
          </listitem>
        </varlistentry>
     
        <!-- Entry for usage -->
        <varlistentry>
          <term><literal>usage</literal></term>

          <listitem>
            <para><literal>header</literal> &ndash; 
              will lead for class types to a pre-declaration in the header, 
              and the include of the remote class header in the header of the 
              generated class.</para>
          </listitem>
        </varlistentry>
     
        <!-- Entry for MultiplicityType -->
        <varlistentry>
          <term><literal>MultiplicityType</literal></term>

          <listitem>
            <para><literal>list || slist || vector || map || stack || 
                stringmap</literal> &ndash; 
              will define a multiplicity as the corresponding STL container, 
              if the <literal>Multiplicity</literal> range of the attribute is 
              variable (for fixed size ranges this setting is ignored).
            </para>
         </listitem>
        </varlistentry>
     
        <!-- Entry for set -->
        <varlistentry>
          <term><literal>set</literal></term>

          <listitem>
            <para><literal>private || protected || public</literal> &ndash; 
              creates a simple function to set the attribute by a function 
              (call by reference is used for class-types, else call by value);
              place the function in the given visibility area.
            </para>
          </listitem>
        </varlistentry>
     
        <!-- Entry for get -->
        <varlistentry>
          <term><literal>get</literal></term>

          <listitem>
            <para><literal>private || protected || public</literal> &ndash; 
              as for <literal>set</literal>.</para>
          </listitem>
        </varlistentry>
      
      </variablelist>
    </sect2>
       
    <sect2>
      <title><literal>Parameters</literal></title>
      
      <sect3>
        <title>Variable passing semantics</title>
        <para>If a <literal>Parameter</literal> for an 
          <literal>Operation</literal> is marked as 
          <literal>out</literal> or <literal>inout</literal> the variable will 
          be passed by reference (default) or pointer (needs tagged value 
          <literal>pointer</literal> &ndash; see above), otherwise by value.
        </para>
        <para>Return values in UML are simply <literal>Parameters</literal> 
          marked as <literal>return</literal>, therefore everything here 
          applies to them, except where explicitly noted.</para> 
          
        <warning>
          <para>Note that UML allows multiple return values. 
            This is possible to support in C++ as out parameters, but, 
            currently the generator doesn't supports it.</para>
          <para>TODO: create an issue for this.</para>
        </warning>
      </sect3>

      <sect3>
      <title><literal>Parameter</literal> tagged values</title>
      <variablelist>
    
        <!-- Entry for pointer -->
        <varlistentry>
          <term><literal>pointer</literal></term>

          <listitem>
            <para><literal>true || false</literal> (default) &ndash; same as 
              for <literal>Attributes</literal>.</para>
          </listitem>
        </varlistentry>
     
        <!-- Entry for reference -->
        <varlistentry>
          <term><literal>reference</literal></term>

          <listitem>
            <para>ditto</para>
          </listitem>
        </varlistentry>
        
        </variablelist>
      </sect3>
    </sect2>

    <sect2>
      <title>Preserved sections</title>
      <para>With each code generation, special comments around the member 
        function definitions will be generated like this:</para>
      
      <programlisting>
  function Testclass::Testclass()
  // section -64--88-0-40-76f2e8:ec37965ae0:-7fff begin
	{
	}
  // section -64--88-0-40-76f2e8:ec37965ae0:-7fff end
      </programlisting>
      <para>All code you put within the "begin" and "end" lines will be 
        preserved when you generate the code again. 
        Please do not change anything within these lines because the sections 
        are recognized by this comment syntax. 
        As the curly braces are placed within the preserved area, attribute 
        initializers are preserved on constructors.
      </para>
      <para>This also works if you change Method Names after the generation.
      </para>
      
      <programlisting>
  void newOperation(std::string test = "fddsaffa")
  // section 603522:ec4c7ff768:-7ffc begin
	{
	}
  // section 603522:ec4c7ff768:-7ffc end
      </programlisting>

      <para>If you delete an Operation in the model. 
        The next time the class 
        is generated, the lost code &ndash; i.e., the whole member function 
        definition &ndash; will be added as comment to the end of the 
        file.</para>
    </sect2>

  </sect1>

</appendix>

<!-- Local stuff for Emacs - please do not delete

Local Variables:
mode: xml
sgml-doctype: "argomanual.xml"
sgml-parent-document: ("argomanual.xml" "appendix" nil)
sgml-validate-command: "nsgmls -wxml -sv ../docbook-setup/xml.dcl \
  argomanual.xml"
indent-tabs-mode: nil
End:

-->
