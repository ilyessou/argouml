<?xml version="1.0" encoding="UTF-8"?>
<part
	xmlns="http://docbook.org/ns/docbook" 
	version="5.0" 
	xml:lang="en"
	xmlns:xi="http://www.w3.org/2001/XInclude" 
	xmlns:xlink="http://www.w3.org/1999/xlink"
	>
	
	<title>Tutorial</title>
	
	<chapter xml:id="ch.tut.uml">
		<title>Introduction (being written)</title>

		<para>This tutorial will be taking you through a tour of the use of ArgoUML to model a system. </para>
		<para>First you will become familiar with the feel of the product and then we will go through an analysis and development process for a test case. Not every nook and cranny of the product will be demonstrated. That degree of detail is given in the reference materials to be found in subsequent parts of this document. </para>
		<para>The state of the model at the end of key sections will be available in .zargo files. These are available so that you can play with various aspects not specifically covered in this tutorial and then restore yourself back to the proper state of the model in your work area. These .zargo files will be identified at the end of the sections whose work they represent. </para>
		<para>An ATM (automated teller machine) project has been chosen as a case study to demonstrate the various aspects of modeling that ArgoUML offers. In subsequent sections we are going to develop the ATM example into a complete description in UML. The tutorial, however, will only walk you through part of it. </para>
		<para>At this point you should create a directory to contain your project. Name the directory anything you feel is consistent with the rest of your file system. You should name the contents and any subdirectories as directed for reasons that will become apparent. </para>
		<para>The case study will be an ATM system. Your company is FlyByNight Industries. You are going to play two roles. That of the Project Manager and that of the Designer Analyst. </para>
		<para>We are not going to build a physical ATM, of course. The product that we will build as a case study will be an ATM simulator to be used for testing the design of a physical ATM. </para>
		<para>How your company arranges its work into projects is usually determined as much by politics as anything else and is, therefore, out of the scope of this document. We will go into how you structure the project itself once one has been defined. </para>
	</chapter>

	
	<chapter xml:id="ch.tut.ooad">
		<title>UML Based OOA&amp;D</title>

		<para>In this chapter, we look at how UML as a notation is used within OOA&amp;D. </para>

		<section>
			<title>Background to UML</title>

			<para><emphasis>Object orientation</emphasis> as a concept has been around since the 1960&#039;s, and as a design concept since 1972. However it was in the 1980&#039;s that it started to develop as a credible alternative to a <emphasis>functional approach</emphasis> in analysis and design. We can identify a number of drivers.</para>

			<orderedlist>
				<listitem>
					<para>The emergence of mainstream OO programming languages like SmallTalk and particularly C++. C++ was a pragmatic OO language derived from C, widely used because of its association with Unix.</para>
				</listitem>
				<listitem>
					<para>The development of powerful workstations, and with them the emergence into the mainstream of windowing operating user environments. Graphical User Interfaces (GUI) have an inherent object structure.</para>
				</listitem>
				<listitem>
					<para>A number of very public major project failures, suggesting that current approaches were not satisfactory.</para>
				</listitem>
			</orderedlist>

			<para>A number of researchers proposed OOA&amp;D processes, and with them notations. Those that achieved some success include Coad-Yourdon, Booch, Rumbaugh OMT, OOSE/Jacobson, Shlaer-Mellor, ROOM (for real-time design) and the hybrid Jackson Structured Development.</para>
			<para>During the early 1990&#039;s it became clear that these approaches had many good ideas, often very similar. A major stumbling block was the diversity of notation, meaning engineers tended to be familiar with one OOA&amp;D methodology, rather than the approach in general.</para>
			<para>UML was conceived as a common notation, that would be in the interests of all involved. The original standard was driven by Rational Software ( <link
					xlink:href="http://www.rational.com"
				>www.rational.com</link>, in which three of the key researchers in the field (Booch, Jacobson and Rumbaugh were involved). They produced documents describing UML v0.9 and v0.91 during 1996. The effort was taken industry wide through the Object Management Group (OMG), already well known for the CORBA standard. A first proposal, 1.0 was published in early 1997, with an improved version 1.1 approved that autumn.</para>
			<para>ArgoUML is based on UML v1.4, which was adopted by OMG in March 2000. The current official version is UML v1.5 dated March 2003, soon to be replaced by a major revision, UML v2.0, which is in the final stages of standardization and is expected to be complete in 2006.</para>
		</section>

		<section>
			<title>UML Based Processes for OOA&amp;D</title>

			<para>It is important to understand that UML is a notation for OOA&amp;D. It does not prescribe any particular process. Whatever process is adopted, it must take the system being constructed through a number of phases. </para>

			<orderedlist>
				<listitem>
					<para>Requirements Capture. This is where we identify the requirements for the system, using the language of the <emphasis>problem domain</emphasis>. In other words we describe the problem in the <quote>customer&#039;s</quote> terms.</para>
				</listitem>
				<listitem>
					<indexterm>
						<primary>Analysis</primary>
					</indexterm>
					<para>Analysis. We take the requirements and start to recast them in the language of a putative solution&#8212;the <emphasis>solution domain</emphasis>. At this stage, although thinking in terms of a solution, we ensure we keep things at a high level, away from concrete details of a specific solution&#8212;what is known as <emphasis>abstraction</emphasis>.</para>
				</listitem>
				<listitem>
					<indexterm>
						<primary>Design</primary>
					</indexterm>
					<para>Design. We take the specification from the Analysis phase and construct the solution in full detail. We are moving from <emphasis>abstraction</emphasis> of the problem to its <emphasis>realization</emphasis> in concrete terms.</para>
				</listitem>
				<listitem>
					<para>Build Phase. We take the actual design and write it in a real programming language. This includes not just the programming, but the testing that the program meets the requirements (<emphasis>verification</emphasis>), testing that the program actually solves the customer&#039;s problem (<emphasis>validation</emphasis>) and writing all user documentation.</para>
				</listitem>
			</orderedlist>

			<section xml:id="s2.proctypes">
				<title>Types of Process</title>

				<para>In this section we look at the two main types of process in use for software engineering. There are others, but they are less widely used.</para>
				<para>In recent years there has also been a move to reduce the effort required in developing software. This has led to the development of a number of lightweight variants of processes (often known as <emphasis>agile computing</emphasis> or <emphasis>extreme programming</emphasis>) that are suited to very small teams of engineers.</para>

				<section>
					<title>The Waterfall Process</title>

					<para>In this process, each stage of the process&#8212;requirements, analysis, design and build (code and test) is completed before the next one starts. This is illustrated in <xref xlink:href="fig.waterfallsteps" />.</para>

					<figure floatstyle="1" xml:id="fig.waterfallsteps">
						<title>The Waterfall Process</title>
						<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/waterfallsteps.png" format="PNG" /></imageobject></mediaobject></screenshot>
					</figure>

					<para>This is a very satisfactory process where requirements are well designed and not expected to change, for example automating a well proven manual system.</para>
					<para>The weaknesses of this approach show with less well defined problems. Invariably some of the uncertainties in the requirements will not be clarified until well into the analysis and design, or even code phases, requiring backtracking to redo work.</para>
					<para>The worst aspect of this, is that working code does not become available until near the end of the project, and very often it is only at this stage that problems with the original requirements (for example with the user interface) become apparent.</para>
					<para>This is exacerbated, by each successive stage requiring more effort, than the previous, so that the costs of late problem discovery are hugely expensive. This is illustrated by the pyramid in <xref xlink:href="fig.waterfall" />.</para>

					<figure floatstyle="1" xml:id="fig.waterfall">
						<title>Effort Involved in the Steps of the Waterfall Process</title>
						
						<screenshot>
							<mediaobject>
								<imageobject>
									<imagedata align="center" fileref="images/tutorial/waterfall.png" format="PNG" />
								</imageobject>
							</mediaobject>
						</screenshot>
					</figure>
					
					<para>The waterfall process is still probably the dominant design process. However because of its limitations it is increasingly replaced by <emphasis>iterative</emphasis> processes, particularly for projects where the requirements are not well defined.</para>
				</section>

				<section>
					<title>Iterative Development Processes</title>

					<indexterm>
						<primary>Iterative Processes</primary>
					</indexterm>

					<para>In recent years a new approach has been used, which aims to get at least part of the code up and running as quickly as possible, to bring discovery of problems forward in the development cycle.</para>
					<para>These processes use a series of <quote>mini-waterfalls</quote>, defining a few requirements (the most important) first, taking them through analysis, design and build to get an early version of the product, with limited functionality, related to the most important requirements. Feedback from this can then be used to refine the requirements, spot problems etc before more work is done.</para>
					<para>The process is then repeated for further requirements to construct a product with a step up in functionality. Again further feedback can be applied to the requirements.</para>
					<para>The process is repeated, until eventually all requirements have been implemented and the product is complete. <indexterm>
							<primary>Iteration</primary>
						</indexterm> It is this <emphasis>iteration</emphasis> that gives these processes their name. <xref
							xlink:href="fig.iterative"
						 /> shows how this process compares to the pyramid structure of the Waterfall Process. </para>

					<figure floatstyle="1" xml:id="fig.iterative">
						<title>Effort Involved in the Steps of an Iterative Process</title>
						<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/iterative.png" format="PNG" /></imageobject></mediaobject></screenshot>
					</figure>
					<para>The growth in popularity of iterative processes is closely tied to the growth of OOA&amp;D. It is the clean encapsulation of objects that allows a part of a system to be built with stubs for the remaining code clearly defined.</para>

					<section>
						<title>The Rational Unified Process</title>

						<para>Perhaps the best known Iterative Process is the Rational Unified Process (RUP) from Rational Software ( <link
								xlink:href="http://www.rational.com">www.rational.com</link>).</para>
						<para>This process recognizes that our pyramid view of even slices of the waterfall is not realistic. In practice the early iterations tend to be heavy on the requirements end of things (you need to define a reasonable amount even to get started), while the later iterations have more of their effort in the design and build areas.</para>
						<para>RUP recognizes that iterations can be grouped into a number of <emphasis>phases</emphasis> according to their stage in the overall project. Each phase may have one or more iterations.</para>

						<itemizedlist>
							<listitem>
								<para>In the <emphasis>inception phase</emphasis> iterations tend to be heavy on the requirements/analysis end, while any build activity may be limited to emulation of the design within a CASE tool.</para>
							</listitem>
							<listitem>
								<para>In the <emphasis>elaboration phase</emphasis> iterations tend to be completing the specification of the requirements, and starting to focus on the analysis and design, and possibly the first real built code.</para>
							</listitem>
							<listitem>
								<para>In the <emphasis>construction phase</emphasis> iterations the requirements and analysis are more or less completed, and the effort is mostly in design and build.</para>
							</listitem>
							<listitem>
								<para>Finally, in the <emphasis>deployment phase</emphasis> iterations are largely about build activity, and in particular the testing of the software.</para>
							</listitem>
						</itemizedlist>

						<note>
							<para>It should be clear that testing is an integral part of all phases. Even in the early phases the requirements and design should be tested, and this is facilitated by a good CASE tool.</para>
						</note>

						<para>We shall use an iterative process in this manual, that is loosely based on the RUP.</para>
					</section>

					<section>
						<title>Iteration Size</title>

						<para>A good rule of thumb is that an iteration should take between six and ten weeks for typical commercial projects. Any longer and you have probably bitten off too many requirements to do in one go. You also lose focus on getting the next working iteration completed. Any shorter and you probably haven&#039;t got enough requirements to make a significant advance. In this case the additional overhead associated with an interation will become a problem. </para>
						<para>The total number of iterations depends on the size of project. Take the estimated time (working out/guessing that is a whole subject on its own), and divide it into 8 week chunks. Experience seems to suggest that the iterations will divide in the ratio of around 1:2:3:3 into RUP style inception, elaboration, construction and deployment phases. A project that has great vagueness in its specification (some advanced research projects for example) will tend to be heavier on the early phases. </para>
						<para>When building a product to contract for a customer the end point is well defined. However when developing a new product for the market place, a strategy that can be used is to decide the product launch date, and hence the end date for completion of engineering (some time before). The time is then divided into iterations, and as much of the product as can be built in that time developed. The iterative process is very effective where time to market is more important than the exact functionality.</para>
					</section>
				</section>

				<section>
					<title>Recursive Development Processes</title>

					<para>Very few software systems are conceived as monolithic artifacts. They are broken down into subsystems, modules etc.</para>
					<para>Software processes are the same, with early parts of the process defining a top level structure, and the process reapplying to parts of the structure in turn to define ever greater details.</para>
					<para>For example the initial design of a telephone system might identify objects to i) handle the phone lines, ii) process the calls, iii) manage the system and iv) bill the customer. The software process can then be reapplied to each of these four components to identify their design.</para>
					<para>OOA&amp;D with its clean boundaries to objects, naturally supports this approach. Such OOA&amp;D with recursive development is sometimes abbreviated as OOA&amp;D/RD.</para>
					<para>Recursive development can be applied equally well to waterfall or iterative processes. It is not an alternative to them.</para>
				</section>
			</section>

			<section>
				<title>A Development Process for This Tutorial</title>

				<para>For the purpose of this tutorial we will use a stripped down iterative process with recursive development, loosely akin to RUP. The case study will take us through the first iteration, although at the end of the tutorial section of the manual we will look at how the project will develop to completion.</para>
				<para>Within that first iteration, we will tackle each of the requirements capture, analysis, design and build activities in turn. Not all parts of the process are based on UML or ArgoUML. We will look at what other material is needed outside.</para>
				<para>Within this process we will have an opportunity to see the various UML diagrams in use. The full range of UML diagrams and how they are supported is described in the reference manual (see <xref
						xlink:href="s1.ref.diagram_types" /> ).</para>

				<section>
					<title>Requirements Capture</title>

					<para>Our requirements capture will use the UML concept of <emphasis>Use Cases</emphasis>. Starting with a <emphasis>Vision Document</emphasis> we will see how Use Cases can be developed to describe all aspects of the system&#039;s behavior in the problem domain.</para>
				</section>

				<section>
					<title>Analysis</title>

					<indexterm>
						<primary>Analysis</primary>
					</indexterm>

					<para>During the analysis stage, we will introduce the UML concept of <emphasis>classes</emphasis> to allow us to build a top level view of the objects that will make up the solution&#8212;sometimes known as a <emphasis>concept diagram</emphasis>.</para>
					<para>We will introduce the UML <emphasis>sequence diagram</emphasis> and <emphasis>statechart diagram</emphasis> to capture requirements for the overall behavior of the system.</para>
					<para>Finally we will take the Use Cases from the requirements capture stage, and recast them in the language of the solution domain. This will illustrate the UML ideas of <emphasis>stereotyping</emphasis> and <emphasis>realization</emphasis>.</para>
				</section>

				<section>
					<title>Design</title>

					<indexterm>
						<primary>Design</primary>
					</indexterm>

					<para>We use the UML <emphasis>package diagram</emphasis> to organize the components of the project. We then revisit the class diagram, sequence diagram and statechart diagram, to show how they can be used recursively to design the complete solution.</para>
					<para>During this part of the process, we need to develop our system architecture, to define how all the components will fit together and operate.</para>
					<para>Although not strictly part of our process, we&#039;ll look at how the UML <emphasis>collaboration diagram</emphasis> can be used as an alternative to, or to complement the <emphasis>sequence diagram</emphasis>. Similarly we will look at the UML <emphasis>activity diagram</emphasis> as an alternative or complement to the statechart diagram.</para>
					<para>Finally we shall use the UML <emphasis>deployment diagram</emphasis> to specify how the system will actually be realized.</para>
				</section>

				<section>
					<title>Build</title>

					<indexterm>
						<primary>Build</primary>
					</indexterm>

					<para>UML is not really concerned with code writing. However at this stage we will show how ArgoUML can be used for code generation.</para>
					<para>We will also look at how the UML Use Case Diagram and Use Case Specification are invaluable tools for a test program.</para>
				</section>
			</section>
		</section>

		<section>
			<title>Why ArgoUML is Different</title>

			<para>In the introduction, we listed the four key things that make ArgoUML different: i) it makes use of ideas from cognitive psychology, ii) it is based on open standards; iii) it is 100% pure Java; and iv) it is an open source project.</para>

			<section xml:id="tut.cog.psych">
				<title>Cognitive Psychology</title>

				<section>
					<title>Theory</title>

					<para>ArgoUML is particularly inspired by three theories within cognitive psychology: i) reflection-in-action, ii) opportunistic design iii) and comprehension and problem solving.</para>

					<itemizedlist>
						<listitem>
							<para>
								<emphasis>Reflection-in-Action</emphasis>
								<indexterm>
									<primary>Reflection-in-Action</primary>
								</indexterm>
							</para>
							<para>This theory observes that designers of complex systems do not conceive a design fully-formed. Instead, they must construct a partial design, evaluate, reflect on, and revise it, until they are ready to extend it further. </para>
							<para>As developers work hands-on with the design, their mental model of the problem situation improves, hence improving their design. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>Opportunistic Design</emphasis>
								<indexterm>
									<primary>Opportunistic Design</primary>
								</indexterm>
							</para>
							<para>A theory within cognitive psychology suggesting that although designers plan and describe their work in an ordered, hierarchical fashion, in reality, they choose successive tasks based on the criteria of cognitive cost. </para>
							<para>Simply stated, designers do not follow even their own plans in order, but choose steps that are mentally least expensive among alternatives. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>Comprehension and Problem Solving</emphasis>
								<indexterm>
									<primary>Comprehension</primary>
								</indexterm>
								<indexterm>
									<primary>Problem Solving</primary>
								</indexterm>
							</para>
							<para>A design visualization theory within cognitive psychology. The theory notes that designers must bridge a gap between their mental model of the problem or situation and the formal model of a solution or system. </para>
							<para>This theory suggests that programmers will benefit from: </para>
							<orderedlist>
								<listitem>
									<para>Multiple representations such as program syntactic decomposition, state transitions, control flow, and data flow. These allow the programmer to better identify elements and relationships in the problem and solution and thus more readily create a mapping between their situation models and working system models. </para>
								</listitem>
								<listitem>
									<para>Familiar aspects of a situation model, which improve designers&#039; abilities to formulate solutions. </para>
								</listitem>
							</orderedlist>
						</listitem>
					</itemizedlist>
				</section>

				<section>
					<title>Practical Application in ArgoUML</title>

					<para>ArgoUML implements these theories using a number of techniques. </para>

					<orderedlist>
						<listitem>
							<para>The design of a user interface which allows the user to view the design from a number of different perspectives, and allows the user to achieve goals through a number of alternative routes.</para>
						</listitem>
						<listitem>
							<para>The the use of processes running in parallel with the design tool, evaluating the current design against models of how <quote>best practice</quote> design might work. These processes are known as <emphasis>design critics</emphasis>.</para>
						</listitem>
						<listitem>
							<para>The use of <emphasis>to-do lists</emphasis> to convey suggestions from the design critics to the user, as well as allowing the user to record areas for future action.</para>
						</listitem>
						<listitem>
							<para>The use of checklists, to guide the user through a complex process.</para>
						</listitem>
					</orderedlist>
				</section>
			</section>

			<section>
				<title>Open Standards</title>

				<para>UML is itself an open standard. ArgoUML throughout has tried to use open standards for all its interfaces.</para>
				<para>The key advantage of adherence to open standards is that it permits easy inter-working between applications, and the ability to move from one application to another as necessary. </para>

				<section>
					<title>XML Metadata Interchange (XMI)</title>

					<indexterm>
						<primary>XMI</primary>
					</indexterm>

					<para><emphasis>XML Metadata Interchange (XMI)</emphasis> is the standard for saving the meta-data that make up a particular UML model. In principle this will allow you to take the model you have created in ArgoUML and import it into another tool.</para>
					<para>This clearly has advantages in allowing UML to meet its goal of being a standard for communication between designers.</para>
					<para>The reality is not quite this good. Prior to UML 2.0 the XMI file includes no information about the graphical representation of the models, so diagram layout is lost. ArgoUML gets round this by saving graphical information separate from the model (see <xref
							xlink:href="s3.tut.loadsave" />). </para>
				</section>

				<section>
					<title>Graphics Formats - EPS, GIF, PGML, PNG, PS, SVG</title>

					<itemizedlist>
						<listitem>
							<para>
								<indexterm>
									<primary>EPS</primary>
								</indexterm>
								<link
									xlink:href="http://en.wikipedia.org/wiki/Encapsulated_PostScript">
									<emphasis>Encapsulated PostScript (EPS)</emphasis>
								</link> file is a PostScript file which satisfies additional restrictions. These restrictions are intended to make it easier for software to embed an EPS file within another PostScript document. </para>
						</listitem>
						<listitem>
							<para>
								<indexterm>
									<primary>GIF</primary>
								</indexterm>
								<link xlink:href="http://en.wikipedia.org/wiki/GIF">
									<emphasis>Graphics Interchange Format (GIF)</emphasis>
								</link> is a patent encumbered format, although the patents will run out in August of 2006. </para>
						</listitem>
						<listitem>
							<para>
								<indexterm>
									<primary>PGML</primary>
								</indexterm>
								<link xlink:href="http://en.wikipedia.org/wiki/PGML">
									<emphasis>Precision Graphics Markup Language (PGML)</emphasis>
								</link> is an XML-based language for representing vector graphics. It was a W3C draft, but was not adopted as a recommendation. PGML and VML, another XML-based vector graphics language, were later joined and improved upon to create SVG (see below). </para>
						</listitem>
						<listitem>
							<para>
								<indexterm>
									<primary>PNG</primary>
								</indexterm>
								<link xlink:href="http://en.wikipedia.org/wiki/PNG">
									<emphasis>Portable Network Graphics (PNG)</emphasis>
								</link> is an ISO/IEC standard (15948:2004) and is also a W3C recommendation. PNG is a bitmap image format that employs lossless data compression. PNG was created to both improve upon and replace the GIF format with an image file format that does not require a patent license to use. PNG is officially pronounced "ping" but it is often just spelled out &#8212; probably to avoid confusion with the network tool ping. PNG is supported by the libpng reference library, a platform-independent library that contains C functions for handling PNG images. </para>
						</listitem>
						<listitem>
							<para>
								<indexterm>
									<primary>PS</primary>
								</indexterm>
								<link xlink:href="http://en.wikipedia.org/wiki/PostScript/">
									<emphasis>PostScript (PS)</emphasis>
								</link> is a page description language and programming language used primarily in the electronic and desktop publishing areas. </para>
						</listitem>
						<listitem>
							<para>
								<indexterm>
									<primary>SVG</primary>
								</indexterm>
								
								<link xlink:href="http://en.wikipedia.org/wiki/Scalable_Vector_Graphics"> <emphasis>Scalable Vector Graphics (SVG)</emphasis> </link> is an XML markup language for describing two-dimensional vector graphics, both static and animated, and either declarative or scripted. It is an open standard created by the World Wide Web Consortium. The use of SVG on the web is in its infancy. There is a great deal of inertia due to the long-time use of pure raster formats and other formats like Macromedia Flash or Java applets, but also browser support is still uneven, with native support in Opera and Firefox, but Safari and Internet Explorer require a plugin. See PGML above. </para>
						</listitem>
					</itemizedlist>
				</section>

				<section>
					<title>Object Constraint Language (OCL)</title>

					<para><link xlink:href="http://en.wikipedia.org/wiki/Object_Constraint_Language"> <emphasis>Object Constraint Language (OCL)</emphasis> </link> is a declarative language for describing rules that apply to UML models. It was developed at IBM and is now part of the UML standard. Initially OCL was only a formal specification language extension to UML. OCL may now be used with any Meta-Object Facility (MOF) compliant metamodel, including UML. The Object Constraint Language is a precise text language that provides constraint and object query expressions on any MOF model or metamodel that cannot otherwise be expressed by diagrammatic notation. </para>
				</section>
			</section>

			<section>
				<title>100% Pure Java</title>

				<para>Java was conceived as an interpreted language. It doesn&#039;t have a compiler to produce code for any particular target machine. It compiles code for its own target, the <emphasis>Java Virtual Machine (JVM)</emphasis>.</para>
				<para>Writing an interpreter for a JVM is much easier than writing a compiler, and such machines are now incorporated into almost every Web Browser. As a result most machines can run Java, with no further work.</para>
				<para>(In case you wonder why all languages aren&#039;t like this, it is because interpreted languages tend to be slower than compiled languages. However with the high performance of modern PCs, the trade-off for portability is worthwhile for many applications. Furthermore modern multi-level caches can mean that interpreted languages, which produce denser code, may actually not be that much slower anyway.)</para>
				<para>By choosing to write ArgoUML in pure Java, it is immediately made available to the maximum number of users with the minimum amount of effort.</para>
			</section>

			<section>
				<title>Open Source</title>

				<para>ArgoUML is an <emphasis>open source</emphasis> project. That means anyone can have a free copy of the source code, change it, use it for new purposes and so on. The only (major) obligation is that you pass your code on in the same way to others. The precise nature of what you can and can&#039;t do varies from project to project, but the principle is the same.</para>
				<para>The advantage is that a small project like ArgoUML suddenly is open to a lot of additional help from those who can chip in their ideas for how the program might be improved. At any one time there may be 10, 15, 20 or more people making significant contributions to ArgoUML. To do that commercially would cost $1m+ per year. </para>
				<para>Its not just a spirit of pure altruism. Contributing is a way of learning <quote>hands-on</quote> about leading edge software. Its a way of getting a lot of visibility (over 1,125,000 people had downloaded ArgoUML by the end of 2005). That&#039;s a lot of good experience on a résumé and a lot of potential employers seeing you!</para>
				<para>And its great for the ego!</para>
				<para>Open Source doesn&#039;t preclude making money. Gentleware <link xlink:href="http://www.gentleware.com" > www.gentleware.com</link> sell a commercial version of ArgoUML, Poseidon. Their value proposition is not a piece of private code. Its the commercial polish and support that take risk out of using ArgoUML in a commercial development, allowing customers to take advantage of ArgoUML&#039;s leading edge technology.</para>
			</section>
		</section>

		<section xml:id="tut.basics">
			<title>ArgoUML Basics</title>

			<para>The aim of this section is to get you started with ArgoUML. It takes you through obtaining the code and getting it running.</para>

			<section>
				<title>Getting Started</title>

				<section xml:id="s3.tut.system.requirements">
					<title>System Requirements</title>

					<para>Since ArgoUML is written in 100% pure Java, it should run on any machine with Java installed. Java, version 1.4 or later is needed. You may have this in place, but if not it can be downloaded free from <link xlink:href="http://www.java.com" >www.java.com</link>. Note that you only need the Java Runtime Environment (JRE), there is no need to download the whole Java Development Kit (JDK).</para>
					<para>ArgoUML needs a reasonable amount of computing resource. A PC with 200MHz processor, 64Mb RAM and 10Mb of space available on a harddisk should be adequate. Download the code from Download section of the project website <link xlink:href="http://argouml.tigris.org" > argouml.tigris.org</link>. Choose the version that suits your needs as described in the section below.</para>
				</section>

				<section>
					<title>Downloading Options</title>

					<para>You have three options for obtaining ArgoUML.</para>

					<orderedlist>
						<listitem>
							<para>Run ArgoUML directly from the Web Site using Java Web Start. This is the easiest option.</para>
						</listitem>
						<listitem>
							<para>Download the binary executable code. This is the right option if you intend using ArgoUML regularly and is not that difficult.</para>
						</listitem>
						<listitem>
							<para>
								<indexterm>
									<primary>Build</primary>
								</indexterm>
									Download the source code using CVS and build your own version. Choose this option if you want to look at the internal workings of ArgoUML, or want to join in as a developer. This option does require the whole JDK (see <xref
									xlink:href="s3.tut.system.requirements" />). </para>
						</listitem>
					</orderedlist>

					<para>All three options are freely available through the project web site, <link
							xlink:href="http://argouml.tigris.org">argouml.tigris.org</link>.</para>
				</section>

				<section>
					<title>ArgoUML Using Java Web Start</title>

					<para>There are two steps to this.</para>

					<orderedlist>
						<listitem>
							<para>Install Java Web Start on your machine. This is available from <link
									xlink:href="http://java.sun.com/products/javawebstart"
									> java.sun.com/products/javawebstart</link>, or via the <literal>Java Web Start</literal> link on the ArgoUML <link
									xlink:href="http://argouml.tigris.org">home page</link>.</para>
						</listitem>
						<listitem>
							<para>Click on the <literal>Launch latest stable release</literal> link on the ArgoUML <link
									xlink:href="http://argouml.tigris.org">home page</link>.</para>
						</listitem>
					</orderedlist>
					<para>Java Web Start will download ArgoUML, cache it and start it the first time, then on subsequent starts, check if ArgoUML is updated and only download any updated parts and then start it. The ArgoUML <link
							xlink:href="http://argouml.tigris.org"
						>home page</link> also provides details on starting ArgoUML from the Java Web Start console.</para>
				</section>

				<section>
					<title>Downloading the Binary Executable</title>

					<para>If you choose to download the binary executable, you will have a choice of downloading the latest stable version of the code (which will be more reliable, but not have all the latest features), or the current version (which will be less reliable, but have more features). Choose according to your own situation.</para>
					<para>ArgoUML comes in <literal>.zip</literal> or <literal> tar.gz</literal> flavors. Choose the former if you are a Microsoft Windows user, and the latter if you are running some flavor of Unix. Unpacking is as follows.</para>

					<itemizedlist>
						<listitem>
							<para>On Windows. Unzip the <literal>.zip</literal> file with WinZip, or on later versions of Windows (ME, XP) copy the files out of the compressed folder and put them into a directory of your choosing.</para>
						</listitem>
						<listitem>
							<para>On Unix. Use GNU tar to unzip and break out the files to a directory of your choice <literal>tar zxvf «file».tar.gz</literal>. If you have an older version of tar, the <literal>z</literal> option may not be available, so use <literal>gunzip « file.tar.gz | tar ;xvf -</literal>.</para>
						</listitem>
					</itemizedlist>
					<para>You should have a directory containing a number of <literal>.jar</literal> files and a <literal>README.txt</literal>.</para>
				</section>

				<section xml:id="s4.probsolving">
					<title>Problems Downloading</title>

					<para>If you get completely stuck and you have no local assistance, try the web site, particularly the <link
							xlink:href="http://argouml.tigris.org/faqs/users.html"
						> FAQ</link>. If this still doesn&#039;t solve the problem, try the ArgoUML users&#039; mailing list.</para>
					<para>You can subscribe through the mailing lists section of the project web site <link
							xlink:href="http://argouml.tigris.org"
							> argouml.tigris.org</link>, or send an empty message to <link
							xlink:href="mailto:users@argouml.org"
							> users@argouml.org</link> with the subject line <literal> subscribe</literal>.</para>
					<para>You can then send your problem to <link
							xlink:href="mailto:users@argouml.org"
						> users@argouml.org</link> and see how other users are able to help.</para>
					<para>The users&#039; mailing list is an excellent introduction to the live activity of the project. If you want to get further involved there are additional mailing lists that cover the development of the product and issues in the current and future releases.</para>
				</section>

				<section>
					<title>Running ArgoUML</title>

					<para>To run ArgoUML depends on whether you use Microsoft Windows or some flavor of Unix.</para>

					<itemizedlist>
						<listitem>
							<para>On Windows. Start an MSDOS shell window by e.g. using Start/Run with <quote>command</quote> in the text window. In the window change to the directory holding your ArgoUML files and type <literal>java -jar argouml.jar</literal>. This method has the advantage that progress and debugging information is visible in the DOS window. Alternatively create a batch file (.bat) containing the above command, with a shortcut to it on the desktop. The batch file should end with a "pause" statement in case any debugging information is created during a run. On some systems, simply (double) clicking on the <literal>argouml.jar</literal> file works. On others doing so initiates a zip utility. Refer to you operating system instructions or help facility to determine how to configure this. </para>
						</listitem>
						<listitem>
							<para>On Unix. Start a shell window and type <literal>java -jar argouml.jar</literal>
							</para>
						</listitem>
					</itemizedlist>
				</section>

				<section>
					<title>Problems Running ArgoUML</title>

					<para>It&#039;s unusual to encounter problems if you have made a successful download. If you can&#039;t solve the problem. Try the users&#039; mailing list (see <xref
							xlink:href="s4.probsolving" />). </para>

					<itemizedlist>
						<listitem>
							<para>Wrong JRE. The most common issue is not having a new enough Java Runtime Environment (it must be 1.4 or later). </para>
						</listitem>
						<listitem>
							<para>Wrong language. If the product came up in a language you can&#039;t read or just don&#039;t want, go to the second leftmost menu item in the menu bar at the top of the screen. Select the bottom most menu entry in the drop down. <xref
									xlink:href="fig.prob.run.02"
									 /> shows this in Russian. Then click on the second tab from the bottom in the column of tabs on the left. Drop down the list as shown in <xref
									xlink:href="fig.prob.run.02"
									 /> and select a language. Note that the languages are listed in themselves. The language shown as being selected is German in which the word for <quote>German</quote> is <quote>Deutsch</quote>. You will have to exit ArgoUML and restart it for the change to take effect. Use the X button at the upper right. </para>
						</listitem>
					</itemizedlist>

					<figure floatstyle="1" xml:id="fig.prob.run.01">
						<title>Finding the Settings Wizard</title>
						<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/langprob01.png" format="PNG" /></imageobject></mediaobject></screenshot>
					</figure>

					<figure floatstyle="1" xml:id="fig.prob.run.02">
						<title>Setting Language in the Appearance Pane</title>
						<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/langprob02.png" format="PNG" /></imageobject></mediaobject></screenshot>
					</figure>
				</section>
			</section>

			<section xml:id="tut.user.iface">
				<title>The ArgoUML User Interface</title>

				<para>Before beginning the Case Study, you need to become familiar with the user interface. Start by reading the introduction to the User Interface Reference. See <xref
						xlink:href="ch.ref.ui" />. You should also read the <xref
						xlink:href="s1.ref.mouse" />
				</para>
				<para>As you go through this tutorial you will be told what to do, and when to do it but how to do it will often be left to the User Interface Reference. It is not necessary at this point to read all of the Reference, but you should leaf through enough of it to become familiar with how to find things in it. Every attempt will be made to direct you to the appropriate part of the Reference at those points in the tutorial where they apply. </para>
				<para>
					<xref xlink:href="fig.tut.startup"
					 />, shows the main ArgoUML window as it appears when ArgoUML is first entered. </para>

				<figure floatstyle="1" xml:id="fig.tut.startup">
					<title>Initial ArgoUML window</title>
					<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/startup.gif" format="GIF" /></imageobject></mediaobject></screenshot>
				</figure>

				<para>Grab the vertical divider bars and move them back and forth. Grab the horizontal divider bar and move it up and down. Play around a little with the little arrows at the left or top of the divider bars. See <xref
						xlink:href="s1.ref.panes" />. </para>

				<section xml:id="tut.menu.toolbars">
					<title>The Menu Bar and Toolbars</title>

					<indexterm>
						<primary>Menu Bar</primary>
					</indexterm>
					<indexterm>
						<primary>Toolbars</primary>
					</indexterm>

					<para>The menu bar and toolbars give access to all the main features of ArgoUML. As is conventional, menu options and toolbar options that are not available (disabled) are grayed out and menu items that invoke a dialog box are followed by an ellipsis (…). At this time you should read <xref
							xlink:href="ch.ref.toolbar" /> and <xref xlink:href="ch.ref.menu" />. </para>
					<para>
						<emphasis>File</emphasis> menu. <indexterm>
							<primary>File Menu</primary>
						</indexterm> The standard file menu entries present no surprises and we will just use them when needed without first showing how they work. A number of other actions are available that are peculiar to ArgoUML and we will go over them here. </para>

					<orderedlist>
						<listitem>
							<para>
								<emphasis>File=»Revert to Saved.</emphasis> This has the same effect as File=»Open Project selecting the current project. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>Export/Import.</emphasis> Select the project line at the top of the Explorer. It should say "untitledModel" unless you have changed it. Perform a <emphasis>File=»Export XMI</emphasis> action using "DeleteThis" for an output name in the file chooser dialog. Select the "Properties" tab in the "Details Pane" and change the name to something else, anything will do. Perform a <emphasis>File=»Import XMI</emphasis> action. It will ask you whether you want to save the changes you have just made. Click on "No" and then in the file choosed that comes up select the "DeleteThis.xmi" file that you just wrote out. Observe that the name of the model has reverted back to what you had saved. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>File=»Import Sources.</emphasis> We will cover this later. You can&#039;t test it now unless you have some Java source code of your own handy. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>File=»Export (All) Graphics.</emphasis> In the Explorer Pane select one of the diagrams. Either "Class Diagram 1" or "Use Case Diagram 1" (assuming you haven&#039;t renamed or deleted them). Perform a <emphasis>File=»Export Graphics</emphasis> action. When the file chooser opens it defaults to the last name you saved something to (even from a project no longer open). The file chooser allows you to select from a number of formats. Drop down the "Files of type" combobox and observe the choices. Cancel out as there is nothing useful to save. Perform a <emphasis>File=»Export All Graphics</emphasis> action. Notice that this time you can&#039;t specify a file name and you can&#039;t select a file format. ArgoUML will allow you only to select an output directory. It will then create a file for each of your diagrams using the diagram name for the file name and an extension determined by the default graphics format. Actually, although you can&#039;t select file names in the browser panel, you can type one into the edit box. But, if you do that, nothing at all will happen. You will learn more about the default graphics format when we get to the <emphasis>Edit</emphasis> menu. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>File=»Notation.</emphasis> We are going to get a little ahead of ourselves here and do a little class diagram work so you can see what notation is all about. In the Explorer Pane select or create a class diagram. See <xref
									xlink:href="s1.ref.create.diagram.menu" /> and <xref
									xlink:href="s2.ref.edit_pane_drawing_tools"
									 />. Create a class in the diagram. Go to the Detail Pane and create an attribute in the class. See <xref
									xlink:href="s2.ref.class_property_toolbar"
									 />. In the Properties tab of the Detail Pane change the multiplicity to "1..*". Now go the the <emphasis>File Menu</emphasis> and select <emphasis>Notation</emphasis>. Go back and forth between UML and Java observing the changes in the display in the Edit Pane. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>File=»Properties.</emphasis> You can change the Notation language in the Properties dialog as well. Click on <emphasis>File=»Properties</emphasis> and select the Notations tab. Set the Notation Language to UML1.4. Turn on all of the options and click Apply. Then turn off all of the options and click Apply observing the changes in the diagram. Set the Default Shadow Width to 8 and click Apply. Notice that nothing happens. This is because you are not setting the Shadow Width, but its default. The next time you create a class in a diagram, this new shadow value will apply. </para>
						</listitem>
					</orderedlist>

					<para>
						<emphasis>Edit</emphasis> menu. <indexterm>
							<primary>Edit Menu</primary>
						</indexterm> The edit menu does not look like what you are used to in other products. There are no "Cut", "Copy", or "Paste" actions. All of the choices are peculiar to ArgoUML so we are going to cover all of them in detail. </para>

					<orderedlist>
						<listitem>
							<para>
								<emphasis>Edit=»Select.</emphasis>
							</para>
							<itemizedlist>
								<listitem>
									<para>Select a class diagram in the Explorer Pane. If there is none there create one using <emphasis>Create=»New Class Diagram</emphasis>. Create three classes using the class tool described in the User Interface Reference section on Class Diagram Specific Tools. Double click on it and then click in the Edit Pane for the class diagram in three different locations. </para>
								</listitem>
								<listitem>
									<para>Undo the current mode by clicking on the "Select" tool. See <xref
											xlink:href="s2.ref.edit_layout"
										 />. This allows you to do things in the Edit Pane other than creating classes. </para>
								</listitem>
								<listitem>
									<para>Each of the classes in the diagram has three vertically spaced sections. Double click in the top section of each class and enter a name for the class then hit the enter key. Just name the classes "A", "B", and "C". Select class A, then class B, and then class C either in the Edit Pane or in the Explorer Pane. </para>
								</listitem>
								<listitem>
									<para>Now do an <emphasis>Edit=»Select=»Navigate Back</emphasis>. Class B should now be selected. Do another <emphasis>Edit=»Select=»Navigate Back</emphasis>. Class A should now be selected. Finally, do an <emphasis>Edit=»Select=»Navigate Forward</emphasis>. Class B should be selected again. </para>
								</listitem>
								<listitem>
									<para>Do an <emphasis>Edit=»Select=»Invert Selection</emphasis>. Classes A and C should now be selected. Do another <emphasis>Edit=»Select=»Invert Selection</emphasis>. Class B should be selected again. </para>
								</listitem>
								<listitem>
									<para>Do an <emphasis>Edit=»Select=»Remove From Diagram</emphasis>. Notice that class B is gone from the diagram but still exists in the Explorer Pane. </para>
								</listitem>
								<listitem>
									<para>Select class B in the Explorer Pane, right click on it and choose "Add to Diagram". Move the cursor back onto the Edit Pane and left click on some part of the diagram where you think it will fit. You should be pretty much right back where you were before you removed it from the diagram. Do an <emphasis>Edit=»Select=»Delete From Model</emphasis>. Now class B should be gone both from the diagram and from the Explorer Pane. </para>
								</listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<para>
								<emphasis>Edit=»Configure Perspectives</emphasis>. Read <xref
									xlink:href="s1.ref.configure_perspectives"
								 />. We aren't going to go into this at this point as it needs much larger projects to be displayed than we have available at this point. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>Edit=»Settings=»Preferences</emphasis>. Enter Help=»About ArgoUML. Look at the panel in the "splash" tab. This is known as the Splash Panel. Go to Edit=»Settings=»Preferences. Turn off the "Show Splash Panel" check button. Exit from ArgoUML and restart it. Note that the splash panel does not show during the load. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>Edit=»Settings=»Environment</emphasis>. Do <emphasis>File=»Export Graphics</emphasis> and observe the file extension that shows at the bottom of the file chooser dialog in the "Files of type" combobox. Go to the <emphasis>Edit=»Settings=»Environment</emphasis> editor and pick some other value for Default graphics format. Click "Apply" and then "OK". Go back to the <emphasis>File=»Export Graphics</emphasis> dialog and notice that the new format is now the default. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>Edit=»Settings=»User</emphasis>. Enter your name and email address. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>Edit=»Settings=»Appearance</emphasis>. Change the "Look and Feel:" to Metal." Note that the "Metal Theme:" editor becomes anabled. Change the theme to "Very Large Fonts." Click on "Apply" and then "OK." Notice that nothing has happened. Exit from ArgoUML and reopen it. The display should be markedly different. You can change it back or leave it that way as you prefer. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>Edit=»Settings=»Notations</emphasis>. We played around with this earlier with the <emphasis>File=»Notation</emphasis> and <emphasis>File=»Properties</emphasis> menu items. Start another copy of ArgoUML resize each copy so they can be seen at the same time next to each other. On one of them set the Notation Language to UML (the actual choice will have a version number with it). On the other set the Notation Language to Java. </para>
							<para>On both of them do the following. Turn all of the check boxes on. Do a <emphasis>File=»New</emphasis>, create a class in a class diagram. Double click in the attributes section to create an attribute. Double click in the operation section to create a method. Observe the difference in the displays. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>Edit=»Settings=»Modules</emphasis>. This is work in progress. We are not going to mess with it in this version of the tutorial. </para>
						</listitem>
					</orderedlist>

					<para>
						<emphasis>View</emphasis> menu. <indexterm>
							<primary>View Menu</primary>
						</indexterm> This allows you to switch between diagrams, find model elements in the model, zoom in a diagram, adjust the grid, toggle page break display, and show an XML representation of the project. Do a <emphasis>File=»New</emphasis> to get back to a known point. Create an example of each diagram type not already in the Explorer Pane. Click on the (+) sign widgets in the Explorer Pane to expand the tree nodes. Select the class diagram and give it a name. </para>

					<orderedlist>
						<listitem>
							<para>
								<emphasis>View=»Goto Diagram</emphasis> brings up a Go To Diagram panel. Select the class diagram entry in this panel and click on the "Go to Selection" button. There should be 0 nodes and 0 edges in the leftmost column. Click on the "Close" button. In the Details Pane (Properties tab) enter the name as "Blort". Create two classes (See …) in the class diagram and go back to <emphasis>View=»Goto Diagram</emphasis>. You should now see 2 nodes and 0 edges shown. Click on the "Close" button again and link the classes with one of the "line" items like association or generalization. Go back to <emphasis>View=»Goto Diagram</emphasis> and you should see 2 nodes and 1 edge(s). Click on the "Close" button again and create a third class. Run the mouse over the icons in the toolbar until you find the one with the tooltip "New Association Class." Click on this tool and then connect the new class to one of the others. Having clicked on the "New Association Class" tool move the mouse over the new class. Press and hold down button 1. Move the mouse over one of the other classes and release button 1. Go back to <emphasis>View=»Goto Diagram</emphasis> and you should see 3 nodes and 2 edge(s). Even though it is a class and has a two dimensional representation, it counts as an edge not a node. Select other entries in this panel and click on the "Go to Selection" button in the Go To Diagram panel. Observe the changes in the Explorer Panel. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>View=»Find.</emphasis> At this point you should have three normal classes and an association class in the Explorer Pane. Name them "AA", "AB", "B", and "C". Perform a <emphasis>View=»Find</emphasis> operation. Click on the "Find" button. Notice that an "* in *" tab is created below. This tab should show pretty much everything. In the "In Diagram" editor change the "*" to "B*" and click on the "Find Button" observing the contents of the new tab with "* in B*" as a tab label. You should see the three classes, the link (such as an association), and the association class. In the Element Type drop down box select "Interface" and click on the Find button. The new tab "* in B* Inte…" should have no entries in it as we have defined no interfaces. In the Element Type drop down box select "Class" and click on the Find button. The new tab "* in B* Class" should have one fewer entries in it than the "* in B*" tab. Switch back and forth between these two observing the difference. In various of these tabs select an item and click on the "Go To Selection" button observing the change in the selection shown in the diagram and in the Explorer Pane. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>View=»Zoom.</emphasis> As an exeption to a general rule the toolbar equivalent of <emphasis>View=»Zoom</emphasis> does not operate in the same way as the correspinding menu item. Highlight <emphasis>View=»Zoom.</emphasis> and a submenu will appear that contains "Zoom Out", "Zoom Reset" and "Zoom In". Click on these a few times observing the effect on the diagram then click on the Zoom tool bar icon. This is a magnifying glass next to a down arrow head. You should see a graduated slider bar tool. Grab the pointer in this tool and move it up and down observing the effect on the diagram. </para>
						</listitem>
						<listitem>
							<para>
								<emphasis>View=»Adjust Grid.</emphasis>
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>View=»Adjust Grid Snap.</emphasis>
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>View=»Page Breaks.</emphasis>
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>View=»XML Dump.</emphasis>
							</para>
						</listitem>
					</orderedlist>

					<para><emphasis>Create Diagram</emphasis> menu. This <indexterm>
							<primary>Create Diagram Menu</primary>
						</indexterm> allows you to create any one of the seven UML diagram types (class, use case, state, activity, collaboration, deployment and sequence) supported by ArgoUML.</para>
					<para>State and activity diagrams can only be created when a class or actor is selected, even though the relevant menu entries are <emphasis>not</emphasis> grayed out if this has not been done (nothing will happen under this circumstance).</para>
					<para><emphasis>Arrange</emphasis> menu. This allows <indexterm>
							<primary>Arrange Menu</primary>
						</indexterm> you to align, distribute and reorder model elements on a diagram and set the layout strategy for the diagram.</para>
					<para><emphasis>Generation</emphasis> menu. This allows <indexterm>
							<primary>Generation Menu</primary>
						</indexterm> you to generate Java code for selected classes or all classes.</para>
					<para><emphasis>Critique</emphasis> menu. This allows <indexterm>
							<primary>Critique Menu</primary>
						</indexterm> you to toggle the auto-critique on and off, set the level of importance of design issues and design goals and browse the critics available.</para>
					<para><emphasis>Tools</emphasis> menu. This menu is <indexterm>
							<primary>Tools Menu</primary>
						</indexterm> permanently grayed out unless there is some tool available in your version of ArgoUML.</para>
					<para><emphasis>Help</emphasis> menu. <indexterm>
							<primary>Help Menu</primary>
						</indexterm> This menu gives access to details of those who authored the system, and where additional help may be found.</para>
					<para>File Toolbar. <indexterm>
							<primary>File Toolbar</primary>
						</indexterm> This toolbar contains some of the tools from the File menu.</para>
					<para>Edit Toolbar. <indexterm>
							<primary>Edit Toolbar</primary>
						</indexterm> This toolbar contains some of the tools from the Edit menu.</para>
					<para>View Toolbar. <indexterm>
							<primary>View Toolbar</primary>
						</indexterm> This toolbar contains some of the tools from the View menu.</para>
					<para>Create Diagram Toolbar. <indexterm>
							<primary>Create Diagram Toolbar</primary>
						</indexterm> This toolbar contains some of the tools from the Create Diagram menu. </para>
				</section>

				<section>
					<title>The Explorer Pane</title>

					<para>At this time you should take the time to read <xref
							xlink:href="ch.ref.navpane"
						 />. The Explorer Pane is fundamental to almost everything that you do and we will be coming back to it again and again in what follows. In fact you will recall we have had to use it already. </para>
					<para>There is an expand or contract control in front of the package symbol for <quote>untitledModel</quote> in the Explorer Pane and the package symbol for <quote>Medium</quote> in the To-Do Pane. Click on these controls and observe that these panes are tree widgets that behave pretty much as you would expect them to. The expand or contract control is either plus (+)/minus (-) sign or knob with a right or bottom pointer depending upon the look and feel that you have chosen for an appearance. </para>
					<para>Select alternately Class Diagram 1 and Use Case Diagram 1 observing that the detail pane changes to track to the selected item in the Explorer. The detail pane is described in Chapter 12. It is not necessary to read Chapter 12 at this point, but it couldn&#039;t hurt. </para>
				</section>

				<section>
					<title>The Editing Pane</title>

					<para>At this point take some time to read <xref xlink:href="ch.ref.editpane"
						 />. </para>
					<para>As we go through the Editing pane changes will sometimes occur in the Details and the To-Do panes. Pay no attention to them for now. We will attend to them when we cover those panes. </para>
					<para>Select "Class Diagram 1" in the Explorers Pane. The name is unimportant, if you have changed it, just select the new name. If you have deleted it, first perform a Create=»New Class Diagram action. Click on the "New Package" button in the Edit Pane tool bar. Click somewhere in the edit pane. In the Explorer notice that a package appears named (unnamed Package). </para>
					<para>Double click on the "New Class" button in Edit Pane the tool bar. Click first within the package and once outside of it. Notice that within the Explorer, two classes appear in the tree both named (unnamed Class) one of them attached to the model node and the other attached to the (unnamed Package) node. </para>
					<para>Click the Select button in the Edit Pane tool bar so you can do things in the Edit Pane without adding new Classes. In the Explorer select the class that is not subordinate to the package. This selects the corresponding class in the diagram. Grab this class and move it into the package. Notice that in the Explorer this class is now also subordinate to the package node. </para>
					<para>In the diagram select the other class. Notice that in the Explorer, the selected node changes correspondingly. Grab this class and move it outside of the package and watch what happens in the Explorer. </para>
				</section>

				<section>
					<title>The Details Pane</title>

					<para>At this point take some time to read <xref xlink:href="ch.ref.detpane"
						 />. </para>

					<note>
						<itemizedlist>
							<listitem>
								<para>To-Do Item. Discuss differences with other tabs about locations of items selected. Hold particulars for discussion of To-Do Pane.</para>
							</listitem>
							<listitem>
								<para>Properties,</para>
							</listitem>
							<listitem>
								<para>Documentation,</para>
							</listitem>
							<listitem>
								<para>Presentation,</para>
							</listitem>
							<listitem>
								<para>Source,</para>
							</listitem>
							<listitem>
								<para>Constraints,</para>
							</listitem>
							<listitem>
								<para>Stereotype,</para>
							</listitem>
							<listitem>
								<para>Tagged Values,</para>
							</listitem>
							<listitem>
								<para>Checklist.</para>
							</listitem>
							<listitem>
								<para>Remove "images/tutorial/detailsoverview.gif" from file system. </para>
							</listitem>
						</itemizedlist>
					</note>
				</section>

				<section>
					<title>The To-Do Pane</title>

					<para>At this point take some time to read <xref xlink:href="ch.ref.todopane"
						 />. </para>

					<note>
						<itemizedlist>
							<listitem>
								<para>Describe priorities.</para>
							</listitem>
							<listitem>
								<para>Resolving items.</para>
							</listitem>
							<listitem>
								<para>Relation to ToDo Item tab in details pane. </para>
							</listitem>
							<listitem>
								<para>Remove "images/tutorial/todooverview.gif" from file system. </para>
							</listitem>
						</itemizedlist>
					</note>
				</section>

				<!-- sect3 xml:id="s3.tut.mouse"> <title>The Mouse</title> <para>The mouse and mouse buttons (or their equivalent with alternative tracking devices) are used in a wide variety of ways. In this section we look at the common modes of use.</para> <para>ArgoUML assumes a two button mouse. We will refer to the buttons as <quote>button 1</quote> and <quote>button 2</quote>. Button 1 is the leftmost button on a right-handed mouse, and sometimes referred to as the <quote>select</quote> button. Button 2 is sometimes referred to as the <quote>adjust</quote> button.</para> <orderedlist> <listitem> <para><emphasis>Button 1 click</emphasis>. This action is generally used to select an item for subsequent operations. If the item is a model element in the explorer or the editing pane it will be highlighted.</para> <para>In the case of the Edit Pane Toolbar, that model element is selected as the next to be added to the diagram (but only once&#8212;see double clicking for adding multiple model elements). The adding to the diagram is achieved by moving the mouse to the editing area and clicking again.</para> </listitem> <listitem> <para><emphasis>Button 1 double click</emphasis>. This action is identical to a single click <emphasis>except</emphasis>, when it is used with the edit pane toolbar. Under these circumstances the selected model element will be added multiple times to the drawing area, once for each further button click, until the tool is again selected or another tool chosen.</para> </listitem> <listitem> <para><emphasis>Button 2 click</emphasis>. When used over text items in the the explorer or details panes, or graphical model elements in the editing pane, this will display a context dependent drop-down menu.</para> <para>If the item has not yet been selected it will also be selected.</para> </listitem> <listitem> <para><emphasis>Button 1 motion</emphasis>. Where button 1 click has been used to pull down a menu from the menu bar, button 1 motion is used to select items on that menu.</para> <para>Button 1 motion also has an effect in the editing pane. Over graphical model elements it will move the model element to a new position. Graphical model elements that are selected show handles, and these can be used for re-sizing.</para> <para>Where the model element is some form of connector between other items, button 1 motion other than at a handle will cause a new handle to be created, allowing the connector to be articulated at that point. Such new handles can be removed by moving them to the end of the connector.</para> </listitem> <listitem> <para><emphasis>Button 2 motion</emphasis>. This is used to select items in a context sensitive menu popped up by use of button 2 click.</para> </listitem> </orderedlist> <para>There are other more specific behaviors that will be encountered under the specific cases where they are used.</para> </sect3-->

				<section>
					<title>Drawing Diagrams</title>

					<para>In general diagrams are drawn by using the edit pane toolbar to select the model element desired and clicking in the diagram at the position required.</para>
					<para>Model elements that are already in the model, but not on a diagram, may be added to a diagram by selecting the model element in the explorer, using <literal> Add to Diagram</literal> from the drop down menu (button 2) over that model element, and then clicking button 1 at the desired location on the diagram.</para>
					<para>As well as UML model elements, the Edit pane toolbar provides for general drawing objects (rectangles, circles, lines, polygons, curves, text) to provide supplementary information on diagrams.</para>

					<section>
						<title>Moving Diagram Elements</title>

						<para>There are several ways to move diagram elements.</para>

						<section>
							<title>Using the Mouse Keys</title>

							<para>Select the elements you want to move. By holding down the Ctrl key while selecting you can select several elements to move at the same time.</para>
							<para>Now hit your arrow keys. Your elements move a little with every key stroke.</para>
							<para>If you also hold down the Shift key, they move a bit faster.</para>
						</section>

						<section>
							<title>Using the Edit Pane Toolbar</title>
							<para>Click on the broom button on the toolbar. Move your mouse to the diagram pane, right click and hold. Now moving your mouse will align elements.</para>
						</section>
					</section>

					<section>
						<title>Arranging Elements</title>

						<para>The menu item <literal>Arrange</literal> allows you to align or group elements.</para>
					</section>
				</section>

				<section>
					<title>Working with Projects</title>

					<section>
						<title>The Start-Up Window</title>

						<para><xref xlink:href="fig.tut.startup"
							 /> shows the ArgoUML main window as it appears as right after start-up</para>
						<!--figure float="1" xml:id="fig.tut.startup"> <title>ArgoUML Window at Start-Up</title> <screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/startup.gif" format="GIF"/></imageobject></mediaobject></screenshot> </figure-->
						<para>The main window&#039;s client area, below the menu and toolbar, is subdivided into four panes. Starting at the leftmost top pane, and working around the clock, you can see the Explorer, showing a tree view of your UML model, the Editing Pane with its toolbar, two scroll bars and gray drawing area, the Details Pane with the ToDoItem tab selected, and the To-Do Pane with a tree view of the to do items, ranked in various ways selected via the drop down list at the top of the pane.</para>
						<para>Each time ArgoUML is started up without a project file as an argument, a new blank project is created. This project contains a model called <literal> untitledModel</literal>. This model contains a blank Class Diagram, called <literal>class diagram 1</literal>, and a blank Use Case Diagram called <literal> use case diagram 1</literal>.</para>
						<para>The model and both empty diagrams can be seen in the explorer, which is the main tool for you to navigate through your model.</para>
						<para>Let&#039;s assume for a moment that this is the point where you want to start modeling a new purchasing system. You want to give the name <quote>purchasingmodel</quote> to your model, and you want to store it in a file called <literal> FirstProject</literal>.</para>
					</section>

					<section>
						<title>Saving a Project - The File Menu</title>

						<para>For now ArgoUML; saves diagrams using an earlier proposed standard, <emphasis>Precision Graphics Markup Language (PGML)</emphasis>. However it has the option to export graphical data as SVG for those who can make use of it. When ArgoUML; supports UML 2.0, it will store diagrams using the UML 2.0 Diagram Interchange format. </para>
						<para>First, let&#039;s save the model in it&#039;s current (empty and unnamed) state. On the menu bar, click on <literal>File</literal>, then on <literal> Save Project As…</literal> as shown in <xref
								xlink:href="fig.tut.saveas" />.</para>

						<figure floatstyle="1" xml:id="fig.tut.saveas">
							<title>Invoking <literal>Save Project As…</literal></title>
							<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/saveas.gif" format="GIF" /></imageobject></mediaobject></screenshot>
						</figure>

						<para>Please notice that the File menu contains the usual options for creating a new project, for opening an existing project, for saving a project under a new name, for printing the currently displayed diagram, for saving the currently displayed diagram as a file, and for program Exit.</para>
						<para>Some of these menu commands can be invoked by pressing key combinations, as indicated on the drop-down menu. For instance, holding down the <quote>Ctrl</quote> key, and pressing <quote>N</quote>, will create a new project.</para>
						<para>In the current version, ArgoUML can only contain one active project at a time. In addition, a project can only contain one UML model. Since an UML model can contain an unlimited number of elements and diagrams, this should not present any serious limitations, even for modeling quite large and complex systems.</para>
					</section>

					<section>
						<title>The File Chooser Dialog</title>

						<para>But let&#039;s go back to saving our project. After clicking on the <literal>Save Project As…</literal> menu command, we get the file chooser dialog to enter the file name we wish to use as shown in <xref
								xlink:href="fig.tut.filechoose" />.</para>

						<figure floatstyle="1" xml:id="fig.tut.filechoose">
							<title>File Chooser Dialog</title>
							<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/filechoose.gif" format="GIF" /></imageobject></mediaobject></screenshot>
						</figure>

						<para>This is a standard Java FileChooser. Let&#039;s go over it in some detail.</para>
						<para>The main, outstanding feature, is the scrollable folders list in the center of the dialog. By using the scroll bar on the right, you can move up and down in the list of folders contained inside the currently selected folder. If it is scrollable or not depends on the amount of files and folders shown and also how they are shown. If everything fits the window is not scrollable as seen in the picture.</para>
						<para>Double-clicking on one of the displayed folders navigates you into that folder, allowing you to quickly navigate down into the folders hierarchy on your hard disk.</para>
						<para>Notice that only folder names, and no file names are displayed in the scrollable area. Indeed, the dialog is currently set up in order to show only ArgoUML project files with an extension of <literal>.zargo</literal>, as can be seen on the lower drop-down control labeled <literal>Files of Type:</literal>.</para>
						<para>Also notice that the currently selected folder&#039;s name is displayed in the upper drop-down control labeled <literal>Look in:</literal>. A single click on a folder inside the scrollable area does select that folder on screen but does not select the folder for saving.</para>
						<para>At the top of the dialog, above the scrollable folder chooser area, there are a few more folder navigation tools.</para>

						<itemizedlist>
							<listitem>
								<para><guiicon>
										<inlinemediaobject><imageobject><imagedata
											fileref="images/tutorial/guifolderdropdown.gif"
											format="GIF" /></imageobject></inlinemediaobject>
									</guiicon> The Folder drop-down control. Clicking on the down-arrow displays a tree view of the folder hierarchy, allowing you to navigate quickly up the hierarchy, and at the same time to quickly determine where in the hierarchy we are currently positioned.</para>
							</listitem>
							<listitem>
								<para><guiicon>
										<inlinemediaobject><imageobject><imagedata fileref="images/tutorial/guifolderupicon.gif"
											format="GIF" /></imageobject></inlinemediaobject>
									</guiicon> The Folder-Up icon. Clicking on this icon will bring us to the parent folder of the current folder.</para>
							</listitem>
							<listitem>
								<para><guiicon>
										<inlinemediaobject><imageobject><imagedata
											fileref="images/tutorial/guihomefoldericon.gif"
											format="GIF" /></imageobject></inlinemediaobject>
									</guiicon> The Home Folder icon. Clicking on this icon will bring us to our home directory.</para>
							</listitem>
							<listitem>
								<para><guiicon>
										<inlinemediaobject><imageobject><imagedata
											fileref="images/tutorial/guinewfoldericon.gif"
											format="GIF" /></imageobject></inlinemediaobject>
									</guiicon> The New Folder icon. Clicking on this icon will create a new folder called &quot;New Folder&quot; under the current folder. After the folder is created selecting it an clicking in the name allows us to select the name of our choice.</para>
							</listitem>
							<listitem>
								<para><guiicon>
										<inlinemediaobject><imageobject><imagedata
											fileref="images/tutorial/guifolderspresentationicon.gif"
											format="GIF" /></imageobject></inlinemediaobject>
									</guiicon> The Folders Presentation Icon.</para>
							</listitem>
						</itemizedlist>
						<para>OK, now we navigate to the directory where we want to save our ArgoUML project, fill in the <literal> File name:</literal> with an appropriate name, such as <quote>FirstProject</quote> and click on the <literal> Save</literal> button.</para>
						<para>You have now an active project called <literal> FirstProject</literal>, connected to the file <literal> FirstProject.zargo</literal>.</para>
					</section>
				</section>
			</section>

			<section>
				<title>Output</title>

				<section xml:id="s3.tut.loadsave">
					<title>Loading and Saving</title>

					<section>
						<title>Saving XMI files in ArgoUML</title>

						<indexterm>
							<primary>XMI</primary>
						</indexterm>

						<para>ArgoUML saves the diagram information in a PGML file (with extension <literal>.pgml</literal>, the model information in an XMI file (with extension <literal> .xmi</literal> and information about the project in a file with extension <literal>.argo</literal>. See <xref
								xlink:href="s4.tut.pgml" /> and <xref xlink:href="s3.tut.xmi"
							 /> for more about PGML and XMI respectively.</para>
						<para>All of these are then zipped to a file with extension <literal>.zargo</literal>. You can easily extract the <literal>.xmi</literal> file from the <literal>.zargo</literal> file using any old generic <application>ZIP</application> application. Give it a try and look into the magic of Argo.</para>

						<warning>
							<para>Be aware that double clicking will launch a <literal>ZIP utility</literal>, if one is installed, and NOT Argo.</para>
						</warning>
					</section>
				</section>

				<section>
					<title>Graphics and Printing</title>

					<section>
						<title>The Graph Editing Framework (GEF)</title>

						<para>GEF is the software package that is the foundation of the diagrams that appear in the Editing Pane. GEF was an integral part of ArgoUML but has been separated. Like ArgoUML it is an open source project available via <link
								xlink:href="http://www.tigris.org">Tigris</link>.</para>
					</section>

					<section xml:id="s4.tut.pgml">
						<title>Precision Graphics Markup Language (PGML)</title>

						<para>PGML is the current storage format for diagram information used in ArgoUML. In the future, PGML will be replaced by the UML 2.0 Diagram Interchange format.</para>
					</section>

					<section>
						<title>Applications Which Open PGML</title>

						<para>PGML is a predecessor of SVG (see <xref xlink:href="s4.tut.svg"
							 />. It was dropped by the W3C Consortium.</para>
						<para>Currently there are no other tools that we know of working on PGML.</para>
					</section>

					<section>
						<title>Printing Diagrams</title>

						<para>Select a diagram, then go to <literal>File</literal>=»<literal>Export Diagrams</literal>. You can generate GIF, PostScript, Encapsulated PostScript or SVG format.</para>
					</section>

					<section xml:id="s4.tut.svg">
						<title>Scalable Vector Graphics (SVG)</title>

						<para>A World Wide Web Consortium (W3C) standard vector graphics format (<link
								xlink:href="http://www.w3.org/TR/SVG/"
							> http://www.w3.org/TR/SVG/</link>).</para>
						<para>Support is built in to modern browsers, but you can also get a plugin for older browsers from <link
								xlink:href="http://www.adobe.com"> adobe.com</link>.</para>
					</section>

					<section>
						<title>Saving Diagrams as SVG</title>

						<orderedlist>
							<listitem>
								<para>Select <literal>.svg</literal> as the file type.</para>
							</listitem>
							<listitem>
								<para>Type the name of the file as you like with the <literal>.svg</literal> tag at the end. Example <literal>myumldiagram.svg</literal></para>
							</listitem>
						</orderedlist>

						<para><phrase xml:lang="fr"
							>Et voila!</phrase> SVG! Give it a try and zoom around a little… They are not pretty though, so if you know anything about rendering beautiful SVG let us know.</para>
						<para>Most modern browsers support SVG. If yours doesn&#039;t try <link
								xlink:href="http://www.mozilla.com/firefox/"
								> Firefox</link> or get a plugin for your current browser from <link
								xlink:href="http://www.adobe.com"> adobe.com</link></para>

						<note>
							<para>You will not have scroll bars for your SVG unless it is embedded in HTML. Good luck and let us know what you find!</para>
						</note>
					</section>
				</section>

				<section xml:id="s3.tut.xmi">
					<title>XMI</title>

					<indexterm>
						<primary>XMI</primary>
					</indexterm>

					<para>ArgoUML supports XMI 1.0, 1.1, and 1.2 files which contain UML 1.3 and UML 1.4 models. For best compatibility with ArgoUML, export your models using UML 1.4 and XMI 1.1 or 1.2. Be sure to turn off any proprietary extensions (such as Poseidon&#039;s diagram data).</para>
					<para>With UML versions earlier than UML 2.0, it isn't possible to save diagram information, so no diagrams will be transferred.</para>
					<para>There is also a tool that converts XMI to HTML. For more information, see <link
							xlink:href="http://www.objectsbydesign.com/projects/xmi_to_html_2.html"
							> http://www.objectsbydesign.com/projects/xmi_to_html_2.html</link>.</para>

					<section>
						<title>Using XMI from Rational Rose</title>

						<para>…</para>
					</section>

					<section>
						<title>Using Models Created by Poseidon</title>

						<indexterm>
							<primary>XMI</primary>
						</indexterm>
						<para>In the <literal>Export project to XMI</literal> dialog, but sure to clear the selection of <literal>Save with diagram data</literal>literal>.</para>
					</section>

					<section>
						<title>Using Models Created by MagicDraw</title>
						<para>…</para>
					</section>

					<section>
						<title>XMI Compatibility with other versions of ArgoUML</title>
						<para>Versions of ArgoUML prior to 0.19.7 supported UML 1.3/XMI 1.0. After this time, the save format is UML 1.4/XMI 1.2 which is not backward compatible. Newer versions of ArgoUML will read projects written by older versions, but not vice versa. If you might need to return to an older version of ArgoUML you should be careful to save a backup of your old projects.</para>
						<para>Additionally, if you write XMI files which need to be read by other tools, you should take into account the different versions. Most modern UML modelling tools should read UML 1.4, but you may have in-house code generators or other tools which are tied to UML 1.3. </para>
					</section>

					<section>
						<title>Importing Other XMI Formats into ArgoUML</title>
						<para>XMI compatibility between UML modeling tools has improved over the years, but you may still occasionally run into problems.</para>
						<para>ArgoUML will not read XMI files which contain UML 1.5 or UML 2.0 models, but it should be able to open most UML 1.4 and UML 1.3 files. If you find one that it can't open, please file a bug report so that a developer can investigate.</para>
					</section>

					<section>
						<title>Generating XMI Format</title>
						<para>Select the command <literal>File</literal>=»<literal>Export as XMI</literal> and choose a filename.</para>
					</section>
				</section>

				<section>
					<title>Code Generation</title>

					<section>
						<title>Code Generated by ArgoUML</title>
						<para>It is possible to compile your generated code with ArgoUML, you still need to implement method bodies, though, to get usable results.</para>
					</section>

					<section>
						<title>Generating Code for Methods</title>
						<para>At the moment you cannot write code for methods (operations) within ArgoUML. The source pane is editable, but the changes are ignored. ArgoUML is a pure design tool for now, no IDE functionality but the desire is there. You might consider using Forte and ArgoUML together&#8212;it&#039;s a good work around!</para>
						<para>You can help us out there if you&#039;d like!</para>
					</section>
				</section>
			</section>

			<section>
				<title>Working With Design Critics</title>

				<para>Design critics are part of the practical application of the theories of Cognitive Psychology that are implemented in ArgoUML. See <xref
						xlink:href="tut.cog.psych" />
				</para>

				<section>
					<title>Messages From the Design Critics</title>

					<para>Where do we stand now? A new project has been created, and is stored in the file <literal> FirstProject.zargo</literal>. <xref
							xlink:href="fig.tut.critstart"
						 /> shows how your ArgoUML window should look at this stage.</para>

					<figure floatstyle="1" xml:id="fig.tut.critstart">
						<title> ArgoUML Window Having Saved <literal>FirstProject.zargo</literal>
						</title>
						<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/critstart.gif" format="GIF" /></imageobject></mediaobject></screenshot>
					</figure>

					<para>The project contains a top-level package, called <literal>untitledModel</literal>, which contains a class diagram and a use case diagram.</para>
					<para>If we look carefully at the screen, we can see that the &quot;Medium&quot; folder in the To-Do Pane (the lower left pane) must contain some items, since its activation icon <guiicon>
							<inlinemediaobject><imageobject><imagedata fileref="images/tutorial/guitreefoldercloseicon.gif"
								format="GIF" /></imageobject></inlinemediaobject>
						</guiicon> is displayed.</para>
					<para>Clicking on this icon will open the &quot;Medium&quot; folder. An open folder is indicated by the <guiicon>
							<inlinemediaobject><imageobject><imagedata fileref="images/tutorial/guitreefolderopenicon.gif"
								format="GIF" /></imageobject></inlinemediaobject>
						</guiicon> icon.</para>
					<para>But what is this <quote>To-Do</quote> Pane anyway. You haven&#039;t recorded anything yet that has to be done, so where do these to do items originate.</para>
					<para>The answer is simple, and is at the same time one of the strong points of ArgoUML. While you are working on your UML model, your work is monitored continuously and invisibly by a piece of code called a <emphasis>design critic</emphasis>. This is like a personal mentor that watches over your shoulder and notifies you each time he sees something questionable in your design.</para>
					<para>Critics are quite unobtrusive. They give you a friendly warning, but they do not force you into design principles that you don&#039;t want or like to follow. Let us take a look at what the critics are telling us. Click on the <guiicon>
							<inlinemediaobject><imageobject><imagedata fileref="images/tutorial/guitreefoldercloseicon.gif"
								format="GIF" /></imageobject></inlinemediaobject>
						</guiicon> icon next to the <literal> Medium</literal> folder, and click on the <literal> Revise Package Name UntitledModel</literal> item.</para>
					<para><xref xlink:href="fig.tut.critrevname"
						 /> shows how your screen should now look.</para>

					<figure floatstyle="1" xml:id="fig.tut.critrevname">
						<title>ArgoUML Window Showing the Critic Item <literal> Revise Package Name UntitledModel</literal></title>
						<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/critrevname.gif" format="GIF" /></imageobject></mediaobject></screenshot>
					</figure>

					<para>Notice that your selection is highlighted in red in the To-Do Pane, and that a full explanation appears now in the Details Pane (the lower right pane). You may have to re-size your Details Pane or to scroll down in order to see the full message as displayed in our example.</para>
					<para>What ArgoUML is trying to tell you is that usually, package names are written in lower cases. The default top level package created by ArgoUML is called <literal> untitledModel</literal> and therefore violates a sound design principle. (Actually, this could be considered as a bug within ArgoUML, but it comes in handy to demonstrate the working of critics).</para>
					<para>At this point, you can choose to change the package name manually or to impose silence on the design critic for some time or permanently</para>
					<para>We will do nothing of this (we&#039;ll come back to it when we talk about the design critics in more detail) but we&#039;ll use another handy feature of ArgoUML&#8212;an auto-correct feature.</para>
					<para>In order to do that, just click on the <literal> Next</literal> button on the Details Pane. This will cause a renaming wizard to be displayed inside the properties panel, proposing to use the name <literal> untitledmodel</literal> (all in lower case).</para>
				</section>

				<section>
					<title>Design Critics at Work: The Rename Package Wizard</title>

					<para>Replace the name <literal>untitledmodel</literal> with <literal>purchasingmodel</literal>, and click on the <literal>Finish</literal> button. <xref
							xlink:href="fig.tut.critwiz"
						 /> shows how the ArgoUML window will now look.</para>

					<figure floatstyle="1" xml:id="fig.tut.critwiz">
						<title>ArgoUML Window Showing the Critic Wizard to Rename the Package</title>
						<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/critwiz.gif" format="GIF" /></imageobject></mediaobject></screenshot>
					</figure>

					<para>Watch now how the design critic note in the To Do panel disappears, leaving only the <literal> Add Elements to Package purchasingmodel</literal> note in the To-Do list.</para>
					<para>If this doesn&#039;t happen at once, wait for a few seconds. ArgoUML makes heavy use of several threads of execution that execute in parallel. This can cause delays of a few seconds before the information gets updated on the screen.</para>
					<para>The package name change should also be reflected in the explorer, in the top left corner of your ArgoUML window.</para>
					<para>We are now ready to create our first UML diagram, a Use Case diagram, but first let&#039;s save what we&#039;ve done so far.</para>
					<para>Click on the <literal>File</literal> menu item, and select <literal>Save Project</literal>. You can now safely exit ArgoUML without losing your work so far, or go on creating your first diagram.</para>
				</section>
			</section>
		</section>

		<section>
			<title>The Case Study (To be written)</title>

			<para>Here is where we are going to start the Case Study. It is at this point that you define your project; not your product, but your project. It can be argued that modeling concepts should apply here as well but this has not been well established. If you can take the time to look into the ArgoUML project, you will find that there are a large number of "lines of code" and lines of documentation that are part of the project, but not part of the product. For example, this document is part of the product while the Cookbook and the build.xml files are part of the project only. At a minimum the file structure of the project could be shown in a package diagram. </para>
			<para>… </para>
		</section>
	</chapter>

	
	<chapter xml:id="ch.tut.reqs">
		<title>Requirements Capture</title>

		<section>
			<title>Introduction</title>

			<indexterm>
				<primary>Requirement</primary>
				<secondary>Capturing</secondary>
			</indexterm>

			<para>Requirements capture is the process of identifying what the <quote>customer</quote> wants from the proposed system.</para>
			<para>The key at this stage is that we are in the problem domain. At this stage we must describe everything from the <quote>customer</quote> perspective and in the language of the <quote>customer</quote>.</para>
			<para>The biggest risk we have in requirements capture is to start thinking in terms of possible solutions. That must wait until the <emphasis>Analysis Phase</emphasis> (see <xref
					xlink:href="ch.tut.analysis"
				 />). One of the steps of the Analysis Phase will be to take the output of the Requirements Phase and recast it in the language of a deemed solution.</para>
			<para>Remember we are using both a <emphasis>incremental</emphasis>, and an <emphasis>iterative</emphasis> process.</para>
			<para>We may well come back to the requirements process again as we break down the problem into smaller chunks, each of which must have its requirements captured.</para>
			<para>We will certainly come back through the requirements phase on each iteration as we seek to define the requirements of more and more of the system</para>
			<note>
				<para>The only part of the requirements notation specified by the UML standard is the use case diagram. The remainder is process specific. The process described in this chapter draws heavily on the Rational Unified Process.</para>
			</note>
		</section>

		<section>
			<title>The Requirements Capture Process</title>

			<indexterm>
				<primary>Vision Document</primary>
			</indexterm>

			<para>We start with a top-level view of the problem we are solving and the key areas of functionality that we must address in any solution. This is our <emphasis>vision document</emphasis>, and should be just a few pages long.</para>
			<para>For example the top-level view of an automated teller machine (ATM) might be that it should support the following.</para>

			<orderedlist>
				<listitem>
					<para>Cash deposit, cash withdrawal and account inquiries by customers.</para>
				</listitem>
				<listitem>
					<para>Maintenance of the equipment by the bank&#039;s engineers, and unloading of deposits and loading of cash by the local bank branch.</para>
				</listitem>
				<listitem>
					<para>Audit trail for all activities sent to the bank&#039;s central computer.</para>
				</listitem>
			</orderedlist>

			<indexterm>
				<primary>Actor</primary>
			</indexterm>

			<para>From this top-level view we can extract the principal activities of the system, and the external agents (people, equipment) that are involved in those activities. These activities are known as <emphasis>use cases</emphasis> and the external agents are known as <emphasis>actors</emphasis>.</para>
			<para>Actors may be people or machines. From a practical standpoint it is worth knowing the stakeholder behind any machine, since only they will be able to engage with the requirements capture process.</para>

			<indexterm>
				<primary>Use Case</primary>
			</indexterm>

			<para>Use cases should be significant activities for the system. For example customer use of the ATM machine is a use case. Entering a PIN number is not.</para>
			<para>There is a gray area between these two extremes. As we shall see it is often useful to break very large use cases into smaller sub-use cases. For example we may have sub-use cases covering cash deposit, cash withdrawal and account inquiry.</para>
			<para>There is no hard and fast rule. Some architects will prefer a small number of relatively large use cases, others will prefer a larger number of smaller use cases. A useful rule of thumb is that any practical project ought to require no more than about 30 use cases (if it needs more, it should be broken into separate projects).</para>
			<para>We then show the relationship between use cases and actors on one or more use case diagrams. For a large project more than one diagram will be needed. Usually groups of related use cases are shown on one diagram.</para>
			<para>We must then give a more detailed specification of each use case. This covers its normal behavior, alternative behaviors and any pre- and post-conditions. This is captured in a document variously known as a <emphasis>use case specification</emphasis> or <emphasis>use case scenario</emphasis>.</para>

			<indexterm>
				<primary>Supplementary Requirement Specification</primary>
			</indexterm>

			<para>Finally, since use cases are functional in nature, we need a document to capture the non-functional requirements (capacity, performance, environmental needs etc). These requirements are captured in a document known as a <emphasis>supplementary requirements specification</emphasis>.</para>

			<section>
				<title>Process Steps</title>

				<para>The steps in the requirements capture process can be summarized as follows.</para>

				<orderedlist>
					<listitem>
						<indexterm>
							<primary>Vision Document</primary>
						</indexterm>
						<para>Capture an overall view of the problem, and the desired characteristics of its solution in the <emphasis>vision document</emphasis>.</para>
					</listitem>
					<listitem>
						<indexterm>
							<primary>Use Case</primary>
						</indexterm>
						<para>Identify the <emphasis>use case</emphasis> and <emphasis>actors</emphasis> from the vision document and show their relationships on one or more <emphasis>use case diagrams</emphasis>.</para>
					</listitem>
					<listitem>
						<indexterm>
							<primary>Use Case Specification</primary>
						</indexterm>
						<indexterm>
							<primary>Specification</primary>
							<secondary>of Use Case</secondary>
						</indexterm>
						<para>Give detailed <emphasis>use case specifications</emphasis> for each use case, covering normal and alternate behavior, pre- and post-conditions.</para>
					</listitem>
					<listitem>
						<indexterm>
							<primary>Non-functional requirements</primary>
						</indexterm>
						<indexterm>
							<primary>Supplementary Requirement Specification</primary>
						</indexterm>
						<para>Capture all non-functional requirements in a <emphasis>supplementary requirements specification</emphasis>.</para>
					</listitem>
				</orderedlist>
				<para>In any iterative development process, we will prioritize, and early iterations will focus on capturing the key behavior of the most important use cases.</para>
				<para>Most modern requirements capture processes agree that it is essential that the authoritative representative of the customer is fully involved throughout the process.</para>
			</section>
		</section>

		<section xml:id="s1.tut.req_process_output">
			<title>Output of the Requirements Capture Process</title>

			<para>Almost all the output of the requirements capture process is documentary. The only diagram is the use case diagram, showing the relationships between use cases and actors.</para>

			<section xml:id="s2.tut.vision_document">
				<title>Vision Document</title>

				<indexterm>
					<primary>Vision Document</primary>
				</indexterm>

				<para>Typical sections of this document would be as follows.</para>

				<itemizedlist>
					<listitem>
						<para><emphasis>Summary</emphasis>. A statement of the context, problem and solution goals.</para>
					</listitem>
					<listitem>
						<indexterm>
							<primary>Goals</primary>
							<secondary>in the Vision document</secondary>
						</indexterm>
						<para><emphasis>Goals</emphasis>. What are we trying to achieve (and how do we wish to achieve it).</para>
					</listitem>
					<listitem>
						<indexterm>
							<primary>Market Context</primary>
							<secondary>in the Vision document</secondary>
						</indexterm>
						<para><emphasis>Market Context</emphasis> or <emphasis>Contractual Arrangements</emphasis>. For a market led development, this should indicate target markets, competitive differentiators, compelling events and so forth. For a contractual development this should explain the key contractual drivers.</para>
					</listitem>
					<listitem>
						<indexterm>
							<primary>Stakeholders</primary>
							<secondary>in the Vision document</secondary>
						</indexterm>
						<para><emphasis>Stakeholders</emphasis>. The users (in the widest sense) of the system. Many of these will map in to actors, or control equipment that maps into actors.</para>
					</listitem>
					<listitem>
						<indexterm>
							<primary>Key features</primary>
							<secondary>in the Vision document</secondary>
						</indexterm>
						<para><emphasis>Key Features</emphasis>. At the very highest level what are they key functional aspects of the problem/desired solution. These will largely map down to the use cases. It is helpful to give some prioritization here.</para>
					</listitem>
					<listitem>
						<indexterm>
							<primary>Constraints</primary>
							<secondary>in the Vision document</secondary>
						</indexterm>
						<indexterm>
							<primary>Non-functional parameters</primary>
							<secondary>in the Vision document</secondary>
						</indexterm>
						<para><emphasis>Constraints</emphasis>. A high level view of the non-functional parameters of the system. These will be worked out in detail in the supplementary requirements specification.</para>
					</listitem>
					<listitem>
						<para><emphasis>Appendix</emphasis>. A listing of the actors and use cases that will be needed to meet this vision. It is useful to link to these from the earlier sections to ensure comprehensive coverage.</para>
					</listitem>
				</itemizedlist>
			</section>

			<section>
				<title>Use Case Diagram</title>

				<indexterm>
					<primary>Use Case Diagram</primary>
				</indexterm>
				<indexterm>
					<primary>Diagram</primary>
					<secondary>Use Case</secondary>
				</indexterm>

				<para>The vision document has identified the use cases and actors. The use case diagram captures how they interact. In our ATM example we have identified <quote>customer uses machine</quote>, <quote>maintain machine</quote> and <quote>audit</quote> as the three main use cases. We have identified <quote>customer</quote>, maintenance engineer<quote>,</quote><quote>local branch official</quote> and <quote>central computer</quote> as the actors.</para>
				<para><xref xlink:href="fig.tut.atm_use_case_diagram_basic"
						 /> shows how this could be displayed on a use case diagram. The use cases are shown as ovals, the actors as stick people (even where they are machines), with lines (known as <emphasis>associations</emphasis> connecting use cases to the actors who are involved with them. A box around the use cases emphasizes the boundary between the system (defined by the use cases) and the actors who are external.</para>

				<note>
					<para>Not all analysts like to use a box around the use cases. It is a matter of personal choice.</para>
				</note>

				<figure floatstyle="1" xml:id="fig.tut.atm_use_case_diagram_basic">
					<title>Basic use case diagram for an ATM system</title>
					<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/atm_use_case_diagram_basic.gif" format="GIF" /></imageobject></mediaobject></screenshot>
				</figure>

				<para>The following sections show how the basic use case diagram can be extended to show additional information about the system being designed.</para>

				<section>
					<title>Active and Passive Actors</title>

					<indexterm>
						<primary>Active Actor</primary>
					</indexterm>

					<para><emphasis>Active</emphasis> actors initiate interaction with the system. This can be shown by placing an arrow on the association from the actor pointing toward the use case. In the ATM example, the customer is an active actor.</para>

					<indexterm>
						<primary>Passive Actor</primary>
					</indexterm>

					<para>Interaction with <emphasis>passive</emphasis> actors is initiated by the system. This can be shown by placing an arrow on the association from the use case pointing toward the actor. In the ATM example, the central computer is a passive actor.</para>
					<para>This is a good example where the arrow helps, since it allows us to distinguish an event driven system (the ATM initiates interaction with the central computer) from a polling system (the central computer interrogates the ATM from time to time).</para>
					<para>Where an actor may be either active or passive, depending on circumstances, the arrow may be omitted. In the ATM example the bank engineer fits into this category. Normally he is active, turning up on a regular cycle to service the machine. However if the ATM detects a fault, it may summon the engineer to fix it.</para>
					<para>The use of arrows on associations is referred to as the <emphasis>navigation</emphasis> of the association. We shall see this used elsewhere in UML later on. The choice, by the OMG, of zero vice two arrowheads to show a bidirectional association is unfortunate. Under this convention you cannot distinguish between an association whose navigation has yet to be determined and one that is bidirectional. </para>
					<para>
						<xref xlink:href="fig.tut.atm_use_case_diagram_navigation"
						 /> shows the ATM use case diagram with navigation displayed.</para>

					<figure floatstyle="1" xml:id="fig.tut.atm_use_case_diagram_navigation">
						<title>Use case diagram for an ATM system showing navigation.</title>
						<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/atm_use_case_diagram_navigation.gif" format="GIF" /></imageobject></mediaobject></screenshot>
					</figure>
				</section>

				<section>
					<title>Multiplicity</title>

					<indexterm>
						<primary>Multiplicity</primary>
						<secondary>in a Use Case Diagram</secondary>
					</indexterm>

					<para>It can be useful to show the <emphasis>multiplicity</emphasis> of associations between actors and use cases. By this we mean how many instances of an actor interact with how many instances of the use case.</para>
					<para>By default we assume one instance of an actor interacts with one instance of a use case. In other cases we can label the multiplicity of one end of the association, either with a number to indicate how many instances are involved, or with a range separated by two periods (<literal>..</literal>). An asterisk ( <literal>*</literal>) is used to indicate an arbitrary number.</para>
					<para>In the ATM example, there is only one central computer, but it may be auditing any number of ATM uses. So we place the label <literal>0..*</literal> at the use case end. There is no need for a label at the other end, since the default is one.</para>
					<para>A local bank will have up to three officials authorized to unload and load ATM machines. So at the actor end of the relationship with the use case <literal>Maintain ATM</literal>, we place the label <literal>1..3</literal>. They may be dealing with any number of ATM machines, so at the other end we place the label <literal> 0..*</literal>.</para>
					<para>There may be any number of customers and there may be any number of ATM systems they could use. So at each end of the association we place the label <literal> 0..*</literal>.</para>
					<para>
						<xref xlink:href="fig.tut.atm_use_case_diagram_multiplicity"
						 /> shows the ATM use case diagram with multiplicity displayed.</para>

					<figure floatstyle="1" xml:id="fig.tut.atm_use_case_diagram_multiplicity">
						<title>Use case diagram for an ATM system showing multiplicity.</title>
						<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/atm_use_case_diagram_multiplicity.gif" format="GIF" /></imageobject></mediaobject></screenshot>
					</figure>

					<para>Multiplicity can clutter a diagram, and is often not shown, except where it is critical to understanding. In the ATM example we would only choose to show <literal> 1..3</literal> against the local bank official, since all others are obvious from the context.</para>
				</section>
				<section>
					<title>Hierarchies of Use Cases</title>

					<indexterm>
						<primary>Hierarchy of Use Cases</primary>
					</indexterm>
					<indexterm>
						<primary>Use Case</primary>
						<secondary>Hierarchy</secondary>
					</indexterm>

					<para>In our ATM example so far we have just three use cases to describe all the behavior of the system. While use cases should always describe a significant chunk of system behavior, if they are too general they can be difficult to describe.</para>
					<para>We could for example define the behavior of the use case <quote>Use ATM</quote> in terms of the behavior of three simpler use cases, <quote>Deposit Cash</quote>, <quote>Withdraw Cash</quote> and <quote>Query Account</quote>. The main use case could be specified by <emphasis>including</emphasis> the behavior of the subsidiary use cases where needed.</para>
					<para>Similarly the <quote>Maintain ATM</quote> use case could be defined in terms of two use cases <quote>Maintain Equipment</quote> and <quote>Reload ATM</quote>. In this case the two actors involved in the main use case are really only involved in one or other of the two subsidiary use cases and this can be shown on the diagram.</para>

					<indexterm>
						<primary>Include Relationship</primary>
					</indexterm>
					<indexterm>
						<primary>Relationship</primary>
						<secondary>Include</secondary>
					</indexterm>

					<para>The decomposition of a use case into simpler sub-use cases is shown in UML by using an <emphasis>include relationship</emphasis>, a dotted arrow from the main use case to the subsidiary, with the label <emphasis>«include»</emphasis>.</para>

					<figure floatstyle="1" xml:id="fig.tut.atm_use_case_diagram_include">
						<title>Use case diagram for an ATM system showing include relationships.</title>
						<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/atm_use_case_diagram_include.gif" format="GIF" /></imageobject></mediaobject></screenshot>
					</figure>

					<para>Include relationships are fine for breaking down the use case behaviors in to hierarchies. However we may also want to show a use case that is an <emphasis>extension</emphasis> to an existing use case to cater for a particular circumstance.</para>
					<para>In the ATM example we have a use case covering routine maintenance of the ATM, <quote>Maintain Equipment</quote>. We also want to cover the special case of an unscheduled repair caused by the ATM detecting an internal fault.</para>

					<indexterm>
						<primary>Extend Relationship</primary>
					</indexterm>
					<indexterm>
						<primary>Relationship</primary>
						<secondary>Extend</secondary>
					</indexterm>

					<para>This is shown in UML by the <emphasis>extend</emphasis> relationship. In the main use case, we specify a name for a location in the description, where an extension to the behavior could be attached. The name and location are shown in a separate compartment within the use case oval. The representation extend relationship is the same as the include relationship, but with the label <emphasis>«extend»</emphasis>. Alongside the extend relationship, we specify the condition under which that behavior will be attached.</para>
					<para><xref xlink:href="fig.tut.atm_use_case_diagram_extend"
						 /> shows the ATM use case diagram with an extend relationship to a use case for unscheduled repairs. The diagram is now getting rather complex, and so we have split it into two, one for the maintenance side of things, the other for customer usage and audit.</para>
					<para>The <quote>Maintain Equipment</quote> use case defines a name <quote>Unsched</quote>, at the start of its description. The extending use case <quote>Unscheduled Repair</quote> is attached there when the ATM detects an internal error.</para>

					<figure floatstyle="1" xml:id="fig.tut.atm_use_case_diagram_extend">
						<title>Use case diagram for an ATM system showing an extend relationship.</title>
						<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/atm_use_case_diagram_extend.gif" format="GIF" /></imageobject></mediaobject></screenshot>
					</figure>

					<indexterm>
						<primary>Use Case Generalization</primary>
					</indexterm>
					<indexterm>
						<primary>Use Case Specialization</primary>
					</indexterm>
					<indexterm>
						<primary>Generalize a Use Case</primary>
					</indexterm>
					<indexterm>
						<primary>Specializations</primary>
						<secondary>of Use Case</secondary>
					</indexterm>

					<para>Use cases may be linked together in one other way. One use case may be a <emphasis>generalization</emphasis> of a subsidiary use case (or alternatively the subsidiary is a <emphasis>specialization</emphasis> of the main use case). This is very like the extends relationship, but without the constraint of specific extension points at which the main use case may be extended, and with no condition on when the subsidiary use case may be used.</para>
					<para>Generalization is shown on a use case diagram by an arrow with solid line and solid white head from the subsidiary to the main use case. This may be useful when a subsidiary use case specializes the behavior of the main use case at a large number of positions and under a wide range of circumstances. However the lack of any restriction makes generalization very hard to specify precisely. In general use an extend relationship instead. </para>
				</section>
			</section>

			<section>
				<title>The Use Case Specification</title>

				<indexterm>
					<primary>Use Case Specification</primary>
				</indexterm>
				<indexterm>
					<primary>Specification</primary>
					<secondary>of Use Case</secondary>
				</indexterm>
				<indexterm>
					<primary>Use Case Scenario</primary>
				</indexterm>

				<para>Each use case must be documented to explain in detail the behavior it is specifying. ArgoUML assists in this area through the generation of graphic files for inclusion in this documentation. This document is known by different names in different processes: <emphasis>use case specification</emphasis>, <emphasis>use case scenario</emphasis> or even (confusingly) just <emphasis>use case</emphasis>. </para>
				<para>A typical use case specification will include the following sections.</para>

				<itemizedlist>
					<listitem>
						<indexterm>
							<primary>Name</primary>
							<secondary>of Use Case</secondary>
						</indexterm>
						<indexterm>
							<primary>Use Case Name</primary>
						</indexterm>
						<para><emphasis>Name</emphasis>. The name of the use case to which this relates.</para>
					</listitem>
					<listitem>
						<indexterm>
							<primary>Goal</primary>
							<secondary>of Use Case</secondary>
						</indexterm>
						<indexterm>
							<primary>Use Case Goal</primary>
						</indexterm>
						<para><emphasis>Goal</emphasis>. A one or two line summary of what this use case achieves <emphasis>for its actors</emphasis>.</para>
					</listitem>
					<listitem>
						<para><emphasis>Actors</emphasis>. The actors involved in this use case, and any context regarding their involvement.</para>
						<note>
							<para>This should not be a description of the actor. That should be associated with the actor on the use case diagram.</para>
						</note>
					</listitem>
					<listitem>
						<indexterm>
							<primary>Pre-condition</primary>
							<secondary>of Use Case</secondary>
						</indexterm>
						<indexterm>
							<primary>Pre-assumptions</primary>
							<secondary>of Use Case</secondary>
						</indexterm>
						<indexterm>
							<primary>Use Case Pre-condition</primary>
						</indexterm>
						<para><emphasis>Pre-condition</emphasis>. These would be better named <quote>pre-assumptions</quote>, but the term used everywhere is pre-conditions. This is a statement of any simplifying assumptions we can make at the start of the use case.</para>
						<para>In the ATM example we might make the assumption for the<quote>Maintain Equipment</quote> use case that an engineer is always available, and we do not need to worry about the case where a routine maintenance visit is missed.</para>
						<caution>
							<para>Avoid pre-conditions wherever possible. You need to be absolutely certain that the pre-condition holds under all possible circumstances. If not your system will be under specified and hence will fail when the pre-condition is not true. Alternatively, when you cannot be certain the pre-condition is always true, you will need to specify a second use case to handle the pre-condition being false. In the first case, pre-conditions are a source of problems, in the second a source of more work.</para>
						</caution>
					</listitem>
					<listitem>
						<indexterm>
							<primary>Basic Flow</primary>
							<secondary>of Use Case</secondary>
						</indexterm>
						<indexterm>
							<primary>Use Case</primary>
							<secondary>Basic Flow</secondary>
						</indexterm>
						<indexterm>
							<primary>Scenario</primary>
						</indexterm>
						<para><emphasis>Basic Flow</emphasis>. The linear sequence of steps that describe the behavior of the use case in the <quote>normal</quote> scenario. Where a use case has a number of scenarios that could be normal, one is arbitrarily selected. Specifying the basic flow is described in more detail in <xref
								xlink:href="s3.tut.basic_flow" /> below.</para>
					</listitem>
					<listitem>
						<indexterm>
							<primary>Alternate Flows</primary>
							<secondary>of Use Case</secondary>
						</indexterm>
						<indexterm>
							<primary>Use Case</primary>
							<secondary>Alternate Flows</secondary>
						</indexterm>
						<para><emphasis>Alternate Flows</emphasis>. A series of linear sequences describing each of the alternative behaviors to the basic flow. Specifying alternate flows is described in more detail in <xref
								xlink:href="s3.tut.alternate_flows" />.</para>
					</listitem>
					<listitem>
						<indexterm>
							<primary>Post-conditions</primary>
							<secondary>of Use Case</secondary>
						</indexterm>
						<indexterm>
							<primary>Post-assumptions</primary>
							<secondary>of Use Case</secondary>
						</indexterm>
						<indexterm>
							<primary>Use Case Post-conditions</primary>
						</indexterm>
						<para><emphasis>Post-conditions</emphasis>. These would be better named <quote>post-assumptions</quote>. This is a statement of any assumptions that we can make at the end of the use case. Most useful where the use case is one of a series of subsidiary use cases that are included in a main use case, where they can form the pre-conditions of the next use case to be included.</para>
						<caution>
							<para>Like pre-conditions, post-conditions are best avoided. They place a burden on the specification of the use case flows, to ensure that the post-condition always holds. They therefore are also a source of problems and extra work.</para>
						</caution>
					</listitem>
					<listitem>
						<para><emphasis>Requirements</emphasis>. In an ideal world the vision document, use case diagrams, use case specifications and supplementary requirements specification would form the requirements for a project.</para>
						<para>For most market-led developments, where ownership of requirements is within the same business as the team who will do the development, this is now usually the case. The marketing department can learn use case based requirements capture and analysis to link to their customer facing activities.</para>
						<para>However for external contract developments, customers may insist on a traditional <quote>list of features</quote> as the basis of the contract. Where this is the case, this section of the use case specification should link to the contract features that are covered by the use case.</para>
						<para>This is often done through a third party tool that can link documents, providing automated checking of coverage, in which case this section is not needed, or may be generated automatically.</para>
					</listitem>
				</itemizedlist>

				<para>The final size of the use case specification will depend on the complexity of the use case. As a rule of thumb, most use cases take around 10-15 pages to specify, the bulk of which is alternate flows. If you are much larger than this, consider breaking the use case down. If you are much smaller consider whether the use case is addressing too small a chunk of behavior.</para>

				<section xml:id="s3.tut.basic_flow">
					<title>Specifying the Basic Flow</title>

					<indexterm>
						<primary>Basic Flow</primary>
						<secondary>of Use Case</secondary>
					</indexterm>
					<indexterm>
						<primary>Use Case</primary>
						<secondary>Basic Flow</secondary>
					</indexterm>

					<para>All flows in a use case specification are linear&#8212;that is there is no conditional branching. Any choices in flows are handled by specifying another alternate flow that takes over at the choice point. It is important to remember we are specifying behavior here, not programming it.</para>
					<para>A flow is specified as a series of numbered steps. Each step must involve some interaction with an actor, or at least generate a change that is observable externally by an actor. Requirements capture should not be specifying hidden internal behavior of a system.</para>
					<para>For example we might give the following sequence of steps for the basic flow of the use case &quot;Withdraw Cash&quot; in our ATM example.</para>

					<orderedlist>
						<listitem>
							<para>Customer indicates a receipt is required.</para>
						</listitem>
						<listitem>
							<para>Customer enters amount of cash required.</para>
						</listitem>
						<listitem>
							<para>ATM verifies with the central computer that the customer can make this withdrawal.</para>
						</listitem>
						<listitem>
							<para>ATM dispenses cash to the customer.</para>
						</listitem>
						<listitem>
							<para>ATM issues receipt to customer.</para>
						</listitem>
					</orderedlist>

					<para>Remember this is a sub-use case included in the main <quote>Use ATM</quote> use case, which will presumably handle checking of cards and PINs before invoking this included use case.</para>

					<note>
						<para>The first step is not a condition. We take as our basic flow the case where the customer does want a receipt. The case where the customer does not want a receipt will be an alternative flow.</para>
					</note>
				</section>

				<section xml:id="s3.tut.alternate_flows">
					<title>Specifying the Alternate Flows</title>

					<indexterm>
						<primary>Alternate Flows</primary>
						<secondary>of Use Case</secondary>
					</indexterm>
					<indexterm>
						<primary>Use Case</primary>
						<secondary>Alternate Flows</secondary>
					</indexterm>
					<indexterm>
						<primary>Alternative scenarios</primary>
					</indexterm>

					<para>This captures the alternative scenarios, as linear flows, by reference to the basic flow. Initially we just build a list of the alternate flows.</para>

					<orderedlist inheritnum="inherit" numeration="upperalpha">
						<listitem>
							<orderedlist inheritnum="inherit" numeration="arabic">
								<listitem>
									<para>Customer does not require a receipt.</para>
								</listitem>
								<listitem>
									<para>Customer&#039;s account will not support the withdrawal.</para>
								</listitem>
								<listitem>
									<para>Communication to the central computer is down.</para>
								</listitem>
								<listitem>
									<para>The customer cancels the transaction.</para>
								</listitem>
								<listitem>
									<para>The customer fails to take the dispensed cash.</para>
								</listitem>
							</orderedlist>
						</listitem>
					</orderedlist>

					<para>Subsequently we flesh out each alternate flow, by reference to the basic flow. For example the first alternate flow might look like.</para>

					<orderedlist inheritnum="inherit" numeration="upperalpha">
						<listitem>
							<orderedlist inheritnum="inherit" numeration="arabic">
								<listitem>
									<para>Customer does not require a receipt.</para>
									<orderedlist inheritnum="inherit" numeration="arabic">
										<listitem>
											<para>At step 1 of the basic flow the customer indicates they do not want a receipt.</para>
										</listitem>
										<listitem>
											<para>The basic flow proceeds from step 2 to step 4, and step 5 is not used.</para>
										</listitem>
									</orderedlist>
								</listitem>
							</orderedlist>
						</listitem>
					</orderedlist>

					<para>The convention is to number the various alternate flows as A.1, A.2, A.3, etc. The steps within an alternate flow are then numbered from this. So the steps of the first alternate flow would be A.1.1, A.1.2, A.1.3, etc.</para>
				</section>

				<section>
					<title>Iterative Development of Use Case Specifications</title>

					<para>Iterative development will prioritize the use cases, and the first iterations will address the most important.</para>
					<para>Early iterations will capture the basic flows of the most important use cases with only essential detail and list the headings of the main alternate flows.</para>
					<para>Later iterations will address the remaining use cases, flesh out the steps on individual alternate flows and possibly provide more detail on individual steps.</para>
				</section>
			</section>

			<section>
				<title>Supplementary Requirement Specification</title>

				<indexterm>
					<primary>Supplementary Requirement Specification</primary>
				</indexterm>
				<indexterm>
					<primary>Non-functional requirements</primary>
				</indexterm>
				<indexterm>
					<primary>Non-functional constraints</primary>
				</indexterm>

				<para>This captures the non-functional requirements or constraints placed on the system. Since use cases are inherently functional in nature, they cannot capture this sort of information.</para>

				<note>
					<para>Some analysts like to place non-functional requirements in a section at the end of each use case specification, containing the non-functional requirements relevant to the use case.</para>
					<para>This can cause some problems. First key non-functional requirements (for example about performance) may need to appear in many use cases and it is bad practice to replicate information. Secondly there are invariably some non-functional requirements that are system wide and need a system wide document. Hence my preference for a single supplementary requirements specification. </para>
				</note>

				<para>There should be a section for each of the main areas of non-functional requirements. The checklist provided by Ian Sommerville in his book <emphasis>Software Engineering</emphasis> (Third Edn, Addison-Wesley, 1989) is a useful guide.</para>

				<itemizedlist>
					<listitem>
						<para><emphasis>Speed</emphasis>. Processor performance, user/event response times, screen refresh time.</para>
					</listitem>
					<listitem>
						<para><emphasis>Size</emphasis>. Main memory (and possibly caches), disc capacity.</para>
					</listitem>
					<listitem>
						<para><emphasis>Ease of use</emphasis>. Training time, style and detail of help system.</para>
					</listitem>
					<listitem>
						<para><emphasis>Reliability</emphasis>. Mean time to failure, probability of unavailability, rate of failure, availability.</para>
					</listitem>
					<listitem>
						<para><emphasis>Robustness</emphasis>. Time to restart after failure, percentage of events causing failure, probability of data corruption on failure.</para>
					</listitem>
					<listitem>
						<para><emphasis>Portability</emphasis>. Percentage of target-dependent code/classes, number of target systems.</para>
					</listitem>
				</itemizedlist>
				<para>To this we should add sections on environment (temperature, humidity, lightening protection status) and standards compliance.</para>
			</section>
		</section>

		<section xml:id="s1.argo_use_cases">
			<title>Using Use Cases in ArgoUML</title>

			<para>ArgoUML allows you to draw use case diagrams. When you create a new project it has a use case diagram created by default, named <literal>use case diagram 1</literal>. Select this by button 1 click on the diagram name in the explorer (the upper left quadrant of the user screen).</para>
			<para>New use case diagrams can be created as needed through <literal>Create Diagram</literal> on the main menu bar or on the Create Diagram Toolbar. They are edited in the editing pane (the upper right quadrant of the user screen).</para>

			<section>
				<title>Actors</title>

				<indexterm>
					<primary>Create New</primary>
					<secondary>Actor</secondary>
				</indexterm>
				<indexterm>
					<primary>Actor</primary>
				</indexterm>

				<para>To add an actor to the diagram use button 1 click on the actor icon on the editing pane toolbar ( <guiicon>
						<inlinemediaobject>
							<imageobject>
								<imagedata align="center" fileref="images/icons/actor.gif"
									format="GIF" />
							</imageobject>
						</inlinemediaobject>
					</guiicon>) and then button 1 click at the location where you wish to place it. The actor can be moved subsequently by button 1 motion (i.e. button 1 down over the actor to select it, move to the new position and button 1 release to drop the actor in place.</para>
				<para>Multiple actors can be added in one go, by using button 1 double click on the actor icon. Each subsequent button 1 click will drop an actor on the diagram. A button 1 click on the select icon ( <guiicon>
						<inlinemediaobject>
							<imageobject>
								<imagedata align="center" fileref="images/icons/select.gif"
									format="GIF" />
							</imageobject>
						</inlinemediaobject>
					</guiicon>) will stop adding actors.</para>
				<para>The actors name is set in its property panel. First select the actor (if not already selected) on the editing pane using button 1 click. Then click on the <literal> Properties</literal> tab in the details pane. The name is entered in the name field, and will appear on the screen.</para>
				<para>As a shortcut, double button 1 click on the name of the actor in the editing pane (or just typing on the keyboard when an actor is selected) will allow the name to be edited directly. This is a convenient way to enter a name for a new actor.</para>
				<para>Having created the actor, you will see it appear in the explorer (the upper left quadrant of the user screen). This shows all the model elements created within the UML design. A drop down at the top of the explorer controls the ordering of model elements in the explorer. The most useful are the <literal> Package-centric</literal> (default) and <literal> Diagram-centric</literal>. The latter shows model elements grouped by the diagram on which they appear.</para>
			</section>

			<section>
				<title>Use Cases</title>

				<indexterm>
					<primary>Create New</primary>
					<secondary>Use Case</secondary>
				</indexterm>
				<indexterm>
					<primary>Use Case</primary>
				</indexterm>

				<para>The procedure for adding use cases is the same as that for adding actors, but using the use case icon on the editing pane toolbar (<guiicon>
						<inlinemediaobject>
							<imageobject>
								<imagedata align="center" fileref="images/icons/use_case.gif"
									format="GIF" />
							</imageobject>
						</inlinemediaobject>
					</guiicon>).</para>
				<para>By default use cases in ArgoUML do not display their extension points (for use in extend relationships). You can show the extension point compartment in one of two ways.</para>

				<orderedlist>
					<listitem>
						<para>Select the use case in the editing pane with button 1 click, then select the <literal>Style</literal> tab in the details pane and button 1 click on the <literal>Display: Extension Points</literal> check box.</para>
					</listitem>
					<listitem>
						<para>Use button 2 click over the use case in the editing pane to display a context-sensitive pop-up menu and from that choose <literal>Show/Show Extension Point Compartment</literal>.</para>
					</listitem>
				</orderedlist>

				<para>The same approaches can be used to hide the extension point compartment.</para>

				<section>
					<title>Adding an Extension Point to a Use Case</title>

					<indexterm>
						<primary>Create New</primary>
						<secondary>Extension Point</secondary>
					</indexterm>
					<indexterm>
						<primary>Extension Point</primary>
					</indexterm>

					<para>There are two ways to add an extension point to a use case.</para>

					<orderedlist>
						<listitem>
							<para>Select the use case on the editing pane with button 1 click. Then click on the <literal>Add Extension Point</literal> icon ( <guiicon>
									<inlinemediaobject>
										<imageobject>
											<imagedata align="center"
												fileref="images/icons/extension_point.gif"
												format="GIF" />
										</imageobject>
									</inlinemediaobject>
								</guiicon>) on the toolbar, and a new extension point with default name and location will be added after any existing extension points.</para>
							<note>
								<para>The <literal>Add Extension Point</literal> icon is grayed out and unusable until a use case is selected.</para>
							</note>
						</listitem>
						<listitem>
							<para>Select the use case on the editing pane with button 1 click and then select its property tab in the details pane. A button 2 click over the <literal> Extension Points:</literal> field will bring up a context-sensitive pop-up menu. Select <literal> Add</literal> to add a new extension point.</para>
							<para>If any extension points already exist, they will be shown in this field on the property tab. The new extension point will be inserted immediately before the entry over which the pop-up menu was invoked. This ordering can be changed later by using the <literal> Move Up</literal> and <literal>Move Down</literal> entries on the pop-up menu.</para>
						</listitem>
					</orderedlist>

					<para>Whichever method is used, the new extension point is selected, and its property tab can be displayed in the details pane. The name and location of the extension point are free text, set in the corresponding fields of the property tab.</para>
					<para>An existing extension point can be edited from its property tab. The property tab can be reached in two ways.</para>

					<orderedlist>
						<listitem>
							<para>If the extension point compartment for the use case is displayed on the diagram, select the use case with button 1 click and then select the extension point with a further button 1 click. The property tab can then be selected in the details pane.</para>
						</listitem>
						<listitem>
							<para>Otherwise select the use case and its property tab in the details pane. A button 1 click on the desired entry in the <literal>Extension Points</literal> field will bring up the property tab for the extension point in the details pane.</para>
						</listitem>
					</orderedlist>
					<para>The name and location fields of the extension point may then be edited.</para>
					<para>As a shortcut, where the extension point compartment is displayed, double click on the extension point allows text to be typed in directly. This is parsed to set name and location for the extension point.</para>
					<para>Extension points may be deleted, or their ordering changed by using the button 2 pop-up menu over the <literal> Extension Points</literal> field in the use case property tab.</para>
					<para>Having created an extension point, it will appear in the explorer (upper left quadrant of the user screen). Extension points are always shown in a sub-tree beneath their owning use case.</para>
				</section>
			</section>

			<section>
				<title>Associations</title>

				<indexterm>
					<primary>Create New</primary>
					<secondary>Association in a Use Case Diagram</secondary>
				</indexterm>
				<indexterm>
					<primary>Association</primary>
					<secondary>in a Use Case Diagram</secondary>
				</indexterm>

				<para>To join a use case to an actor on the diagram use button 1 click on the association icon on the editing pane toolbar (<guiicon>
						<inlinemediaobject>
							<imageobject>
								<imagedata align="center" fileref="images/icons/association.gif"
									format="GIF" />
							</imageobject>
						</inlinemediaobject>
					</guiicon>). Hold button 1 down at the use case, move to the actor and release button 1 (or alternatively start at the actor and finish at the use case).</para>
				<para>This will create a straight line between actor and use case. You can segment the line by holding down button 1 down on the line and moving before releasing. A vertex will be added to the line, which you can move by button 1 motion. A vertex can be removed by picking it up and sliding to one end of the line.</para>
				<para>Multiple associations can be added in one go, by using button 1 double click on the association icon. Each subsequent button 1 down/motion/release sequence will join an actor to a use case. Use button 1 on the select icon ( <guiicon>
						<inlinemediaobject>
							<imageobject>
								<imagedata align="center" fileref="images/icons/select.gif"
									format="GIF" />
							</imageobject>
						</inlinemediaobject>
					</guiicon>) to stop adding associations.</para>
				<para>It is also possible to add associations using small <quote>handles</quote> that appear to the left and right of a use case or actor when it is selected and the mouse is over it. Dragging the handle from a use case to an actor will create an association to that actor (and similarly by dragging a handle from an actor to a use case).</para>
				<para>Dragging a handle from a use case into empty space will create a new actor to go on the other end. Similarly dragging a handle from an actor into empty space will create a new use case.</para>
				<para>It is possible to give an association a name, describing the relationship of the actor to the use case, although this is not usually necessary. This is done through the property tab of the association. Such a name appears alongside the association near its center.</para>

				<section xml:id="s3.tut.req_argo_navigation">
					<title>Setting Navigation</title>

					<indexterm>
						<primary>Setting Navigation</primary>
						<secondary>to an association in a Use Case Diagram</secondary>
					</indexterm>
					<indexterm>
						<primary>Navigation</primary>
						<secondary>Setting</secondary>
					</indexterm>

					<para>There are two ways of setting the navigation of an association.</para>

					<orderedlist>
						<listitem>
							<para>Use button 2 click on the association to bring up a context-sensitive pop-up menu. The <literal> Navigability</literal> sub-menu has options for bi-directional navigation (the default, with no arrows) and for navigability Actor-»Use Case and Use Case-»Actor.</para>
						</listitem>
						<listitem>
							<para>Use button 1 to select the association and select its property tab in the details pane. This shows a field named <literal>Association Ends:</literal>, with entries for each end labeled by the actor or use case name and its multiplicity. Select the end that should be at the tail of the arrow with button 1 click. This brings up the property tab for the association end. Use button 1 click to uncheck the <literal> Navigability</literal> box.</para>
							<note>
								<para>This may seem counter-intuitive, but in fact associations by default are navigable in both directions (when no arrows are shown). This process is <emphasis>turning off</emphasis> navigation at one end, rather than turning it on at the other.</para>
							</note>
						</listitem>
					</orderedlist>
					<para>You will see it is possible to give an association end a name in its property tab. This name will appear at that end of the association, and can be used to indicate the <emphasis>role</emphasis> being played by an actor or use case in an association.</para>
					<para>For example a time management system for a business may have use cases for completing time sheets and for signing off time sheets. An employee actor may be involved in both, one as an employee, but the other in a role as manager.</para>
				</section>

				<section>
					<title>Setting Multiplicity</title>

					<indexterm>
						<primary>Setting Multiplicity</primary>
						<secondary>to an association in a Use Case Diagram</secondary>
					</indexterm>
					<indexterm>
						<primary>Multiplicity</primary>
						<secondary>Setting</secondary>
					</indexterm>

					<para>There are two ways of setting multiplicity at the end of an association.</para>

					<orderedlist>
						<listitem>
							<para>Button 2 click over the end of an association will cause a context-sensitive pop-up menu to appear with a sub-menu labeled <literal> Multiplicity</literal>. This allows you to select from <literal>1</literal> (the default), <literal> 0..1</literal>, <literal>0..*</literal> and <literal> 1..*</literal>.</para>
						</listitem>
						<listitem>
							<para>Bring up the property sheet for the association end as described for setting navigation (see the second option in <xref
									xlink:href="s3.tut.req_argo_navigation"
								 /> ). A drop down menu gives a range of multiplicity options that may be selected.</para>
						</listitem>
					</orderedlist>

					<para>The second of these two approaches has a wider range of options, although ArgoUML does not currently allow the user to set an arbitrary multiplicity.</para>
				</section>
			</section>

			<section>
				<title>Hierarchical Use Cases</title>

				<indexterm>
					<primary>Hierarchical Use Cases</primary>
				</indexterm>
				<indexterm>
					<primary>Use Case, Hierarchical</primary>
				</indexterm>

				<para>UML as originally designed allowed use cases to be organized by grouping them in packages as well as by specifying relations among them. In ArgoUML only the relations mechanism is supported. All Three of the relations that apply to use cases are supported. These are <emphasis>include</emphasis>, <emphasis>extend</emphasis> and <emphasis>generalization</emphasis>. </para>

				<section>
					<title>Includes</title>

					<indexterm>
						<primary>Create New</primary>
						<secondary>Include Relationship in a Use Case Diagram</secondary>
					</indexterm>
					<indexterm>
						<primary>Include Relationship</primary>
						<secondary>in a Use Case Diagram</secondary>
					</indexterm>
					<indexterm>
						<primary>Relationship</primary>
						<secondary>Include</secondary>
					</indexterm>

					<para>The procedure for adding an include relationship is the same as that for adding an association, but using the include icon from the editing pane toolbar ( <guiicon>
							<inlinemediaobject>
								<imageobject>
									<imagedata align="center" fileref="images/icons/include.gif"
										format="GIF" />
								</imageobject>
							</inlinemediaobject>
						</guiicon>) to join two use cases.</para>
					<para>Since include relationships are directional the order in which the two ends are selected is important. The <emphasis>including</emphasis> (main) use case should be selected first (button 1 down) and the <emphasis>included</emphasis> (subsidiary) use case second (button 1 release).</para>
					<para>It is possible to name include relationships using the property tab, but this is rarely done, and will not be displayed on the use case diagram.</para>
				</section>

				<section>
					<title>Extends</title>

					<indexterm>
						<primary>Create New</primary>
						<secondary>Extend Relationship in a Use Case Diagram</secondary>
					</indexterm>
					<indexterm>
						<primary>Extend Relationship</primary>
						<secondary>in a Use Case Diagram</secondary>
					</indexterm>
					<indexterm>
						<primary>Relationship</primary>
						<secondary>Extend</secondary>
					</indexterm>

					<para>The procedure for adding an extend relationship is the same as that for adding an include relationship, but using the extend icon from the editing pane toolbar ( <guiicon>
							<inlinemediaobject>
								<imageobject>
									<imagedata align="center" fileref="images/icons/extend.gif"
										format="GIF" />
								</imageobject>
							</inlinemediaobject>
						</guiicon>) to join two use cases.</para>
					<para>As with include relationships, the order of selection matters. In this case, the <emphasis>extending</emphasis> (subsidiary) use case should be selected first (button 1 down) and the <emphasis>extending</emphasis> (main) use case second (button 1 release).</para>

					<note>
						<para>This is the reverse of the include relationship, but reflects the way that designer&#039;s tend to think. The fact that the extend icon&#039;s arrow points upward (the opposite of the include icon) should help remind you of this.</para>
					</note>

					<para>To set a condition for the extend relationship, select the extend relationship in the editing pane (button 1 click) and then bring up its property tab in the details pane (button 1 click on the tab). The text of the condition may be typed in the <literal>Condition</literal> field. Long conditions may be split over several lines if desired. The condition is displayed under the <literal>«extend»</literal> label on the diagram.</para>
					<para>It is possible to name extend relationships using the property tab, but this is rarely done, and will not be displayed on the use case diagram.</para>
				</section>

				<section>
					<title>Generalization</title>

					<indexterm>
						<primary>Create New</primary>
						<secondary>Generalization relationship in a Use Case Diagram</secondary>
					</indexterm>
					<indexterm>
						<primary>Generalization Relationship</primary>
						<secondary>in a Use Case Diagram</secondary>
					</indexterm>
					<indexterm>
						<primary>Relationship</primary>
						<secondary>Generalization</secondary>
					</indexterm>

					<para>The procedure for adding generalizations, is the same as for adding extend relationships, but using the generalization icon from the editing pane toolbar ( <guiicon>
							<inlinemediaobject>
								<imageobject>
									<imagedata align="center"
										fileref="images/icons/generalization.gif" format="GIF" />
								</imageobject>
							</inlinemediaobject>
						</guiicon>).</para>
					<para>Since generalization is a directed relationship, the order of selection matters. The specialized use case should be selected first (button 1 down) and the generalized second (button 1 release).</para>
					<para>It is also possible to add generalizations using small <quote>handles</quote> that appear to the top and bottom of a use case when it is selected. Dragging the handle at the top to another use case will create a generalization. The original use case is the specializing end, and the use case to which the handle was dragged will be the generalizing end. Dragging into empty space will create a new use case to be the generalizing end.</para>
					<para>Similarly dragging on the bottom handle will create a generalization in which the original use case is the <emphasis>generalizing</emphasis> end.</para>
					<para>Generalization is also permitted between actors, although its use is beyond the scope of this tutorial. Unlike use cases there are no generalization handles on actors, so generalizations must be created using the toolbar icon.</para>
					<para>It is possible to name generalization relationships using the property tab, but this is rarely done. If a name is provided, it will be displayed on the use case diagram.</para>
				</section>
			</section>

			<section>
				<title>Stereotypes</title>

				<indexterm>
					<primary>Stereotype</primary>
					<secondary>in Use Case Diagrams</secondary>
				</indexterm>

				<para>UML has the concept of <emphasis>stereotyping</emphasis> as a way of extending the basic notation. It may prove useful for example to model a problem at both the business level and the engineering level. It is for this reason that the OMG distinguishes between a PIM and a PSM. For both of these we will need use cases, but the use cases at the business level hold a different sort of information to those at the engineering level. Very likely they use different language and notation in their underlying use case specifications. </para>
				<para><emphasis>Stereotypes</emphasis> are used to label UML model elements such as use cases, to indicate that they belong to a certain category. Such labels are shown in guillemots ( <literal>« »</literal>) above the name of the model element on the diagram. The UML standard defines a number of standard stereotypes, and the user may define more stereotypes of his own.</para>
				<para>You will see that ArgoUML has a drop down selector, <literal>Stereotype</literal> on every property tab. This is populated with the standard stereotypes, to which you may add your own user defined ones.</para>
				<para>The details of stereotyping are beyond the scope of this tutorial. The reference manual (see <xref
						xlink:href="s1.ref.stereotype"
					 />) documents the support provided in ArgoUML.</para>

				<warning>
					<para>ArgoUML is missing a few of the standard UML stereotypes. In addition not all model elements will actually display the stereotype on the diagram. At present this includes use cases and actors.</para>
				</warning>
			</section>

			<section>
				<title>Documentation</title>

				<indexterm>
					<primary>Documentation in Use Case Diagrams</primary>
				</indexterm>

				<para>ArgoUML has some simple documentation facilities associated with model elements on a diagram. In general these should be used only to record the location of material in documents that can be handled by a mainstream editor or word processor, not the actual documentation itself.</para>
				<para>Documentation for a particular model element is recorded through the documentation tab in the details pane (the quadrant of the user screen at the bottom right).</para>
				<para>In addition annotation may be added to diagrams using the text icon on the editing pane toolbar ( <guiicon>
						<inlinemediaobject>
							<imageobject>
								<imagedata align="center" fileref="images/icons/text.gif"
									format="GIF" />
							</imageobject>
						</inlinemediaobject>
					</guiicon>).</para>
				<para>The recommendation is that a use case diagram should use the documentation tab of actors to record information about the actor, or if the actor is complex to refer to a separate document that holds information about the actor.</para>
				<para>The documentation tab of use cases should record the location of the use case specification. The information in a use case specification (for all but the simplest use cases) is too complex to be placed directly in the tab.</para>
				<para>The project should also have a separate vision document and supplementary requirements specification. A text annotation on diagrams may be used to refer to these if the user finds this helpful.</para>

				<warning>
					<para>The documentation tab includes a <literal>Deprecated</literal> check box. The state of this flag is not preserved over save and load in the current release of ArgoUML</para>
				</warning>
			</section>

			<section>
				<title>System Boundary Box</title>

				<indexterm>
					<primary>System Boundary Box in Use Case Diagram</primary>
				</indexterm>

				<para>ArgoUML provides a series of tools to provide arbitrary graphical annotation on diagrams (we have already mentioned the text tool). These are found at the right hand end of the editing pane toolbar and are fully documented in the reference manual (see <xref
						xlink:href="ch.ref.editpane" /> ).</para>
				<para>The rectangle tool can be used to draw the boundary box. Use the button 2 context-sensitive <literal> Ordering</literal> pop-up menu to place it behind everything else. However there is no way to change its fill color from the default white. You may therefore prefer to draw the boundary box as four lines. This is the method used for the diagrams in this chapter.</para>

				<note>
					<para>The editing pane in ArgoUML has a grid to which objects snap to aid in drawing. The size of this grid and its effect may be altered through the <literal> View</literal> menu (using <literal>Adjust Grid</literal> and <literal>Adjust Grid Snap</literal>). This is described fully in the reference manual (see <xref
							xlink:href="ch.ref.menu" />).</para>
				</note>
			</section>
		</section>

		<section xml:id="s3.tut.req_case_study">
			<title>Case Study</title>

			<section>
				<title>Vision Document</title>

				<indexterm>
					<primary>Vision Document</primary>
					<secondary>Case Study</secondary>
				</indexterm>

				<para>A vision document contains more than those things needed for the modeling effort. It also contains financial and scheduling pertinent information. The following sections are those parts of the Vision Document spelled out in <xref
						xlink:href="s2.tut.vision_document"
					 /> above. In practice this format need not be followed religiously, but is used here for consistency.</para>

				<section>
					<title>Summary</title>

					<para>The company wishes to produce and market a line of ATM devices. The purpose of this project is to produce the hardware and the software to drive it that are both maintainable and robust.</para>
				</section>

				<section>
					<title>Goals</title>

					<para>To produce better designed products based on newer technology. Follow the MDA philosophy of the OMG by producing first a Platform Independent Model (PIM). As current modeling technology does not admit of maintaining the integrity of the connection between the PIM and Platform Specific Models (PSMs), the PIM will become comparatively stable before the first iteration of the PSM is produced. The software platform will be Java technology. The system will use a simple userid (from ATM card) and password (or PIN) mechanism.</para>
				</section>

				<section>
					<title>Market Context</title>

					<para>Equipment currently on the market is based on older technology for both hardware and software. This technology has not reached the end of its useful life, making it unlikely that the vendors of that gear are going to update it in the near future. On the other hand newer technology is available that would put us at a competitive advantage if implemented now.</para>
				</section>

				<section>
					<title>Stakeholders</title>

					<para>Among the stakeholders for this system are the Engineering Department, the Maintenance Department, and the Central Computer Facility. The full list of these stakeholders and the specific individuals representing them are.</para>

					<itemizedlist>
						<listitem>
							<para><emphasis>Engineering</emphasis>. Bunny, Bugs</para>
						</listitem>
						<listitem>
							<para><emphasis>Maintenance</emphasis>. Hardy, Oliver</para>
						</listitem>
						<listitem>
							<para><emphasis>Computer Facility</emphasis>. Laurel, Stanley</para>
						</listitem>
						<listitem>
							<para><emphasis>Chief Executive Officer</emphasis>. Hun, Atilla The</para>
						</listitem>
						<listitem>
							<para><emphasis>Marketing</emphasis>. Harry, Oil Can</para>
						</listitem>
					</itemizedlist>
				</section>

				<section>
					<title>Key Features</title>

					<para>Cash deposit, cash withdrawal, and account inquiries by customers. Customers include people who have accounts at the owning bank as well as people who wish to make withdrawals from accounts in other banks or from credit card accounts.</para>
					<para>Maintenance of the equipment by the bank&#039;s engineers. This action may be initiated by the engineer on a routine basis. It may also be initiated by the equipment that can call the engineer when it detects an internal fault.</para>
					<para>Unloading of deposits and loading of cash by officials of the local bank branch. These actions occur either on a scheduled basis or when the central computer determines that the cash supply is low or the deposit receptacle is liable to be getting full.</para>
					<para>An audit trail for all activities will be maintained and sent periodically to the bank&#039;s central computer. It will be possible for the maintenance engineer to save a copy of the audit trail to a diskette for transporting to the central computer.</para>
					<para>Both dialup and leased line support will be provided. The ATM will continue to provide services to customers when communication with the central computer is not available. </para>
				</section>

				<section>
					<title>Constraints</title>

					<para>The project must be completed within nine months. It must cost no more than 1,750,000 USD excluding production costs. Components may be contracted out, but the basic architecture as well as the infrastructure will be designed in house. Close liaison must be maintained between the software development and the design, development and production of the hardware. Neither the hardware nor the software shall be considered the independent variable, but rather they shall be considered equal.</para>
				</section>

				<section>
					<title>Appendix</title>

					<para>The following are the actors that directly support this vision. Additional actors may be identified later that are needed to support this or that technology. They should not be added to this list unless they are deemed to directly support the vision as described in this document.</para>

					<itemizedlist>
						<listitem>
							<para>Central Computer</para>
						</listitem>
						<listitem>
							<para>Customer</para>
						</listitem>
						<listitem>
							<para>Local Branch Official</para>
						</listitem>
						<listitem>
							<para>Maintenance Engineer</para>
						</listitem>
					</itemizedlist>

					<para>The following are the use cases that directly support this vision. Additional use cases may be identified later that are needed to support this or that technology or to support the use cases listed here. They should not be added to this list unless they are deemed to directly support the vision as described in this document.</para>

					<itemizedlist>
						<listitem>
							<para>Audit</para>
						</listitem>
						<listitem>
							<para>Customer Uses Machine</para>
						</listitem>
						<listitem>
							<para>Maintain Machine</para>
						</listitem>
					</itemizedlist>
				</section>
			</section>

			<section>
				<title>Identifying Actors and Use Cases</title>

				<para>For the ATM case study, we will elaborate on the examples in <xref
						xlink:href="s1.tut.req_process_output" />, <xref
						xlink:href="fig.tut.atm_use_case_diagram_include" /> and <xref
						xlink:href="fig.tut.atm_use_case_diagram_extend"
						 />, and progress to identify additional actors and use cases that comprise our model of the ATM system. <xref
						xlink:href="fig.tut.atm_use_case_diagram_include" /> and <xref
						xlink:href="fig.tut.atm_use_case_diagram_extend"
					 /> exemplified the essential concepts and components of a use case diagram such as, use cases, actors, multiplicity, and include / extend relationships. They showed the relationships between the actors and use cases, and demonstrated how these actors and use cases interact.</para>
				<para>In <xref xlink:href="fig.tut.atm_use_case_diagram_include"
					 /> we see a use case diagram for an ATM system consisting of «include» relationships for the use cases, Maintain ATM and Use ATM. Maintain ATM was further defined by two use cases, &quot;Maintain Equipment&quot; and &quot;Reload ATM&quot;. Use ATM was further defined in terms of the behavior of three simpler use cases: &quot;Deposit Cash&quot;, &quot;Withdraw Cash&quot; and &quot;Query Account&quot;.</para>

				<remark>More to be written…</remark>
			</section>

			<section>
				<title>Associations (To be written)</title>

				<remark>To be written…</remark>
			</section>

			<section>
				<title>Advanced Diagram Features (To be written)</title>

				<remark>To be written…</remark>
			</section>

			<section>
				<title>Use Case Specifications (To be written)</title>

				<remark>To be written…</remark>
			</section>

			<section>
				<title>Supplementary Requirements Specification (To be written)</title>

				<remark>To be written…</remark>
			</section>
		</section>
	</chapter>

	
	<chapter xml:id="ch.tut.analysis">
		<title>Analysis</title>
		<para>Analysis is the process of taking the <quote>customer</quote> requirements and re-casting them in the language of, and from the perspective of, a putative solution.</para>
		<para>We are not actually trying the flesh out the detailed solution at this stage. That occurs in the <emphasis>Design Phase</emphasis> (see <xref xlink:href="ch.tut.design" />).</para>
		<para>Unlike the boundary between Requirements and Analysis Phases, the boundary between Analysis and Design Phases is inherently blurred. The key is that analysis should define the solution no further than is necessary to specify the requirements in the language of the solution. The model elements in Analysis generally represent a high level of abstraction.</para>
		<para>Once again the <emphasis>recursive</emphasis>, and <emphasis>iterative</emphasis> nature of our process means we will come back to the Analysis phase many times in the future.</para>
		
		<section>
			<title>The Analysis Process</title>
			
			<para>There are three schools of thought on how Analysis should be approached. The ontologist defines the data (actually the metadata) first and worries about processes later. The true ontologist would prefer not to have to think about processes at all. The phenomenonologist reverses this and favors process over data. The panparadigmist considers both process and data to be equally important and addresses both from the start. </para>
			<para>When it comes to being a purist the ontologist has the upper hand. It is possible to define and build a database into which data can be entered and retrieved without concern for what happens to it or is done with it. On the other hand implementing a process without having any data structures for it to operate on is not very meaningful. </para>
			
			<section>
				<title>Class, Responsibilities, and Collaborators (CRC) Cards</title>
				
				<para>The CRC methodology favors the phenomenonologists preference for analysis. It is the equivalent of starting with the use cases, the process aspects (operations) of the class diagrams, and scenarios from which sequence diagrams can be initiated. </para>
				<para>CRC cards and the associated methodology are described in detail in <xref
						xlink:href="app.crc"
						 />. They are used again in the design phase and are further discussed in <xref
						xlink:href="ch.tut.design" />. </para>
				<para>The strength of CRC cards during analysis. <itemizedlist>
						<listitem>
							<para>Common Project Vocabulary -</para>
						</listitem>
						<listitem>
							<para>Spread Domain Knowledge -</para>
						</listitem>
						<listitem>
							<para>Making the Paradigm Shift -</para>
						</listitem>
						<listitem>
							<para>Live Prototyping -</para>
						</listitem>
						<listitem>
							<para>Identifying Holes in Requirements -</para>
						</listitem>
					</itemizedlist>
				</para>
				<para>In this phase the group should consist of two or three domain experts, one object-oriented technology facilitator, and the rest of the group made up of people who are responsible for delivering the system. </para>
				<para>The first time that the Analysis phase occurs a special case of the CRC session happens as there are no classes or scenarios to choose from to define a CRC session. At this point a special type of session known as brainstorming is held. During this session you identify the initial set of classes in the problem domain by using the problem statement or requirements document or whatever you know about the desired result for a starting point. The nouns that are found in whatever you are starting from are a good key to an initial set of classes in the system. In a brainstorming session there should be little or no discussion of the ideas. Record them and filter the results after the brainstorming. At this stage the distinction between class and object is blurred. </para>
				<para>Once a reasonable set of classes has been defined by the group, responsibilities can be added. Add responsibilities that are obvious from the requirements or the name of the class. You don&#039;t need to find them all (or any for that matter). The scenarios will make them more obvious. The advantage of finding some in the beginning is that it helps provide a starting place. </para>
				<para>Select the initial scenarios from the requirements document by examining it&#039;s verbs in much the same way that we scanned its nouns earlier. Then as many walk through sessions as necessary to complete the analysis phase are performed. </para>
				<para>When is enough of the analysis complete that design can begin? When all the different responsibilities are in place and the system has become stable. After all the normal behavior has been covered, exceptional behavior needs to be simulated. When you notice that the responsibilities are all in place to support the new scenarios, and there is little change to the cards, this is a sign the you are ready to start design. </para>
			</section>
			<section>
				<title>Concept Diagram (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>System Sequence Diagram (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>System Statechart Diagram (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Realization Use Case Diagram (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Documents (To be written)</title>
				<remark>Use Case Specifications and Supplementary Requirements Specifications recast in solution language. To be written…</remark>
			</section>
		</section>
		<section xml:id="s1.umlclassdiags">
			<title>Class Diagrams (To be written)</title>
			<remark>To be written…</remark>
			<section>
				<title>The Class Diagram (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Advanced Class Diagrams (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Association Classes (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
		</section>
		<section xml:id="s1.argoclassdiags">
			<title>Creating Class Diagrams in ArgoUML</title>
			<section>
				<title>Classes</title>
				<remark>Identifying class diagrams from existing materials (Vision, Use Cases etc). To be written…</remark>
				<section>
					<title>Using the Note Icon in the Tool Bar</title>
					<para>Click on your target class. Then click on the note icon. ArgoUML will generate the link automatically.</para>
					<para>You can also right click to add a note as well! Be aware that you can add an undefined number of notes to any one class!</para>
					<warning>
						<para>Be aware that your note will not appear in the source code documentation tab.</para>
					</warning>
				</section>
			</section>
			<section>
				<title>Associations (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Aggregation (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>Class Attributes and Operations (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Entering Data Into Attributes and Methods Windows</title>
					<para>Click directly in the class model element and start typing. Do not use the properties window dialog fields&#8212;they are not fully functional and liable to cause you a little frustration.</para>
					<para>In fact, it would be interesting to see if you can type stereotypes right into the class attribute box for generating XML diagrams. </para>
				</section>
				<section>
					<title>Class Attributes (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Class Operations (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>Advanced Class Features (To be written)</title>
				<section>
					<title>Association Classes (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Stereotypes (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
		</section>
		<section xml:id="s1.umlseqdiags">
			<title>Sequence Diagrams (To be written)</title>
			<remark>To be written…</remark>
			<section>
				<title>The Sequence Diagram (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Identifying Actions (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Advanced Sequence Diagrams (To be written)</title>
				<remark>To be written…</remark>
			</section>
		</section>
		<section xml:id="s1.argoseqdiags">
			<title>Creating Sequence Diagrams in ArgoUML</title>
			<section>
				<title>Sequence Diagrams</title>
				<section>
					<title>Creating a Sequence Diagram</title>
					<para>Normally, you can just start a sequence diagram right away. On the <literal>Create Diagram</literal> menu choose <literal>Sequence</literal>.</para>
				</section>
			</section>
			<section>
				<title>Actions (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Advanced Sequence Diagrams (To be written)</title>
				<remark>To be written…</remark>
			</section>
		</section>
		<section xml:id="s1.umlstatediags">
			<title>Statechart Diagrams (To be written)</title>
			<remark>To be written…</remark>
			<section>
				<title>The Statechart Diagram (To be written)</title>
				<remark>Types of statechart diagram (Moore, Mealy); Hierarchical diagrams. To be written…</remark>
			</section>
			<section>
				<title>Advanced Statechart Diagrams (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Hierarchical Statechart Diagrams (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
		</section>
		<section xml:id="s1.argostatediags">
			<title>Creating Statechart Diagrams in ArgoUML</title>
			<section>
				<title>Statechart Diagrams (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Creating a Statechart Diagram</title>
					<para>Select a class, then you can create a statechart diagram.</para>
				</section>
			</section>
			<section>
				<title>States (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Editing a Composite State</title>
					<para>When editing a composite state, how do you provide do and event for a composite state?</para>
					<para>The answer is to select a class, then you can create a statechart diagram.</para>
				</section>
			</section>
			<section>
				<title>Transitions (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Actions (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Advanced Statechart Diagrams (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Hierarchical Statechart Diagrams (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
		</section>
		<section>
			<title>Realization Use Cases (To be written)</title>
			<remark>To be written…</remark>
		</section>
		<section>
			<title>Creating Realization Use Cases in ArgoUML (To be written)</title>
			<remark>To be written…</remark>
		</section>
		<section>
			<title>Case Study (To be written)</title>
			<para>Regardless of which methodology you use, at this time you are undoubtedly going to take the problem statement from <xref
					xlink:href="s3.tut.req_case_study" /> and extract the nouns from it. This list should be compacted to contain only those nouns that are expected to result in a class. This effort results in the following. <itemizedlist>
					<listitem>
						<para>Account</para>
					</listitem>
					<listitem>
						<para>Audit trail</para>
					</listitem>
					<listitem>
						<para>Bank</para>
					</listitem>
					<listitem>
						<para>Cash</para>
					</listitem>
					<listitem>
						<para>Customer</para>
					</listitem>
				</itemizedlist>
			</para>
			<section>
				<title>CRC Cards</title>
				<para>The project manager convenes a CRC session at which the initial set of classes are to be defined. The facilitator reminds the participants that we are in the analysis phase and are only interested in what needs to be done (at the business level) and are to leave out anything that smacks of how to do it. As a general rule of thumb this means a subset of the nouns from the problem statement (see above). The group starts with a complete list of all of the nouns in the statement, examines each one, and decides which are inappropriate crossing them off the list. Each class is then assigned to one of the participants. </para>
				<para>
					<remark>to be continued</remark>… </para>
			</section>
			<section>
				<title>Concept Class Diagrams (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Identifying classes (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Identifying associations (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>System Sequence Diagrams (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Identifying actions (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>System Statechart Diagrams (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Realization Use Cases (To be written)</title>
				<remark>To be written…</remark>
			</section>
		</section>
	</chapter>
	
	
	<chapter xml:id="ch.tut.design">
		<title>Design</title>
		<para>We now have the problem we are trying to solve specified in the language of a putative solution. In the Design Phase, we construct all the details of that solution. </para>
		<para>The blurred boundary between Analysis and Design is reflected in their use of many of the same UML tools. In this chapter we will mostly be reusing UML technology we have already met once. The big step is casting everything into concrete terms. We move from the abstract concepts of analysis to their concrete realization. </para>
		<para>Once again the <emphasis>recursive</emphasis>, and <emphasis>iterative</emphasis> nature of our process means we will come back to the Design phase many times in the future. </para>
		<section>
			<title>The Design Process (To be written)</title>
			<para>The design process extends the modeling effort beyond the business concerns and into the solutions space. It is during this effort that you decide whether you are going to use Java, C++, J2EE, CORBA, SOAP, Dial up line, internet connection dedicated line, XML, etc. Many of these decisions will impact directly the PSM model, others may only be reflected in the documents produced. </para>
			<para>… </para>
			<section>
				<title>Class, Responsibilities, and Collaborators (CRC) Cards</title>
				<para>Strength of CRC cards during Design <itemizedlist>
						<listitem>
							<para>Spreading Objet-Oriented Design Expertise</para>
						</listitem>
						<listitem>
							<para>Design Reviews</para>
						</listitem>
						<listitem>
							<para>Framework for Implementation</para>
						</listitem>
						<listitem>
							<para>Informal Notation</para>
						</listitem>
						<listitem>
							<para>Choice of supporting software components</para>
						</listitem>
						<listitem>
							<para>Performance Requirements</para>
						</listitem>
					</itemizedlist>
				</para>
				<para>In this phase developers replace some of the domain experts in the group, but there should always be at least one domain expert in the group. </para>
				<para>The focus of the group moves from what is to be done to how to do it. The classes from the solution domain are added to those defined in the analysis phase. Think about what classes are needed to make the system work. Do you need a List class to hold objects? Do you need classes to handle exceptions? Do you need wrapper classes for other subsystems? New classes that are looked for in this part, are classes that support the implementation of the system. </para>
				<para>During the design phase the distinction between class and object becomes important. Think about the objects in your scenarios. Who creates the objects? What happens when it is created and destroyed? What is the lifetime of the object vs. the lifetime of the information held be the object? </para>
				<para>Now is the time to look at what information the objects hold compared to what is requested from other classes or computed on the fly. Use the back of the card to record the attributes found for the classes. Break you responsibilities into subresponsibilities and list the subresponsibilities indented under the main responsibilities. Move the collaborators next to the subresponsibilities that use them. </para>
				<para>After the Collaborator class on your card list the responsibility of the used class that is used in the collaboration. After the collaborating responsibilities on your cards, list the data passed back by the collaborating object in parenthesis. </para>
				<para>Redo the scenarios you did in the analysis phase, but know take into consideration all of the design heuristics discussed. Make up your own scenarios and try them. </para>
			</section>
			<section>
				<title>Package Diagram (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Realization Class Diagrams (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Sequence Diagrams and Collaboration Diagrams (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Statechart Diagrams and Activity Diagrams (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Deployment Diagram (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Documents (To be written)</title>
				<remark>System Architecture. To be written…</remark>
			</section>
		</section>
		<section>
			<title>Package Diagrams (To be written)</title>
			<remark>To be written…</remark>
			<section>
				<title>The Package Diagram (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Advanced Package Diagrams (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Subpackages (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Adding DataTypes (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Adding Stereotypes (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
		</section>
		<section>
			<title>Creating Package Diagrams in ArgoUML</title>
			<section>
				<title>Packages</title>
				<remark>How to work out what goes in packages. To be written…</remark>
				<section>
					<title>Subpackages (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>Relationships between packages (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Dependency (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Generalization (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Realization and Abstraction (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>Advanced Package Features (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Creating New Datatypes (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Creating New Stereotypes (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
		</section>
		<section>
			<title>More on Class Diagrams (To be written)</title>
			<remark>To be written…</remark>
			<section>
				<title>The Class Diagram (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Class Attributes (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Class Operations (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>Advanced Class Diagrams (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Realization and Abstraction (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
		</section>
		<section>
			<title>More on Class Diagrams in ArgoUML (To be written)</title>
			<section>
				<title>Classes (To be written)</title>
				<remark>More on identifying classes from existing materials and use of stereotypes. To be written…</remark>
			</section>
			<section>
				<title>Class Attributes and Operations (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Class Attributes (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Class Operations (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>Advanced Class Features</title>
				<section>
					<title>Operations on Interfaces</title>
					<section>
						<title>Interfaces that extend interfaces</title>
						<para>Add a unnamed interface to the current classdiagram by single-clicking on the interface icon in the tool bar and then clicking at the diagram pane (see <xref
								xlink:href="fig.tut.iftool" />).</para>
						<figure floatstyle="1" xml:id="fig.tut.iftool">
							<title>Selecting the Interface tool</title>
							<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/iftool.gif" format="GIF" /></imageobject></mediaobject></screenshot>
						</figure>
						<para>Then double click on the interfaces name field to change it&#039;s name as shown in <xref
								xlink:href="fig.tut.if" />.</para>
						<figure floatstyle="1" xml:id="fig.tut.if">
							<title>Interface model element on the Class Diagram</title>
							<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/if.gif" format="GIF" /></imageobject></mediaobject></screenshot>
						</figure>
						<para>and type a name for it (like <literal> TestInterface</literal> in this case). Press <quote>Enter</quote> when the name is complete. (You could also enter the name by going to the Properties Tab in the Details Pane after adding the interface.)</para>
						<para>Add another interface with a different by repeating the last 2 steps. Then single-click on the Generalization icon in the tool bar as shown in <xref
								xlink:href="fig.tut.generalize" />.</para>
						<figure floatstyle="1" xml:id="fig.tut.generalize">
							<title>Generalization on the Class Diagram tool bar</title>
							<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/generalize.gif" format="GIF" /></imageobject></mediaobject></screenshot>
						</figure>
						<para>move the mouse pointer to the subinterface, press the left mouse button and drag the generalization to the superinterface, where you release the mouse button. Figure <xref
								xlink:href="fig.tut.ifgen"
							 /> shows how your diagram should look now.</para>
						<figure floatstyle="1" xml:id="fig.tut.ifgen">
							<title>Generalization between two Interfaces.</title>
							<screenshot><mediaobject><imageobject> <imagedata align="center" fileref="images/tutorial/ifgen.gif" format="GIF" /></imageobject></mediaobject></screenshot>
						</figure>
						<para>By clicking on the subinterface and the source tab properties pane, and then selecting Java Notation for the source tab, you can see that the interface actually extends it&#039;s superinterface.</para>
					</section>
				</section>
				<section>
					<title>Stereotypes (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
		</section>
		<section>
			<title>Sequence and Collaboration Diagrams (To be written)</title>
			<note>
				<para>Sequence diagrams does not work in ArgoUML version 0.14.</para>
			</note>
			<remark>To be written…</remark>
			<section>
				<title>More on the Sequence Diagram (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>The Collaboration Diagram (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Messages (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Actions (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>Advanced Collaboration Diagrams (To be written)</title>
				<remark>To be written…</remark>
			</section>
		</section>
		<section>
			<title>Creating Collaboration Diagrams in ArgoUML (To be written)</title>
			<section>
				<title>Collaboration Diagrams (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Messages (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Actions (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>Advanced Collaboration Diagrams (To be written)</title>
				<remark>To be written…</remark>
			</section>
		</section>
		<section>
			<title>Statechart Diagrams (To be written)</title>
			<remark>To be written…</remark>
			<section>
				<title>The Statechart Diagram (To be written)</title>
				<remark>More on this. To be written…</remark>
			</section>
			<section>
				<title>Advanced Statechart Diagrams (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Actions (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Transitions (To be written)</title>
					<remark>To be written…</remark>
					<section>
						<title>Triggers (To be written)</title>
						<remark>To be written…</remark>
					</section>
					<section>
						<title>Guards (To be written)</title>
						<remark>To be written…</remark>
					</section>
					<section>
						<title>Effectss (To be written)</title>
						<remark>To be written…</remark>
					</section>
				</section>
				<section>
					<title>Pseudo States (To be written)</title>
					<remark>To be written…</remark>
					<section>
						<title>Junction and Choice (To be written)</title>
						<remark>To be written…</remark>
					</section>
					<section>
						<title>Fork and Join (To be written)</title>
						<remark>To be written…</remark>
					</section>
				</section>
				<section>
					<title>Hierarchical State Machines (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Models for State History (To be written)</title>
					<remark>Shallow v Deep. To be written…</remark>
				</section>
			</section>
		</section>
		<section>
			<title>Creating Statechart Diagrams in ArgoUML (To be written)</title>
			<section>
				<title>Statechart Diagrams (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>States (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Transitions (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Actions (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Advanced Statechart Diagrams (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Transitions (To be written)</title>
					<remark>To be written…</remark>
					<section>
						<title>Triggers (To be written)</title>
						<remark>To be written…</remark>
					</section>
					<section>
						<title>Guards (To be written)</title>
						<remark>To be written…</remark>
					</section>
					<section>
						<title>Effectss (To be written)</title>
						<remark>To be written…</remark>
					</section>
				</section>
				<section>
					<title>Pseudo States (To be written)</title>
					<remark>To be written…</remark>
					<section>
						<title>Junction and Choice (To be written)</title>
						<remark>To be written…</remark>
					</section>
					<section>
						<title>Fork and Join (To be written)</title>
						<remark>To be written…</remark>
					</section>
				</section>
				<section>
					<title>Hierarchical State Machines (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>History (To be written)</title>
					<remark>Shallow v Deep. To be written…</remark>
				</section>
			</section>
		</section>
		<section xml:id="s1.umlactivitydiags">
			<title>Activity Diagrams (To be written)</title>
			<remark>To be written…</remark>
			<section>
				<title>The Activity Diagram (To be written)</title>
				<remark>More on this. To be written…</remark>
				<section>
					<title>Action States (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
		</section>
		<section>
			<title>Creating Activity Diagrams in ArgoUML (To be written)</title>
			<section>
				<title>Activity Diagrams (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Creating an Activity Diagram</title>
					<para>Select a use case or class, then you can create an activity diagram.</para>
				</section>
			</section>
			<section>
				<title>Action States (To be written)</title>
				<remark>To be written…</remark>
			</section>
		</section>
		<section>
			<title>Deployment Diagrams (To be written)</title>
			<remark>To be written…</remark>
			<section>
				<title>The Deployment Diagram (To be written)</title>
				<remark>To be written…</remark>
			</section>
		</section>
		<section>
			<title>Creating Deployment Diagrams in ArgoUML (To be written)</title>
			<section>
				<title>Nodes (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Node Instances (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>Components (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Component Instances (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>Relationships between nodes and components (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Dependency (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Associations (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Links (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
		</section>
		<section>
			<title>System Architecture (To be written)</title>
			<remark>To be written…</remark>
		</section>
		<section>
			<title>Case Study (To be written)</title>
			<section>
				<title>CRC Cards (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Packages (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Identifying Packages (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Datatypes and Stereotypes (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>Class Diagrams (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Identifying classes (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Identifying associations (To be written)</title>
					<remark>To be written…</remark>
				</section>
				<section>
					<title>Specifying Attributes and Operations (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>Sequence Diagrams (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Identifying actions (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>Collaboration Diagrams (To be written)</title>
				<remark>To be written…</remark>
				<section>
					<title>Identifying Messages (To be written)</title>
					<remark>To be written…</remark>
				</section>
			</section>
			<section>
				<title>Statechart Diagrams (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>Activity Diagrams (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>The Deployment Diagram (To be written)</title>
				<remark>To be written…</remark>
			</section>
			<section>
				<title>The System Architecture (To be written)</title>
				<remark>To be written…</remark>
			</section>
		</section>
	</chapter>
	
	
	<chapter xml:id="ch.tut.build">
		<title>Code Generation, Reverse Engineering, and Round Trip Engineering</title>
		<section>
			<title>Introduction</title>
			<para>We now have our design fully specified. With the right simulator we could actually execute the design and see if it works. (ArgoUML does not provide such functionality, but this functionality has been provided in alternative tools.)</para>
			<para>ArgoUML does allow you to generate code from the design in several different programming languages. We, most likely, already in the design had a programming language in mind because some of the design considerations are to care for a specific language.</para>
			<para>The output of this process is the set of files that constitute the program that solves the problem.</para>
			<para>Once again the <emphasis>recursive</emphasis>, and <emphasis>iterative</emphasis> nature of our process means we will come back to the Build phase many times in the future.</para>
			<para>There is also another side to this and that is the reverse engineering side. If we happen to have an old program that we would like to examine then we could take the files and reverse engineer them to create a design. This can be used when trying to understand some not so well documented program or as a quick start for the design work.</para>
			<para>The process of going back and forth between doing changes in the design followed by a code generation and then doing changes in the code followed by a reverse engineering using for every change, the best possible perspective, is called Round-trip Engineering.</para>
		</section>
		<section>
			<title>Code Generation</title>
			<indexterm>
				<primary>Code Generation</primary>
			</indexterm>
			<para>The output of the Code Generation is the completed program. Depending on the contents of the design, we could also generate Unit test cases.</para>
			<para>To do the work we need the design model, containing both static and dynamic descriptions of the program.</para>
			<section>
				<title>Generating Code from the Static Structure</title>
				<indexterm>
					<primary>Generating Code</primary>
					<secondary>from the Static Structure</secondary>
				</indexterm>
				<para>It is rather straightforward to do this generation, at least as long as we do it for an object-oriented language. This is some of the basic rules: <itemizedlist>
						<listitem>
							<para>A class will become a class.</para>
							<para>In some target languages (like java, c++) they also become files and compilation units.</para>
						</listitem>
						<listitem>
							<para>A generalization will become an inheritance.</para>
							<para>If the target language does not support inheritance and we didn&#039;t address this during the design, some special conversions are required to solve this.</para>
						</listitem>
						<listitem>
							<para>An attribute will become a member variable.</para>
						</listitem>
						<listitem>
							<para>A navigable association will become a member variable.</para>
							<para>Depending on the target language, target platform, and the association multiplicities this will be a pointer, a reference, a collection class, an entry in some table or map.</para>
						</listitem>
						<listitem>
							<para>A non-abstract operation in a class will become a method.</para>
						</listitem>
						<listitem>
							<para>An abstract operation in a class will become an abstract method.</para>
						</listitem>
						<listitem>
							<para>An in parameter in an operation will become a parameter in the method.</para>
							<para>For simple types (int, boolean), this is the normal case. For C++, these will probably const classes. For Java, this cannot be enforced for classes.</para>
						</listitem>
						<listitem>
							<para>An out or in/out parameter in an operation will become a referenced parameter in the method.</para>
							<para>For C++, these will be referenced non-const parameters. For Java classes, this is the default. Simple types (int, boolean) must, in java, be converted to an object of a corresponding class (Integer, Boolean).</para>
						</listitem>
						<listitem>
							<para>The visibilities of the attributes, associations, and operations will become visibilities on the member variables or methods.</para>
						</listitem>
						<listitem>
							<para>Packages will become directories, namespaces, or both.</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>
			<section>
				<title>Generating code from interactions and state machines</title>
				<indexterm>
					<primary>Generating Code</primary>
					<secondary>from Sequence Diagrams</secondary>
				</indexterm>
				<indexterm>
					<primary>Generating Code</primary>
					<secondary>from Interactions</secondary>
				</indexterm>
				<indexterm>
					<primary>Generating Code</primary>
					<secondary>from Collaboration Diagrams</secondary>
				</indexterm>
				<indexterm>
					<primary>Generating Code</primary>
					<secondary>from Statechart Diagrams</secondary>
				</indexterm>
				<para>This conversion is not as straight-forward as the conversion of the static structure. It is much more depending on the target language and target platform.</para>
				<para>In general it is only possible to say the following for interactions: <itemizedlist>
						<listitem>
							<para>A message is converted into a function call.</para>
							<para>The class of the recipient will have to have a function with the correct name and signature.</para>
							<para>The sender function in the class of the sender will have a call to the function in the recipient.</para>
						</listitem>
						<listitem>
							<para>An asynchronous message is converted to either posting a message to be handled by some other thread or a function call to a function that starts a new thread.</para>
						</listitem>
					</itemizedlist>
				</para>
				<para>The following describes one possible way to generate state machines: <itemizedlist>
						<listitem>
							<para>A State Machine is generated to a set of member variables that each method in this class refer to when deciding behavior.</para>
						</listitem>
						<listitem>
							<para>A State is generated to a closed set of combination of values on these member variables.</para>
						</listitem>
						<listitem>
							<para>An Event is generated as a call to a member method that can change the state.</para>
							<para>These methods would then typically have one big switch statement splitting on the current state.</para>
						</listitem>
						<listitem>
							<para>A Guard is generated to an <symbol>if</symbol> statement in the event member method in the branch for the correct state.</para>
						</listitem>
						<listitem>
							<para>A Transition is generated as an assignment of some state variable.</para>
						</listitem>
						<listitem>
							<para>An Action is generated as a function call.</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>
		</section>
		<section>
			<title>Code Generation in ArgoUML</title>
			<section>
				<title>Static Structure</title>
				<para>Most of the generation can be done automatically by the provided language modules. Files are generated in a directory hierarchy that need to be filled in by the actual code.</para>
			</section>
			<section>
				<title>Interactions and statechart diagrams</title>
				<para>There is currently no support for this in ArgoUML, not for any language.</para>
			</section>
		</section>

		<section>
			<title>Reverse Engineering</title>

			<indexterm>
				<primary>Reverse Engineering</primary>
			</indexterm>

			<para>Reverse Engineering is used for two main purposes: <orderedlist>
					<listitem>
						<para>To get previously developed classed into the model to build upon.</para>
					</listitem>
					<listitem>
						<para>To get a UML view of previously developed classes to understand how they work.</para>
					</listitem>
				</orderedlist>
			</para>
			<para>Essentially this does the opposite of Code Generation.</para>
		</section>

		<section>
			<title>Round-Trip Engineering</title>
			<indexterm>
				<primary>Round-Trip Engineering</primary>
			</indexterm>
			<para>Round-Trip Engineering makes it possible to switch perspective while doing the design. Create some classes in a class diagram. Write some code for some of the operations or functions using your favorite editor. Move the operations from one class to another in the class diagram…</para>
			<para>ArgoUML currently does not support this for any language.</para>
		</section>
	</chapter>
</part>