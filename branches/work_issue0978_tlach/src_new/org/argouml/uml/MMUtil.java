// Copyright (c) 1996-99 The Regents of the University of California. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies.  This software program and
// documentation are copyrighted by The Regents of the University of
// California. The software program and documentation are supplied "AS
// IS", without any accompanying services from The Regents. The Regents
// does not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason.  IN NO EVENT SHALL THE
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

// File: MMUtil.java
// Classes: MMUtil
// Original Author: not known

// 3 Apr 2002: Jeremy Bennett (mail@jeremybennett.com). Extended to support
// the Extend and Include relationships.

// 8 Apr 2002: Jeremy Bennett (mail@jeremybennett.com). Extended to add
// buildExtensionPoint and getExtensionPoints methods for use cases.

// 16 Apr 2002: Jeremy Bennett (mail@jeremybennett.com). Extended to remove
// include and extend relationships when deleting a use case.


package org.argouml.uml;

import ru.novosoft.uml.*;
import ru.novosoft.uml.foundation.core.*;
import ru.novosoft.uml.foundation.data_types.*;
import ru.novosoft.uml.model_management.*;
import ru.novosoft.uml.foundation.extension_mechanisms.*;
import ru.novosoft.uml.behavior.use_cases.*;
import ru.novosoft.uml.behavior.collaborations.*;
import ru.novosoft.uml.behavior.state_machines.*;
import ru.novosoft.uml.behavior.common_behavior.*;

import java.util.*;

import org.argouml.ui.ProjectBrowser;
import org.apache.log4j.Category;
import org.argouml.application.api.Argo;
import org.argouml.application.api.Notation;
import org.argouml.application.api.NotationName;
import org.argouml.application.notation.NotationProviderFactory;
import org.argouml.kernel.Project;
import org.argouml.model.uml.UmlFactory;

public class MMUtil {

	Category cat = Category.getInstance(org.argouml.uml.MMUtil.class);

	public static MMUtil SINGLETON = new MMUtil();

	public static MModel STANDARDS;

	static {
		STANDARDS = UmlFactory.getFactory().getModelManagement().createModel();
		STANDARDS.setName("standard Elements");
		MStereotype realizationStereo = UmlFactory.getFactory().getExtensionMechanisms().createStereotype();
		realizationStereo.setName("realize");
		STANDARDS.addOwnedElement(realizationStereo);

		MStereotype interfaceStereo = UmlFactory.getFactory().getExtensionMechanisms().createStereotype();
		interfaceStereo.setName("interface");
		STANDARDS.addOwnedElement(interfaceStereo);
	}


    /**
     * This tag is set on elements that are generated by reference when
     * importing.
     * If it is set, then the critics could ignore those objects if they want.
     */
    public static final String GENERATED_TAG = "GeneratedFromImport";


    /**
     * <p>Remove a use case and its associated connections from the model.<p>
     *
     * <p>We remove the include and extend here, then use the classifier
     *   version of this method to remove everything else. Note that we must
     *   get rid of both ends.</p>
     *
     * @param useCase  The use case to remove form the model
     */

    public void remove(MUseCase useCase) {

        // Get rid of extends

        Iterator extendIterator = (useCase.getExtends()).iterator();

        while (extendIterator.hasNext()) {
            ((MExtend) extendIterator.next()).remove();
        }

        extendIterator = (useCase.getExtends2()).iterator();

        while (extendIterator.hasNext()) {
            ((MExtend) extendIterator.next()).remove();
        }

        // Get rid of includes

        Iterator includeIterator = (useCase.getIncludes()).iterator();

        while (includeIterator.hasNext()) {
            ((MInclude) includeIterator.next()).remove();
        }

        includeIterator = (useCase.getIncludes2()).iterator();

        while (includeIterator.hasNext()) {
            ((MInclude) includeIterator.next()).remove();
        }

        // Use the classifier version to get rid of everything else (including
        // our very own good selves).

        remove((MClassifier) useCase);
    }

    // This method takes care about removing all unneeded transitions
    // while removing a StateVertex (like a State or ActionState, also Fork et.al.)
    public void remove(MStateVertex sv) {
	Collection transitions = sv.getIncomings();
	Iterator transitionIterator = transitions.iterator();
	while (transitionIterator.hasNext()) {
	    MTransition transition = (MTransition)transitionIterator.next();
	    transition.remove();
	}
	transitions = sv.getOutgoings();
	transitionIterator = transitions.iterator();
	while (transitionIterator.hasNext()) {
	    MTransition transition = (MTransition)transitionIterator.next();
	    transition.remove();
	}
	sv.remove();
    }
    
    /**
     * Removes a modelelement. Delegates the actual removal to more 
     * specific methods if specific elements must be removed.
     * @param me
     * @see org.argouml.kernel.Project#trashInternal(Object) for the use of the method
     * @author jaap.branderhorst@xs4all.nl
     */
    public void remove(MModelElement me) {
    	if (me instanceof MClassifier) {
    		remove((MClassifier)me); return;
    	}
    	if (me instanceof MStateVertex) {
    		remove((MStateVertex)me); return;
    	}
    	if (me instanceof MLink) {
    		remove((MLink)me); return;
    	}
    	if (me instanceof MObject) {
    		remove((MObject)me); return;
    	}
    	if (me instanceof MStimulus) {
    		remove((MStimulus)me); return;
    	}
    	if (me instanceof MUseCase) {
    		remove((MUseCase)me); return;
    	}
    	me.remove();
    }

    /**
     * Removes a classifier including all depending Modelelements.
     * @param cls The classifier to be removed
     */
	// This method takes care about removing all unneeded associations,
	// generalizations, ClassifierRoles and dependencies when removing
	// a classifier.
    public void remove(MClassifier cls) {
		Iterator ascEndIterator = (cls.getAssociationEnds()).iterator();
		while (ascEndIterator.hasNext()) {
			MAssociationEnd ae = (MAssociationEnd)ascEndIterator.next();
			MAssociation assoc = ae.getAssociation();
			if ((assoc.getConnections()).size() < 3)
				assoc.remove();
			else
				ae.remove();
		}

		Iterator roleIterator = (cls.getClassifierRoles()).iterator();
		while (roleIterator.hasNext()) {
			MClassifierRole r = (MClassifierRole)roleIterator.next();
			r.remove();
		}

		Iterator generalizationIterator = (cls.getGeneralizations()).iterator();
		while (generalizationIterator.hasNext()) {
			MGeneralization gen = (MGeneralization)generalizationIterator.next();
			gen.remove();
		}

		Iterator specializationIterator = (cls.getSpecializations()).iterator();
		while (specializationIterator.hasNext()) {
			MGeneralization spec = (MGeneralization)specializationIterator.next();
			spec.remove();
		}

		Iterator clientDependencyIterator = cls.getClientDependencies().iterator();
		while (clientDependencyIterator.hasNext()) {
			MDependency dep = (MDependency)clientDependencyIterator.next();
			if (dep.getClients().size() < 2)
				dep.remove();
		}

		Iterator supplierDependencyIterator = cls.getSupplierDependencies().iterator();
		while (supplierDependencyIterator.hasNext()) {
			MDependency dep = (MDependency)supplierDependencyIterator.next();
			if (dep.getSuppliers().size() < 2)
				dep.remove();
		}


		cls.remove(); //takes also care of removing the elementlisteners
    }

 public void remove (MObject obj) {
	Iterator linkEndIterator = (obj.getLinkEnds()).iterator();
	while (linkEndIterator.hasNext()) {
	    MLinkEnd le = (MLinkEnd)linkEndIterator.next();
	    MLink link = le.getLink();
	    if ((link.getConnections()).size() < 3)
		link.remove();
	    else
		le.remove();
	}
	obj.remove();
    }

    public void remove (MStimulus stimulus) {
	MLink link = stimulus.getCommunicationLink();
	link.remove();
	stimulus.remove();
    }

     public void remove (MLink link) {
	link.remove();
    }

    /**
     * Build a returnparameter. Removes all current return parameters from the
     * operation and adds the supplied parameter. The directionkind of the 
     * parameter will be return. The name will be equal to the name of the last
     * found return parameter or the default value "return" if no return
     * parameter was present in the operation.
     * @param operation
     * @param newReturnParameter
     */
	public void setReturnParameter(MOperation operation, MParameter newReturnParameter) {
		Iterator params = operation.getParameters().iterator();
        String name = "return";
		while (params.hasNext()) {
			MParameter parameter = (MParameter)params.next();
			if ((parameter.getKind()).equals(MParameterDirectionKind.RETURN)) {
				operation.removeParameter(parameter);
                if (parameter.getName() != null || parameter.getName() == "") {
                    name = parameter.getName();
                }
			}
		}
        newReturnParameter.setName(name);
		newReturnParameter.setKind(MParameterDirectionKind.RETURN);
		operation.addParameter(0, newReturnParameter);
	}


    
    
    
}

