<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Id$ -->
<!--
// Copyright (c) 1996-2005 The Regents of the University of California. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies.  This software program and
// documentation are copyrighted by The Regents of the University of
// California. The software program and documentation are supplied "AS
// IS", without any accompanying services from The Regents. The Regents
// does not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason.  IN NO EVENT SHALL THE
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
-->

<!--

This section covers requirements capture and how &argouml; supports such
activity.

-->

<chapter id="ch.tut.reqs">
  <title>Requirements Capture</title>

  <sect1>
    <title>Introduction</title>

    <indexterm>
      <primary>Requirement</primary>
      <secondary>Capturing</secondary>
    </indexterm>

    <para>Requirements capture is the process of identifying what the
      <quote>customer</quote> wants from the proposed system.</para>

    <para>The key at this stage is that we are in the problem domain. At this
      stage we must describe everything from the <quote>customer</quote>
      perspective and in the language of the <quote>customer</quote>.</para>

    <para>The biggest risk we have in requirements capture is to start thinking
      in terms of possible solutions. That must wait until the
      <emphasis>Analysis Phase</emphasis> (see <xref
      linkend="ch.tut.analysis"/>). One of the steps of the Analysis Phase will
      be to take the output of the Requirements Phase and recast it in the
      language of a deemed solution.</para>

    <para>Remember we are using both a <emphasis>incremental</emphasis>, and an
      <emphasis>iterative</emphasis> process.</para>

    <para>We may well come back to the requirements process again as we break
      down the problem into smaller chunks, each of which must have its
      requirements captured.</para>

    <para>We will certainly come back through the requirements phase on each
      iteration as we seek to define the requirements of more and more of the
      system</para>

    <note>
      <para>
The only part of the requirements notation specified by the
      UML standard is the use case diagram. The remainder is process
      specific. The process described in this chapter draws heavily on the
      Rational Unified Process.</para></note>
  </sect1>

  <!-- Take the reader through the process of capturing requirements. This will
       be quite high level in the current version of the document. -->

  <sect1>
    <title>The Requirements Capture Process</title>

    <indexterm>
      <primary>Vision Document</primary>
    </indexterm>

    <para>
We start with a top-level view of the problem we are solving and the
      key areas of functionality that we must address in any
      solution. This is our <emphasis>vision document</emphasis>, and should
      be just a few pages long.</para>

    <para>
For example the top-level view of an automated teller machine (ATM)
      might be that it should support the following.</para>

    <orderedlist>
      <listitem><para>Cash deposit, cash withdrawal and account inquiries by
        customers.</para></listitem>

      <listitem><para>Maintenance of the equipment by the bank's engineers, and
        unloading of deposits and loading of cash by the local bank
        branch.</para></listitem>

      <listitem><para>Audit trail for all activities sent to the bank's central
        computer.</para></listitem>
    </orderedlist>

    <indexterm>
      <primary>Actor</primary>
    </indexterm>

    <para>
From this top-level view we can extract the principle activities of
      the system, and the external agents (people, equipment) that are involved
      in those activities. These activities are known as <emphasis>use
      cases</emphasis> and the external agents are known as
      <emphasis>actors</emphasis>.</para>

    <para>Actors may be people or machines. From a practical standpoint it is
      worth knowing the stakeholder behind any machine, since only they will be
      able to engage with the requirements capture process.</para>

    <indexterm>
      <primary>Use Case</primary>
    </indexterm>

    <para>Use cases should be significant activities for the system. For
      example customer use of the ATM machine is a use case. Entering a PIN
      number is not.</para>

    <para>There is a gray area between these two extremes. As we shall see it
      is often useful to break very large use cases into smaller sub-use
      cases. For example we may have sub-use cases covering cash deposit, cash
      withdrawal and account inquiry.</para>

    <para>There is no hard and fast rule. Some architects will prefer a small
      number of relatively large use cases, others will prefer a larger number
      of smaller use cases. A useful rule of thumb is that any practical
      project ought to require no more than about 30 use cases (if it needs
      more, it should be broken into separate projects).</para>

    <para>We then show the relationship between use cases and actors on one or
      more use case diagrams. For a large project more than one diagram will be
      needed. Usually groups of related use cases are shown on one
      diagram.</para>

    <para>We must then give a more detailed specification of each use
      case. This covers its normal behavior, alternative behaviors and any pre-
      and post-conditions. This is captured in a document variously known as a
      <emphasis>use case specification</emphasis> or <emphasis>use case
      scenario</emphasis>.</para>

    <indexterm>
      <primary>Supplementary Requirement Specification</primary>
    </indexterm>

    <para>Finally, since use cases are functional in nature, we need a document
      to capture the non-functional requirements (capacity, performance,
      environmental needs etc). These requirements are captured in a document
      known as a <emphasis>supplementary requirements
      specification</emphasis>.</para>

    <sect2>
      <title>Process Steps</title>

      <para>The steps in the requirements capture process can be summarized as
        follows.</para>

      <orderedlist>
        <listitem>
          <indexterm>
            <primary>Vision Document</primary>
          </indexterm>

          <para>Capture an overall view of the problem, and the
desired characteristics of its solution in the <emphasis>vision
document</emphasis>.
</para>
        </listitem>

        <listitem>
          <indexterm>
            <primary>Use Case</primary>
          </indexterm>

          <para>Identify the <emphasis>use case</emphasis> and
          <emphasis>actors</emphasis> from the vision document and show their
          relationships on one or more <emphasis>use case
          diagrams</emphasis>.</para></listitem>

        <listitem>
          <indexterm>
            <primary>Use Case Specification</primary>
          </indexterm>
          <indexterm>
            <primary>Specification</primary>
            <secondary>of Use Case</secondary>
          </indexterm>

          <para>Give detailed <emphasis>use case
          specifications</emphasis> for each use case, covering normal and
          alternate behavior, pre- and post-conditions.</para></listitem>

        <listitem>
          <indexterm>
            <primary>Non-functional requirements</primary>
          </indexterm>
          <indexterm>
            <primary>Supplementary Requirement Specification</primary>
          </indexterm>

          <para>Capture all non-functional requirements in a
          <emphasis>supplementary requirements
          specification</emphasis>.</para></listitem>
      </orderedlist>

      <para>In any iterative development process, we will 
        prioritize, and early iterations will focus on capturing the key
        behavior of the most important use cases.</para>

      <para>Most modern requirements capture processes agree that it is
        essential that the authoritative representative of the customer is
        fully involved throughout the process.</para>
    </sect2>
  </sect1>

  <sect1 id="s1.tut.req_process_output">
    <title>Output of the Requirements Capture Process</title>

    <para>Almost all the output of the requirements capture process is
      documentary. The only diagram is the use case diagram, showing the
      relationships between use cases and actors.</para>

    <sect2 id="s2.tut.vision_document">
      <title>Vision Document</title>

      <indexterm>
        <primary>Vision Document</primary>
      </indexterm>

      <para>Typical sections of this document would be as follows.</para>

      <itemizedlist>
        <listitem><para><emphasis>Summary</emphasis>. A statement of the
          context, problem and solution goals.</para></listitem>

        <listitem>
          <indexterm>
            <primary>Goals</primary>
            <secondary>in the Vision document</secondary>
          </indexterm>

          <para><emphasis>Goals</emphasis>. 
What are we trying to
achieve (and how do we wish to achieve it).
</para>
        </listitem>

        <listitem>
          <indexterm>
            <primary>Market Context</primary>
            <secondary>in the Vision document</secondary>
          </indexterm>

          <para><emphasis>Market Context</emphasis>
or <emphasis>Contractual Arrangements</emphasis>.

For a market led development, this should indicate target markets,
competitive differentiators, compelling events and so forth.

For a contractual development this should explain the key contractual
drivers.
</para>
        </listitem>

        <listitem>
          <indexterm>
            <primary>Stakeholders</primary>
            <secondary>in the Vision document</secondary>
          </indexterm>

          <para><emphasis>Stakeholders</emphasis>. 
The users (in the widest sense) of the system.

Many of these will map in to actors, or control equipment that maps
into actors.
</para>
        </listitem>

        <listitem>
          <indexterm>
            <primary>Key features</primary>
            <secondary>in the Vision document</secondary>
          </indexterm>

          <para><emphasis>Key Features</emphasis>.

At the very highest level what are they key functional aspects of the
problem/desired solution.

These will largely map down to the use cases.

It is helpful to give some prioritization here.
</para>
        </listitem>

        <listitem>
          <indexterm>
            <primary>Constraints</primary>
            <secondary>in the Vision document</secondary>
          </indexterm>
          <indexterm>
            <primary>Non-functional parameters</primary>
            <secondary>in the Vision document</secondary>
          </indexterm>

          <para><emphasis>Constraints</emphasis>.
A high level view of the non-functional parameters of the system.

These will be worked out in detail in the supplementary requirements
specification.
</para>
        </listitem>

        <listitem><para><emphasis>Appendix</emphasis>. A listing of the
          actors and use cases that will be needed to meet this vision. It is
          useful to link to these from the earlier sections to ensure
          comprehensive coverage.</para></listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Use Case Diagram</title>

      <indexterm>
        <primary>Use Case Diagram</primary>
      </indexterm>
      <indexterm>
        <primary>Diagram</primary>
        <secondary>Use Case</secondary>
      </indexterm>

      <para>The vision document has identified the use cases and actors. The
        use case diagram captures how they interact. In our ATM example we
        have identified <quote>customer uses machine</quote>, <quote>maintain
        machine</quote> and <quote>audit</quote> as the three main use
        cases. We have identified <quote>customer</quote>, maintenance
        engineer<quote>, </quote><quote>local branch official</quote> and
        <quote>central computer</quote> as the actors.</para>

      <para><xref linkend="fig.tut.atm_use_case_diagram_basic"/> shows how
        this could be displayed on a use case diagram. The use cases are
        shown as ovals, the actors as stick people (even where they are
        machines), with lines (known as <emphasis>associations</emphasis>
        connecting use cases to the actors who are involved with them. A box
        around the use cases emphasizes the boundary between the system
        (defined by the use cases) and the actors who are external.</para>

      <note><para>Not all analysts like to use a box around the use cases. It
        is a matter of personal choice.</para></note>

      <!-- This just shows the three use cases and four actors -->

      <figure id="fig.tut.atm_use_case_diagram_basic" float="1">
        <title>Basic use case diagram for an ATM system</title>

        <screenshot><mediaobject>
            <imageobject>
              <imagedata format="GIF" align="center"
                fileref="images/tutorial/atm_use_case_diagram_basic.gif"/>
            </imageobject>
          </mediaobject></screenshot>
      </figure>

      <para>The following sections show how the basic use case diagram can be
        extended to show additional information about the system being
        designed.</para>

      <!-- Showing navigation on associations -->

      <sect3>
        <title>Active and Passive Actors</title>

        <indexterm>
          <primary>Active Actor</primary>
        </indexterm>

        <para><emphasis>Active</emphasis> actors initiate interaction with
          the system. This can be shown by placing an arrow on the
          association from the actor pointing toward the use case. In the
          ATM example, the customer is an active actor.</para>

        <indexterm>
          <primary>Passive Actor</primary>
        </indexterm>

        <para>Interaction with <emphasis>passive</emphasis> actors is
          initiated by the system. This can be shown by placing an arrow on
          the association from the use case pointing toward the actor. In
          the ATM example, the central computer is a passive actor.</para>

        <para>This is a good example where the arrow helps, since it allows
          us to distinguish an event driven system (the ATM initiates
          interaction with the central computer) from a polling system (the
          central computer interrogates the ATM from time to time).</para>

        <para>Where an actor may be either active or passive, depending on
          circumstances, the arrow may be omitted. In the ATM example the
          bank engineer fits into this category. Normally he is active,
          turning up on a regular cycle to service the machine. However if
          the ATM detects a fault, it may summon the engineer to fix
          it.</para>

        <para>The use of arrows on associations is referred to as the
          <emphasis>navigation</emphasis> of the association. We shall see
          this used elsewhere in UML later on.</para>

        <para><xref linkend="fig.tut.atm_use_case_diagram_navigation"/> shows
          the ATM use case diagram with navigation displayed.</para>

        <!-- This adds navigation to the diagram -->

        <figure id="fig.tut.atm_use_case_diagram_navigation" float="1">
          <title>Use case diagram for an ATM system showing
            navigation.</title>

          <screenshot><mediaobject>
              <imageobject>
                <imagedata format="GIF" align="center"
                  fileref="images/tutorial/atm_use_case_diagram_navigation.gif"/>
              </imageobject>
            </mediaobject></screenshot>
        </figure>
      </sect3>

      <!-- Multiplicity -->

      <sect3>
        <title>Multiplicity</title>

        <indexterm>
          <primary>Multiplicity</primary>
          <secondary>in a Use Case Diagram</secondary>
        </indexterm>

        <para>It can be useful to show the <emphasis>multiplicity</emphasis> of
          associations between actors and use cases. By this we mean how many
          instances of an actor interact with how many instances of the use
          case.</para>

        <para>By default we assume one instance of an actor interacts with one
          instance of a use case. In other cases we can label the multiplicity
          of one end of the association, either with a number to indicate how
          many instances are involved, or with a range separated by two periods
          (<literal>..</literal>). An asterisk (<literal>*</literal>) is used
          to indicate an arbitrary number.</para>

        <para>In the ATM example, there is only one central computer, but it
          may be auditing any number of ATM uses. So we place the label
          <literal>0..*</literal> at the use case end. There is no need for a
          label at the other end, since the default is one.</para>

        <para>A local bank will have up to three officials authorized to unload
          and load ATM machines. So at the actor end of the relationship with
          the use case <literal>Maintain ATM</literal>, we place the label
          <literal>1..3</literal>. They may be dealing with any number of ATM
          machines, so at the other end we place the label
          <literal>0..*</literal>.</para>

        <para>There may be any number of customers and there may be any number
          of ATM systems they could use. So at each end of the association we
          place the label <literal>0..*</literal>.</para>

        <para><xref linkend="fig.tut.atm_use_case_diagram_multiplicity"/> shows
          the ATM use case diagram with multiplicity displayed.</para>

        <!-- This adds multiplicity to the diagram -->

        <figure id="fig.tut.atm_use_case_diagram_multiplicity" float="1">
          <title>Use case diagram for an ATM system showing
            multiplicity.</title>

          <screenshot><mediaobject>
              <imageobject>
                <imagedata format="GIF" align="center"
                  fileref="images/tutorial/atm_use_case_diagram_multiplicity.gif"/>
              </imageobject>
            </mediaobject></screenshot>
        </figure>

        <para>Multiplicity can clutter a diagram, and is often not shown,
          except where it is critical to understanding. In the ATM example we
          would only choose to show <literal>1..3</literal> against the local
          bank official, since all others are obvious from the context.</para>
      </sect3>

      <!-- Use of includes, extends and generalization -->

      <sect3>
        <title>Hierarchies of Use Cases</title>

        <indexterm>
          <primary>Hierarchy of Use Cases</primary>
        </indexterm>
        <indexterm>
          <primary>Use Case</primary>
          <secondary>Hierarchy</secondary>
        </indexterm>

        <para>In our ATM example so far we have just three use cases to
          describe all the behavior of the system. While use cases should
          always describe a significant chunk of system behavior, if they are
          too general they can be difficult to describe.</para>

        <para>We could for example define the behavior of the use case
          <quote>Use ATM</quote> in terms of the behavior of three simpler
          use cases, <quote>Deposit Cash</quote>, <quote>Withdraw
          Cash</quote> and <quote>Query Account</quote>. The main use case
          could be specified by <emphasis>including</emphasis> the behavior
          of the subsidiary use cases where needed.</para>

        <para>Similarly the <quote>Maintain ATM</quote> use case could be
          defined in terms of two use cases <quote>Maintain Equipment</quote>
          and <quote>Reload ATM</quote>. In this case the two actors involved
          in the main use case are really only involved in one or other of
          the two subsidiary use cases and this can be shown on the
          diagram.</para>

        <indexterm>
          <primary>Include Relationship</primary>
        </indexterm>
        <indexterm>
          <primary>Relationship</primary>
          <secondary>Include</secondary>
        </indexterm>

        <para>The decomposition of a use case into simpler sub-use cases is
          shown in UML by using an <emphasis>include relationship</emphasis>,
          a dotted arrow from the main use case to the subsidiary, with the
          label <emphasis>&laquo;include&raquo;</emphasis>.</para>

        <!-- Show include on the diagram -->

        <figure id="fig.tut.atm_use_case_diagram_include" float="1">
          <title>Use case diagram for an ATM system showing
            include relationships.</title>

          <screenshot><mediaobject>
              <imageobject>
                <imagedata format="GIF" align="center"
                  fileref="images/tutorial/atm_use_case_diagram_include.gif"/>
              </imageobject>
            </mediaobject></screenshot>
        </figure>

        <para>Include relationships are fine for breaking down the use case
          behaviors in to hierarchies. However we may also want to show a use
          case that is an <emphasis>extension</emphasis> to an existing
          use case to cater for a particular circumstance.</para>

        <para>In the ATM example we have a use case covering routine
          maintenance of the ATM, <quote>Maintain Equipment</quote>. We also
          want to cover the special case of an unscheduled repair caused by
          the ATM detecting an internal fault.</para>

        <indexterm>
          <primary>Extend Relationship</primary>
        </indexterm>
        <indexterm>
          <primary>Relationship</primary>
          <secondary>Extend</secondary>
        </indexterm>

        <para>This is shown in UML by the <emphasis>extend</emphasis>
          relationship. In the main use case, we specify a name for a
          location in the description, where an extension to the behavior
          could be attached. The name and location are shown in a
          separate compartment within the use case oval. The representation
          extend relationship is the same as the include relationship, but
          with the label <emphasis>&laquo;extend&raquo;</emphasis>. Alongside
          the extend relationship, we specify the condition under which that
          behavior will be attached.</para>

        <para><xref linkend="fig.tut.atm_use_case_diagram_extend"/> shows
          the ATM use case diagram with an extend relationship to a use case
          for unscheduled repairs. The diagram is now getting rather
          complex, and so we have split it into two, one for the maintenance
          side of things, the other for customer usage and audit.</para>

        <para>The <quote>Maintain Equipment</quote> use case defines a name
          <quote>Unsched</quote>, at the start of its description. The
          extending use case <quote>Unscheduled Repair</quote> is attached
          there when the ATM detects an internal error.</para>

        <!-- This adds navigation to the diagram -->

        <figure id="fig.tut.atm_use_case_diagram_extend" float="1">
          <title>Use case diagram for an ATM system showing an extend
            relationship.</title>

          <screenshot><mediaobject>
              <imageobject>
                <imagedata format="GIF" align="center"
                  fileref="images/tutorial/atm_use_case_diagram_extend.gif"/>
              </imageobject>
            </mediaobject></screenshot>
        </figure>

        <indexterm>
          <primary>Use Case Generalization</primary>
        </indexterm>
        <indexterm>
          <primary>Use Case Specialization</primary>
        </indexterm>
        <indexterm>
          <primary>Generalize a Use Case</primary>
        </indexterm>
        <indexterm>
          <primary>Specializations</primary>
          <secondary>of Use Case</secondary>
        </indexterm>

        <para>Use cases may be linked together in one other way. One use case
          may be a <emphasis>generalization</emphasis> of a subsidiary use
          case (or alternatively the subsidiary is a
          <emphasis>specialization</emphasis> of the main use case).</para>

        <para>This is very like the extends relationship, but without the
          constraint of specific extension points at which the main use case
          may be extended, and with no condition on when the subsidiary use
          case may be used.</para>

        <para>Generalization is shown on a use case diagram by an arrow with
          solid line and solid white head from the subsidiary to the main use
          case.</para>

        <para>This may be useful when a subsidiary use case specializes the
          behavior of the main use case at a large number of positions and
          under a wide range of circumstances.</para>

        <para>However the lack of any restriction makes generalization very
          hard to specify precisely. In general use an extend relationship
          instead.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>The Use Case Specification</title>

      <indexterm>
        <primary>Use Case Specification</primary>
      </indexterm>
      <indexterm>
        <primary>Specification</primary>
        <secondary>of Use Case</secondary>
      </indexterm>
      <indexterm>
        <primary>Use Case Scenario</primary>
      </indexterm>

      <para>Each use case must be documented to explain in detail the
        behavior it is specifying. This document is known by different names
        in different processes: <emphasis>use case
        specification</emphasis>,<emphasis> use case scenario</emphasis> or
        even (confusingly) just <emphasis>use case</emphasis>.</para>

      <para>A typical use case will include the following sections.</para>

      <itemizedlist>
        <listitem>
          <indexterm>
            <primary>Name</primary>
            <secondary>of Use Case</secondary>
          </indexterm>
          <indexterm>
            <primary>Use Case Name</primary>
          </indexterm>

          <para><emphasis>Name</emphasis>. 

The name of the use case to which this relates.
</para>
        </listitem>

        <listitem>
          <indexterm>
            <primary>Goal</primary>
            <secondary>of Use Case</secondary>
          </indexterm>
          <indexterm>
            <primary>Use Case Goal</primary>
          </indexterm>
          <para><emphasis>Goal</emphasis>.

A one or two line summary of what this use case achieves <emphasis>for
its actors</emphasis>.
</para>
        </listitem>

        <listitem><para><emphasis>Actors</emphasis>. The actors involved in
          this use case, and any context regarding their involvement.</para>

        <note><para>This should not be a description of the actor. That
          should be associated with the actor on the use case
          diagram.</para></note></listitem>

        <listitem>
          <indexterm>
            <primary>Pre-condition</primary>
            <secondary>of Use Case</secondary>
          </indexterm>
          <indexterm>
            <primary>Pre-assumptions</primary>
            <secondary>of Use Case</secondary>
          </indexterm>
          <indexterm>
            <primary>Use Case Pre-condition</primary>
          </indexterm>

          <para><emphasis>Pre-condition</emphasis>.

These would be better named <quote>pre-assumptions</quote>, but the
term used everywhere is pre-conditions.

This is a statement of any simplifying assumptions we can make at the
start of the use case.
</para>

        <para>In the ATM example we might make the assumption for the<quote>
          Maintain Equipment</quote> use case that an engineer is always
          available, and we do not need to worry about the case where a
          routine maintenance visit is missed.</para>

        <caution><para>Avoid pre-conditions wherever possible. You need to be
          absolutely certain that the pre-condition holds under all possible
          circumstances. If not your system will be under specified and hence
          will fail when the pre-condition is not true. Alternatively, when
          you cannot be certain the pre-condition is always true, you will
          need to specify a second use case to handle the pre-condition being
false.
In the first case, pre-conditions are a source of
          problems, in the second a source of more
          work.</para></caution></listitem>

        <listitem>
          <indexterm>
            <primary>Basic Flow</primary>
            <secondary>of Use Case</secondary>
          </indexterm>
          <indexterm>
            <primary>Use Case</primary>
            <secondary>Basic Flow</secondary>
          </indexterm>
          <indexterm>
            <primary>Scenario</primary>
          </indexterm>

          <para><emphasis>Basic Flow</emphasis>.

The linear sequence of steps that describe the behavior of the use
case in the <quote>normal</quote> scenario.

Where a use case has a number of scenarios that could be normal, one
is arbitrarily selected.

Specifying the basic flow is described in more detail in
<xref linkend="s3.tut.basic_flow"/> below.
</para>
        </listitem>

        <listitem>
          <indexterm>
            <primary>Alternate Flows</primary>
            <secondary>of Use Case</secondary>
          </indexterm>
          <indexterm>
            <primary>Use Case</primary>
            <secondary>Alternate Flows</secondary>
          </indexterm>

          <para><emphasis>Alternate Flows</emphasis>.

A series of linear sequences describing each of the alternative
behaviors to the basic flow.

Specifying alternate flows is described in more detail in
<xref linkend="s3.tut.alternate_flows"/>.
</para>
        </listitem>

        <listitem>
          <indexterm>
            <primary>Post-conditions</primary>
            <secondary>of Use Case</secondary>
          </indexterm>
          <indexterm>
            <primary>Post-assumptions</primary>
            <secondary>of Use Case</secondary>
          </indexterm>
          <indexterm>
            <primary>Use Case Post-conditions</primary>
          </indexterm>

          <para><emphasis>Post-conditions</emphasis>. 

These would be better named <quote>post-assumptions</quote>.

This is a statement of any assumptions that we can make at the end of
the use case.

Most useful where the use case is one of a series of subsidiary use
cases that are included in a main use case, where they can form the
pre-conditions of the next use case to be included.
</para>

        <caution><para>Like pre-conditions, post-conditions are best
          avoided. They place a burden on the specification of the use case
          flows, to ensure that the post-condition always holds. They
          therefore are also a source of problems and extra
          work.</para></caution></listitem>

        <listitem><para><emphasis>Requirements</emphasis>. In an ideal world
          the vision document, use case diagrams, use case specifications and
          supplementary requirements specification would form the
          requirements for a project.</para>

        <para>For most market-led developments, where ownership of requirements
          is within the same business as the team who will do the development,
          this is now usually the case. The marketing department can learn use
          case based requirements capture and analysis to link to their
          customer facing activities.</para>

        <para>However for external contract developments, customers may
          insist on a traditional <quote>list of features</quote> as the
          basis of the contract. Where this is the case, this section of the
          use case specification should link to the contract features that
          are covered by the use case.</para>
          
        <para>This is often done through a third party tool that can link
          documents, providing automated checking of coverage, in which case
          this section is not needed, or may be generated
          automatically.</para></listitem>
      </itemizedlist>

      <para>The final size of the use case specification will depend on the
        complexity of the use case. As a rule of thumb, most use cases take
        around 10-15 pages to specify, the bulk of which is alternate
        flows. If you are much larger than this, consider breaking the use
        case down. If you are much smaller consider whether the use case is
        addressing too small a chunk of behavior.</para>

      <!-- More detail on the basic flow -->

      <sect3 id="s3.tut.basic_flow">
        <title>Specifying the Basic Flow</title>

        <indexterm>
          <primary>Basic Flow</primary>
          <secondary>of Use Case</secondary>
        </indexterm>
        <indexterm>
          <primary>Use Case</primary>
          <secondary>Basic Flow</secondary>
        </indexterm>

        <para>All flows in a use case specification are linear&mdash;that is
          there is no conditional branching. Any choices in flows are handled
          by specifying another alternate flow that takes over at the choice
          point. It is important to remember we are specifying behavior here,
          not programming it.</para>

        <para>A flow is specified as a series of numbered steps. Each step
          must involve some interaction with an actor, or at least generate a
          change that is observable externally by an actor. Requirements
          capture should not be specifying hidden internal behavior of a
          system.</para>

        <para>For example we might give the following sequence of steps for
          the basic flow of the use case "Withdraw Cash" in our ATM
          example.</para>

        <orderedlist>
          <listitem><para>Customer indicates a receipt is
            required.</para></listitem>

          <listitem><para>Customer enters amount of cash
            required.</para></listitem>

          <listitem><para>ATM verifies with the central computer that the
            customer can make this withdrawal.</para></listitem>

          <listitem><para>ATM dispenses cash to the
            customer.</para></listitem>

          <listitem><para>ATM issues receipt to customer.</para></listitem>
        </orderedlist>

        <para>Remember this is a sub-use case included in the main <quote>Use
          ATM</quote> use case, which will presumably handle checking of
          cards and PINs before invoking this included use case.</para>

        <note><para>The first step is not a condition. We take as our basic
          flow the case where the customer does want a receipt. The case
          where the customer does not want a receipt will be an alternative
          flow.</para></note>
      </sect3>

      <!-- More detail on the alternate flows -->

      <sect3 id="s3.tut.alternate_flows">
        <title>Specifying the Alternate Flows</title>

        <indexterm>
          <primary>Alternate Flows</primary>
          <secondary>of Use Case</secondary>
        </indexterm>
        <indexterm>
          <primary>Use Case</primary>
          <secondary>Alternate Flows</secondary>
        </indexterm>
        <indexterm>
          <primary>Alternative scenarios</primary>
        </indexterm>

        <para>This captures the alternative scenarios, as linear flows, by
          reference to the basic flow. Initially we just build a list of the
          alternate flows.</para>

        <orderedlist numeration="upperalpha" inheritnum="inherit">
          <listitem><orderedlist numeration="arabic" inheritnum="inherit">
            <listitem><para>Customer does not require a
              receipt.</para></listitem>

            <listitem><para>Customer's account will not support the
              withdrawal.</para></listitem>

            <listitem><para>Communication to the central computer is
              down.</para></listitem>

            <listitem><para>The customer cancels the
              transaction.</para></listitem>

            <listitem><para>The customer fails to take the dispensed
              cash.</para></listitem>
        </orderedlist></listitem></orderedlist>

        <para>Subsequently we flesh out each alternate flow, by reference to
          the basic flow. For example the first alternate flow might look
          like.</para>

        <orderedlist numeration="upperalpha" inheritnum="inherit">
          <listitem><orderedlist numeration="arabic" inheritnum="inherit">
            <listitem><para>Customer does not require a
              receipt.</para>

            <orderedlist numeration="arabic" inheritnum="inherit">
              <listitem><para>At step 1 of the basic flow the customer
                indicates they do not want a receipt.</para></listitem>

              <listitem><para>The basic flow proceeds from step 2 to step 4,
                and step 5 is not used.</para></listitem>
            </orderedlist></listitem>
        </orderedlist></listitem></orderedlist>

        <para>The convention is to number the various alternate flows as A.1,
          A.2, A.3, etc. The steps within an alternate flow are then numbered
          from this. So the steps of the first alternate flow would be A.1.1,
          A.1.2, A.1.3, etc.</para>
      </sect3>

      <!-- How does this fit into iterative development -->

      <sect3>
        <title>Iterative Development of Use Case Specifications</title>

        <para>Iterative development will prioritize the use cases, and the
          first iterations will address the most important.</para>

        <para>Early iterations will capture the basic flows of the most
          important use cases with only essential detail and list the
          headings of the main alternate flows.</para>

        <para>Later iterations will address the remaining use cases, flesh
          out the steps on individual alternate flows and possibly provide
          more detail on individual steps.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Supplementary Requirement Specification</title>

      <indexterm>
        <primary>Supplementary Requirement Specification</primary>
      </indexterm>
      <indexterm>
        <primary>Non-functional requirements</primary>
      </indexterm>
      <indexterm>
        <primary>Non-functional constraints</primary>
      </indexterm>

      <para>This captures the non-functional requirements or constraints placed
        on the system. Since use cases are inherently functional in nature,
        they cannot capture this sort of information.</para>

      <note><para>Some analysts like to place non-functional requirements in a
        section at the end of each use case specification, containing the
        non-functional requirements relevant to the use case.</para>

      <para>I don't like this for two reasons. First key non-functional
        requirements (for example about performance) may need to appear in many
        use cases and it is bad practice to replicate information. Secondly
        there are invariably some non-functional requirements that are system
        wide and need a system wide document. Hence my preference for a single
        supplementary requirements specification.</para></note>

      <para>There should be a section for each of the main areas of
non-functional requirements.
The checklist provided by Ian Sommerville
        in his book <emphasis>Software Engineering</emphasis> (Third Edn,
        Addison-Wesley, 1989) is a useful guide.</para>

      <itemizedlist>
        <listitem><para><emphasis>Speed</emphasis>. Processor performance,
          user/event response times, screen refresh time.</para></listitem>

        <listitem><para><emphasis>Size</emphasis>. Main memory (and possibly
          caches), disc capacity.</para></listitem>

        <listitem><para><emphasis>Ease of use</emphasis>. Training time, style
          and detail of help system.</para></listitem>

        <listitem><para><emphasis>Reliability</emphasis>. Mean time to failure,
          probability of unavailability, rate of failure,
          availability.</para></listitem>

        <listitem><para><emphasis>Robustness</emphasis>. Time to restart after
          failure, percentage of events causing failure, probability of data
          corruption on failure.</para></listitem>

        <listitem><para><emphasis>Portability</emphasis>. Percentage of
          target-dependent code/classes, number of target
          systems.</para></listitem>
      </itemizedlist>

      <para>To this we should add sections on environment (temperature,
        humidity, lightening protection status) and standards
        compliance.</para>
    </sect2>
  </sect1>

  <!-- Now show how to do in in Argo/UML. -->

  <sect1 id="s1.argo_use_cases">
    <title>Using Use Cases in &argouml;</title>

    <para>&argouml; allows you to draw use case diagrams. When you create a new
      project it has a use case diagram created by default, named <literal>use
      case diagram 1</literal>. Select this by &button1; click on the diagram
      name in the explorer (the upper left quadrant of the user
      screen).</para>

    <para>New use case diagrams can be created as needed through
<literal>Create Diagram</literal> on the main menu bar or 
on the Create Diagram Toolbar. 
They are edited
      in the editing pane (the upper right quadrant of the user screen).</para>

    <sect2>
      <title>Actors</title>

      <indexterm>
        <primary>Create New</primary>
        <secondary>Actor</secondary>
      </indexterm>
      <indexterm>
        <primary>Actor</primary>
      </indexterm>

      <para>To add an actor to the diagram use &button1; click on the actor
        icon on the editing pane toolbar
        (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
        align="center" fileref="images/icons/actor.gif"/>
        </imageobject></inlinemediaobject></guiicon>) and then &button1; click
        at the location where you wish to place it. The actor can be moved
subsequently by &button1;
motion (i.e. &button1; down over the actor to
        select it, move to the new position and &button1; release to drop the
        actor in place.</para>

      <para>Multiple actors can be added in one go, by using &button1; double
        click on the actor icon. Each subsequent &button1; click will drop an
actor on the diagram. 
A &button1; click on the select icon
(<guiicon>
          <inlinemediaobject>
            <imageobject>
              <imagedata format="GIF" 
                align="center" 
                fileref="images/icons/select.gif"/>
            </imageobject>
          </inlinemediaobject>
</guiicon>)
will stop adding actors.
</para>

      <para>The actors name is set in its property panel. First select the
        actor (if not already selected) on the editing pane using &button1;
        click. Then click on the <literal>Properties</literal> tab in the
        details pane. The name is entered in the name field, and will appear on
        the screen.</para>

      <para>As a shortcut, double &button1; click on the name of the actor in
        the editing pane (or just typing on the keyboard when an actor is
        selected) will allow the name to be edited directly. This is a
        convenient way to enter a name for a new actor.</para>

      <para>Having created the actor, you will see it appear in the explorer
        (the upper left quadrant of the user screen). This shows all the
        artifacts created within the UML design. A drop down at the top of the
        explorer controls the ordering of artifacts in the explorer.
        The most useful are the <literal>Package-centric</literal>
        (default) and <literal>Diagram-centric</literal>. The latter shows
        artifacts grouped by the diagram on which they appear.</para>
    </sect2>

    <sect2>
      <title>Use Cases</title>

      <indexterm>
        <primary>Create New</primary>
        <secondary>Use Case</secondary>
      </indexterm>
      <indexterm>
        <primary>Use Case</primary>
      </indexterm>

      <para>The procedure for adding use cases is the same as that for adding
        actors, but using the use case icon on the editing pane toolbar
        (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
        align="center" fileref="images/icons/use_case.gif"/>
        </imageobject></inlinemediaobject></guiicon>).</para>

      <para>By default use cases in &argouml; do not display their extension
        points (for use in extend relationships). You can show the extension
        point compartment in one of two ways.</para>

      <orderedlist>
        <listitem><para>Select the use case in the editing pane with &button1;
          click, then select the <literal>Style</literal> tab in the details
          pane and &button1; click on the <literal>Display: Extension
          Points</literal> check box.</para></listitem>

        <listitem><para>Use &button2; click over the use case in the editing
pane to display a context-sensitive pop-up menu and from that choose
          <literal>Show/Show Extension Point
          Compartment</literal>.</para></listitem>
      </orderedlist>

      <para>The same approaches can be used to hide the extension point
        compartment.</para>

      <sect3>
        <title>Adding an Extension Point to a Use Case</title>

        <indexterm>
          <primary>Create New</primary>
          <secondary>Extension Point</secondary>
        </indexterm>
        <indexterm>
          <primary>Extension Point</primary>
        </indexterm>

        <para>There are two ways to add an extension point to a use
          case.</para>

        <orderedlist>
          <listitem><para>Select the use case on the editing pane with
            &button1; click. Then click on the <literal>Add Extension
            Point</literal> icon
            (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
            align="center" fileref="images/icons/extension_point.gif"/>
            </imageobject></inlinemediaobject></guiicon>) on the toolbar, and a
            new extension point with default name and location will be added
            after any existing extension points.</para>

          <note><para>The <literal>Add Extension Point</literal> icon is grayed
            out and unusable until a use case is
            selected.</para></note></listitem>

          <listitem><para>Select the use case on the editing pane with
            &button1; click and then select its property tab in the details
pane.
A &button2; click over the <literal>Extension Points:</literal>
field will bring up a context-sensitive pop-up menu.
Select
            <literal>Add</literal> to add a new extension point.</para>

          <para>If any extension points already exist, they will be shown in
            this field on the property tab. The new extension point will be
            inserted immediately before the entry over which the pop-up menu
            was invoked. This ordering can be changed later by using the
<literal>Move Up</literal> and <literal>Move Down</literal> entries
            on the pop-up menu.</para></listitem>
        </orderedlist>

        <para>Whichever method is used, the new extension point is selected,
          and its property tab can be displayed in the details pane. The name
          and location of the extension point are free text, set in the
          corresponding fields of the property tab.</para>

        <para>An existing extension point can be edited from its property
          tab. The property tab can be reached in two ways.</para>

        <orderedlist>
          <listitem><para>If the extension point compartment for the use case
            is displayed on the diagram, select the use case with &button1;
            click and then select the extension point with a further &button1;
            click. The property tab can then be selected in the details
            pane.</para></listitem>

          <listitem><para>Otherwise select the use case and its property tab in
the details pane. 
A &button1; click on the desired entry in the
            <literal>Extension Points</literal> field will bring up the
            property tab for the extension point in the details
            pane.</para></listitem>
        </orderedlist>

        <para>The name and location fields of the extension point may then be
          edited.</para>

        <para>As a shortcut, where the extension point compartment is
          displayed, double click on the extension point allows text to be
          typed in directly. This is parsed to set name and location for the
          extension point.</para>

        <para>Extension points may be deleted, or their ordering changed by
using the &button2; pop-up menu over the 
<literal>Extension Points</literal> field in
          the use case property tab.</para>

        <para>Having created an extension point, it will appear in the
          explorer (upper left quadrant of the user screen). Extension
          points are always shown in a sub-tree beneath their owning use
          case.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Associations</title>

      <indexterm>
        <primary>Create New</primary>
        <secondary>Association in a Use Case Diagram</secondary>
      </indexterm>
      <indexterm>
        <primary>Association</primary>
        <secondary>in a Use Case Diagram</secondary>
      </indexterm>

      <para>To join a use case to an actor on the diagram use &button1; click
        on the association icon on the editing pane toolbar
        (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
        align="center" fileref="images/icons/association.gif"/>
        </imageobject></inlinemediaobject></guiicon>).
Hold &button1; down
        at the use case, move to the actor and release &button1; (or
        alternatively start at the actor and finish at the use case).</para>

      <para>This will create a straight line between actor and use case. You
        can segment the line by holding down &button1; down on the line and
        moving before releasing. A vertex will be added to the line, which you
        can move by &button1; motion. A vertex can be removed by picking it up
        and sliding to one end of the line.</para>

      <para>Multiple associations can be added in one go, by using &button1;
        double click on the association icon. Each subsequent &button1;
        down/motion/release sequence will join an actor to a use case. Use
        &button1; on the select icon
        (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
        align="center" fileref="images/icons/select.gif"/>
        </imageobject></inlinemediaobject></guiicon>) to stop adding
        associations.</para>

      <para>It is also possible to add associations using small
        <quote>handles</quote> that appear to the left and right of a use case
        or actor when it is selected and the mouse is over it. Dragging the
        handle from a use case to an actor will create an association to that
        actor (and similarly by dragging a handle from an actor to a use
        case).</para>

      <para>Dragging a handle from a use case into empty space will create a
        new actor to go on the other end. Similarly dragging a handle from an
        actor into empty space will create a new use case.</para>

      <para>It is possible to give an association a name, describing the
        relationship of the actor to the use case, although this is not usually
        necessary. This is done through the property tab of the
        association. Such a name appears alongside the association near its
        center.</para>

      <!-- How to put arrows on the associations -->

      <sect3 id="s3.tut.req_argo_navigation">
        <title>Setting Navigation</title>
        
        <indexterm>
          <primary>Setting Navigation</primary>
          <secondary>to an association in a Use Case Diagram</secondary>
        </indexterm>
        <indexterm>
          <primary>Navigation</primary>
          <secondary>Setting</secondary>
        </indexterm>

        <para>There are two ways of setting the navigation of an
          association.</para>

        <orderedlist>
          <listitem><para>Use &button2; click on the association to bring up a
            context-sensitive pop-up menu. The <literal>Navigability</literal>
sub-menu has options for bi-directional navigation 
(the default, with no arrows) and
for navigability Actor&rarr;Use Case and Use Case&rarr;Actor.
</para>
          </listitem>

          <listitem><para>Use &button1; to select the association and select
            its property tab in the details pane. This shows a field named
            <literal>Association Ends:</literal>, with entries for each end
            labeled by the actor or use case name and its
            multiplicity. Select the end that should be at the tail of the
            arrow with &button1; click. This brings up the property tab for the
            association end. Use &button1; click to uncheck the
            <literal>Navigability</literal> box.</para>

          <note><para>This may seem counter-intuitive, but in fact associations
            by default are navigable in both directions (when no arrows are
            shown). This process is <emphasis>turning off</emphasis> navigation
            at one end, rather than turning it on at the
            other.</para></note></listitem>
        </orderedlist>

        <para>You will see it is possible to give an association end a name in
          its property tab. This name will appear at that end of the
          association, and can be used to indicate the
          <emphasis>role</emphasis> being played by an actor or use case in an
          association.</para>

        <para>For example a time management system for a business may have use
          cases for completing time sheets and for signing off time sheets. An
          employee actor may be involved in both, one as an employee, but the
          other in a role as manager.</para>
      </sect3>

      <!-- How to set multiplicity -->

      <sect3>
        <title>Setting Multiplicity</title>

        <indexterm>
          <primary>Setting Multiplicity</primary>
          <secondary>to an association in a Use Case Diagram</secondary>
        </indexterm>
        <indexterm>
          <primary>Multiplicity</primary>
          <secondary>Setting</secondary>
        </indexterm>

        <para>There are two ways of setting multiplicity at the end of an
          association.</para>

        <orderedlist>
          <listitem><para>&Button2; click over the end of an association will
cause a context-sensitive pop-up menu to appear with a sub-menu
            labeled <literal>Multiplicity</literal>. This allows you to select
            from <literal>1</literal> (the default), <literal>0..1</literal>,
            <literal>0..*</literal> and
            <literal>1..*</literal>.</para></listitem>

          <listitem><para>Bring up the property sheet for the association end
            as described for setting navigation (see the second option in <xref
            linkend="s3.tut.req_argo_navigation"/>). A drop down menu gives a
            range of multiplicity options that may be
            selected.</para></listitem>
        </orderedlist>

        <para>The second of these two approaches has a wider range of options,
          although &argouml; does not currently allow the user to set an
          arbitrary multiplicity.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Hierarchical Use Cases</title>

      <indexterm>
        <primary>Hierarchical Use Cases</primary>
      </indexterm>
      <indexterm>
        <primary>Use Case, Hierarchical</primary>
      </indexterm>

      <sect3>
        <title>Includes</title>

        <indexterm>
          <primary>Create New</primary>
          <secondary>Include Relationship in a Use Case Diagram</secondary>
        </indexterm>
        <indexterm>
          <primary>Include Relationship</primary>
          <secondary>in a Use Case Diagram</secondary>
        </indexterm>
        <indexterm>
          <primary>Relationship</primary>
          <secondary>Include</secondary>
        </indexterm>

        <para>The procedure for adding an include relationship is the same as
          that for adding an association, but using the include icon from the
          editing pane toolbar
          (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
          align="center" fileref="images/icons/include.gif"/>
          </imageobject></inlinemediaobject></guiicon>) to join two use
          cases.</para>

        <para>Since include relationships are directional the order in which
          the two ends are selected is important. The
          <emphasis>including</emphasis> (main) use case should be selected
          first (&button1; down) and the <emphasis>included</emphasis>
          (subsidiary) use case second (&button1; release).</para>

        <para>It is possible to name include relationships using the property
          tab, but this is rarely done, and will not be displayed on the use
          case diagram.</para>
      </sect3>
       
      <sect3>
        <title>Extends</title>

        <indexterm>
          <primary>Create New</primary>
          <secondary>Extend Relationship in a Use Case Diagram</secondary>
        </indexterm>
        <indexterm>
          <primary>Extend Relationship</primary>
          <secondary>in a Use Case Diagram</secondary>
        </indexterm>
        <indexterm>
          <primary>Relationship</primary>
          <secondary>Extend</secondary>
        </indexterm>

        <para>The procedure for adding an extend relationship is the same as
          that for adding an include relationship, but using the extend icon
          from the editing pane toolbar
          (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
          align="center" fileref="images/icons/extend.gif"/>
          </imageobject></inlinemediaobject></guiicon>) to join two use
          cases.</para>

        <para>As with include relationships, the order of selection matters. In
          this case, the <emphasis>extending</emphasis> (subsidiary) use case
          should be selected first (&button1; down) and the
          <emphasis>extending</emphasis> (main) use case second (&button1;
          release).</para>

        <note><para>This is the reverse of the include relationship, but
          reflects the way that designer's tend to think. The fact that the
          extend icon's arrow points upward (the opposite of the include icon)
          should help remind you of this.</para></note>

        <para>To set a condition for the extend relationship, select the extend
          relationship in the editing pane (&button1; click) and then bring up
          its property tab in the details pane ((&button1; click on the
          tab). The text of the condition may be typed in the
          <literal>Condition</literal> field. Long conditions may be split over
          several lines if desired. The condition is displayed under the
          <literal>&laquo;extend&raquo;</literal> label on the diagram.</para>

        <para>It is possible to name extend relationships using the property
          tab, but this is rarely done, and will not be displayed on the use
          case diagram.</para>
      </sect3>

      <sect3>
        <title>Generalization</title>

        <indexterm>
          <primary>Create New</primary>
          <secondary>
Generalization relationship in a Use Case Diagram
</secondary>
        </indexterm>
        <indexterm>
          <primary>Generalization Relationship</primary>
          <secondary>in a Use Case Diagram</secondary>
        </indexterm>
        <indexterm>
          <primary>Relationship</primary>
          <secondary>Generalization</secondary>
        </indexterm>

        <para>
The procedure for adding generalizations, is the same as for
          adding extend relationships, but using the generalization icon from
          the editing pane toolbar
          (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
          align="center" fileref="images/icons/generalization.gif"/>
          </imageobject></inlinemediaobject></guiicon>).</para>

        <para>Since generalization is a directed relationship, the order of
          selection matters. The specialized use case should be selected first
          (&button1; down) and the generalized second (&button1;
          release).</para>

        <para>It is also possible to add generalizations using small
          <quote>handles</quote> that appear to the top and bottom of a use
          case when it is selected. Dragging the handle at the top to another
          use case will create a generalization. The original use case is
          the specializing end, and the use case to which the handle was
          dragged will be the generalizing end. Dragging into empty space will
          create a new use case to be the generalizing end.</para>

        <para>Similarly dragging on the bottom handle will create a
          generalization in which the original use case is the
          <emphasis>generalizing</emphasis> end.</para>

        <para>Generalization is also permitted between actors, although its use
          is beyond the scope of this tutorial. Unlike use cases there are no
          generalization handles on actors, so generalizations must be created
          using the toolbar icon.</para>

        <para>
It is possible to name generalization relationships using the property
          tab, but this is rarely done. If a name is provided, it will be
          displayed on the use case diagram.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Stereotypes</title>

      <indexterm>
        <primary>Stereotype</primary>
        <secondary>in Use Case Diagrams</secondary>
      </indexterm>

      <para>UML has the concept of <emphasis>stereotyping</emphasis> as a way
        of extending the basic notation. It may prove useful for example to
        model a problem at both the business level and the engineering
        level. For both of these we will need use cases, but the use cases at
        the business level hold a different sort of information to those at the
        engineering level. Very likely they use different language and notation
        in their underlying use case specifications.</para>

      <para><emphasis>Stereotypes</emphasis> are used to label UML artifacts
        such as use cases, to indicate that they belong to a certain
        category. Such labels are shown in guillemots
        (<literal>&laquo;&raquo;</literal>) above the name of the artifact on
        the diagram. The UML standard defines a number of standard stereotypes,
and the user may define more stereotypes of his own.
</para>

      <para>You will see that &argouml; has a drop down selector,
        <literal>Stereotype</literal> on every property tab. This is populated
        with the standard stereotypes, to which you may add your own user
        defined ones.</para>

      <para>
The details of stereotyping are beyond the scope of this
        tutorial. The reference manual (see <xref
        linkend="s1.ref.stereotype"/>) documents the support provided in
        &argouml;.</para>

      <warning><para>&argouml; is missing a few of the standard UML
        stereotypes. In addition not all artifacts will actually display the
        stereotype on the diagram. At present this includes use cases and
        actors.</para></warning>
    </sect2>

    <sect2>
      <title>Documentation</title>

      <indexterm>
        <primary>Documentation in Use Case Diagrams</primary>
      </indexterm>

      <para>&argouml; has some simple documentation facilities associated with
        artifacts on a diagram. In general these should be used only to record
        the location of material in documents that can be handled by a
        mainstream editor or word processor, not the actual documentation
        itself.</para>

      <para>Documentation for a particular artifact is recorded through the
        documentation tab in the details pane (the quadrant of the user screen
        at the bottom right).</para>

      <para>In addition annotation may be added to diagrams using the text icon
        on the editing pane toolbar
        (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
        align="center" fileref="images/icons/text.gif"/>
        </imageobject></inlinemediaobject></guiicon>).</para>

      <para>The recommendation is that a use case diagram should use the
        documentation tab of actors to record information about the actor, or
        if the actor is complex to refer to a separate document that holds
        information about the actor.</para>

      <para>The documentation tab of use cases should record the location of
        the use case specification. The information in a use case specification
        (for all but the simplest use cases) is too complex to be placed
        directly in the tab.</para>

      <para>The project should also have a separate vision document and
        supplementary requirements specification. A text annotation on diagrams
        may be used to refer to these if the user finds this helpful.</para>

      <!-- This is issue ??? --> 
      <warning><para>The documentation tab includes a
<literal>Deprecated</literal> check box.
The state of this flag is not
        preserved over save and load in the current release of
        &argouml;</para></warning>
    </sect2>

    <!-- How to add other annotation -->

    <sect2>
      <title>System Boundary Box</title>

      <indexterm>
        <primary>System Boundary Box in Use Case Diagram</primary>
      </indexterm>

      <para>&argouml; provides a series of tools to provide arbitrary graphical
        annotation on diagrams (we have already mentioned the text tool). These
        are found at the right hand end of the editing pane toolbar and are
        fully documented in the reference manual (see <xref
        linkend="ch.ref.editpane"/>).</para>

      <para>The rectangle tool can be used to draw the boundary box. Use the
&button2; context-sensitive <literal>Ordering</literal> pop-up menu to
        place it behind everything else. However there is no way to change its
        fill color from the default white. You may therefore prefer to draw
        the boundary box as four lines. This is the method used for the
        diagrams in this chapter.</para>

      <note><para>The editing pane in &argouml; has a grid to which objects
        snap to aid in drawing. The size of this grid and its effect may be
        altered through the <literal>View</literal> menu (using <literal>Adjust
        Grid</literal> and <literal>Adjust Grid Snap</literal>). This is
        described fully in the reference manual (see <xref
        linkend="ch.ref.menu"/>).</para></note>
    </sect2>
  </sect1>

  <!-- The Case Study will show at least some of these features -->

  <sect1>
    <title>Case Study</title>

    <sect2>
      <title>Vision Document</title>

      <indexterm>
        <primary>Vision Document</primary>
        <secondary>Case Study</secondary>
      </indexterm>

      <para>
A vision document contains more than those things needed for
the modeling effort.
It also contains financial and scheduling pertinent information.
The following sections are those parts of the Vision Document
spelled out in
<xref linkend="s2.tut.vision_document"/> above.
In practice this format need not be followed religiously, but
is used here for consistency.
</para>

      <sect3>
        <title>Summary</title>
        <para>
The company wishes to produce and market a line of ATM devices.
The purpose of this project is to produce the hardware and
the software to drive it that are both maintainable and robust.
</para>
      </sect3>

      <sect3>
        <title>Goals</title>
        <para>
To produce better designed products based on newer
technology.
Follow the MDA philosophy of the OMG by producing first
a Platform Independent Model (PIM).
As current modeling technology does not admit of
maintaining the integrity of the connection between the 
PIM and Platform Specific Models (PSMs), the PIM will
become comparatively stable before the first iteration of
the PSM is produced.
The software platform will be Java technology.
The system will use a simple userid (from ATM card) and
password (or PIN) mechanism.
</para>
      </sect3>

      <sect3>
        <title>Market Context</title>
        <para>
Equipment currently on the market is based on older
technology for both hardware and software.
This technology has not reached the end of its
useful life, making it unlikely that the vendors of that
gear are going to update it in the near future.
On the other hand newer technology is available
that would put us at a competitive advantage if implemented
now.
</para>
      </sect3>

      <sect3>
        <title>Stakeholders</title>

        <para>
Among the stakeholders for this system are the Engineering
Department, the Maintenance Department, and the Central
Computer Facility.
The full list of these stakeholders and the specific
individuals representing them are.
</para>

        <itemizedlist>
          <listitem>
            <para>
<emphasis>Engineering</emphasis>. &nbsp;Bunny, Bugs
</para>
          </listitem>
          <listitem>
            <para>
<emphasis>Maintenance</emphasis>. &nbsp;Hardy, Oliver
</para>
          </listitem>
          <listitem>
            <para>
<emphasis>Computer Facility</emphasis>. &nbsp;Laurel, Stanley
            </para>
          </listitem>
          <listitem>
            <para>
<emphasis>Chief Executive Officer</emphasis>. &nbsp;Hun, Atilla The
            </para>
          </listitem>
          <listitem>
            <para>
<emphasis>Marketing</emphasis>. &nbsp;Harry, Oil Can
            </para>
          </listitem>
        </itemizedlist>

      </sect3>

      <sect3>
        <title>Key Features</title>

        <para>
Cash deposit, cash withdrawal, and account inquiries by
customers.
Customers include people who have accounts at the owning
bank as well as people who wish to make withdrawals from
accounts in other banks or from credit card accounts.
</para>

        <para>
Maintenance of the equipment by the bank's engineers.
This action may be initiated by the engineer on a routine
basis.
It may also be initiated by the equipment that can call
the engineer when it detects an internal fault.
</para>

        <para>
Unloading of deposits and loading of cash by officials
of the local bank branch.
These actions occur either on a scheduled basis or when the
central computer determines that the cash supply is low or
the deposit receptacle is liable to be getting full.
</para>

        <para>
An audit trail for all activities will be maintained and
sent periodically to the bank's central computer.
It will be possible for the maintenance engineer to save 
a copy of the audit trail to a diskette for transporting to
the central computer.
        </para>

        <para>
Both dialup and leased line support will be provided.
The ATM will continue to provide services to customers when
communications with the central computer is not available.
</para>

      </sect3>

      <sect3>
        <title>Constraints</title>
        <para>
The project must be completed within nine months.
It must cost no more than 1,750,000 USD excluding
production costs.
Components may be contracted out, but the basic
architecture as well as the infrastructure will be designed
in house.
Close liaison must be maintained between the software
development and the design, development and production of
the hardware.
Neither the hardware nor the software shall be considered
the independent variable, but rather they shall be
considered equal.
</para>
      </sect3>

      <sect3>
        <title>Appendix</title>

        <para>
The following are the actors that directly support this
vision.
Additional actors may be identified later that are needed
to support this or that technology.
They should not be added to this list unless they are
deemed to directly support the vision as described in this
document.
</para>

        <itemizedlist>
          <listitem><para>Central Computer</para></listitem>
          <listitem><para>Customer</para></listitem>
          <listitem><para>Local Branch Official</para></listitem>
          <listitem><para>Maintenance Engineer</para></listitem>
        </itemizedlist>

        <para>
The following are the use cases that directly support this vision.
Additional use cases may be identified later that are
needed to support this or that technology or to support the
use cases listed here.
They should not be added to this list unless they are
deemed to directly support the vision as described in this
document.
</para>

        <itemizedlist>
          <listitem><para>Audit</para></listitem>
          <listitem><para>Customer Uses Machine</para></listitem>
          <listitem><para>Maintain Machine</para></listitem>
        </itemizedlist>

      </sect3>

    </sect2>

    <sect2>
      <title>Identifying Actors and Use Cases</title>
      
      <para> For the ATM case study, we will elaborate on the examples in
        <xref linkend="s1.tut.req_process_output"/>,
        <xref linkend="fig.tut.atm_use_case_diagram_include"/> 
        and <xref linkend="fig.tut.atm_use_case_diagram_extend"/>, 
        and progress to identify additional
        actors and use cases that comprise our model of the ATM system. 
        <xref linkend="fig.tut.atm_use_case_diagram_include"/> and 
        <xref linkend="fig.tut.atm_use_case_diagram_extend"/> 
        exemplified the essential concepts and components of a use
        case diagram such as, use cases, actors, multiplicity, and include /
        extend relationships. They showed the relationships between the actors and
        use cases, and demonstrated how these actors and use cases interact.
      </para>
      <para>In <xref linkend="fig.tut.atm_use_case_diagram_include"/> 
        we see a use case diagram for an ATM system consisting of
        &laquo;include&raquo; relationships for the use cases, Maintain ATM and Use ATM.
        Maintain ATM was further defined by two use cases, "Maintain Equipment" and
        "Reload ATM". Use ATM was further defined in terms of the behavior of three
        simpler use cases: "Deposit Cash", "Withdraw Cash" and "Query Account".
      </para>

      <remark>More to be written&hellip;</remark>
    </sect2>

    <sect2>
      <title>Associations (To be written)</title>

      <remark>To be written&hellip;</remark>
    </sect2>

    <sect2>
      <title>Advanced Diagram Features (To be written)</title>

      <remark>To be written&hellip;</remark>
    </sect2>

    <sect2>
      <title>Use Case Specifications (To be written)</title>

      <remark>To be written&hellip;</remark>
    </sect2>

    <sect2>
      <title>Supplementary Requirements Specification (To be written)</title>

      <remark>To be written&hellip;</remark>
    </sect2>
  </sect1>
</chapter>

<!-- Local stuff for Emacs - please do not delete

Local Variables:
mode: xml
sgml-doctype: "argomanual.xml"
sgml-parent-document: ("argomanual.xml" "chapter" nil)
sgml-validate-command: "nsgmls -wxml -sv ../docbook-setup/xml.dcl \
  argomanual.xml"
indent-tabs-mode: nil
End:

-->
