<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>5.7.&nbsp;Java - Code generations and Reverse Engineering</title><link rel="stylesheet" href="look-and-feel.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><link rel="home" href="index.html" title="Cookbook for Developers of ArgoUML"><link rel="up" href="ch05.html" title="Chapter&nbsp;5.&nbsp;Inside the components"><link rel="previous" href="ch05s06.html" title="5.6.&nbsp;Code Generation Component"><link rel="next" href="ch05s08.html" title="5.8.&nbsp;Other languages"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5.7.&nbsp;Java - Code generations and Reverse Engineering</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s06.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;5.&nbsp;Inside the components</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch05s08.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="java"></a>5.7.&nbsp;Java - Code generations and Reverse Engineering</h2></div></div><div></div></div><a class="indexterm" name="d0e5215"></a><a class="indexterm" name="d0e5220"></a><a class="indexterm" name="d0e5225"></a><a class="indexterm" name="d0e5230"></a><p>
Purpose - two purposes:
to allow the model to be converted into java code and updated either
in java or in the model;
to allow some java code to be coverted into a model.
</p><p>
The java things are located in 
<tt class="classname">org.argouml.language.java</tt>.
</p><p>
The Java component is a Layer 3 component. See <a href="ch04s07.html" title="4.7.&nbsp;Layer 3 - Description of components">Section&nbsp;4.7, &#8220;Layer 3 - Description of components&#8221;</a>.
</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="howdoi_reverse"></a>5.7.1.&nbsp;How do I ...?</h3></div></div><div></div></div><p>...</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5249"></a>5.7.2.&nbsp;Which sources are involved?</h3></div></div><div></div></div><p>
The package org.argouml.uml.reveng is supposed to hold those classes
that are common to all RE packages. At the moment this is the Import
class which is mainly responsible to recognize directories, get their
content and parse every known source file in them. These are only java
files at the moment, but there might be other languages like C++ in
the future. With this concept you could mix several languages within
a project. The DiagramInterface is used to visualize generated NSUML
metamodel objects then.
</p><p>
The package org.argouml.uml.reveng.java holds the Java specific parts
of the current RE code. C++ RE might go to org.argouml.uml.reveng.cc,
or so...
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5256"></a>5.7.3.&nbsp;How is the grammar of the target language implemented?</h3></div></div><div></div></div><p>
It's an Antlr (<a href="http://www.antlr.org" target="_top">http://www.antlr.org</a>)
grammar, based on the Antlr Java parser
example. The main difference is the missing AST (Abstract Syntax Tree)
generation and treeparser. So the original example generates an AST
(a treelike data structure) and then traverses this tree, while the
ArgoUML code parses the source file and generates NSUML objects
directly from the sources. This was done to avoid the memory usage
of an AST and the frequent GC while parsing many source files.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5264"></a>5.7.4.&nbsp;Which model/diagram elements are generated?</h3></div></div><div></div></div><p>
The *context classes hold the current context for a package, class
etc. When the required information for an object is available, the
corresponding NSUML object is created and passed to the DiagramInterface
to visualize it.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5269"></a>5.7.5.&nbsp;Which layout algorithm is used?</h3></div></div><div></div></div><p>
The classes in org.argouml.uml.diagram.static_structure.layout.* hold
the Classdiagram layout code. No layout for other diagram types yet.
It's based on a ranking scheme for classes and interfaces. The rank of
a class/interface depends on the total number of (direct or indirect)
superclasses. So if class B extends A (with rank(A)=0), then rank(B)=1.
If C extends B, then rank(C)=2 since it has 2 superclasses A,B. An
implemented interface is treated similar to a extended class. The
objects are placed in rows then, that depend on their rank.
rank(0)=1st row. rank(1) =2nd row (below the 1st one) etc. Example:
</p><div class="mediaobject"><img src="images/examples/example1.gif"></div><p>
In the next diagramm, a link goes to an object that is not in the row
above:
</p><div class="mediaobject"><img src="images/examples/example2.gif"></div><p>
In this case, insert virtual objects which are linked to the actual
target and link to them:
</p><div class="mediaobject"><img src="images/examples/example3.gif"></div><p>
The objects are sorted within their row then to minimize crossing links
between them. Compute the average value of the vertical positions of all linked
objects in the row above. Example: we have 2 ranks, 0 and 1, with 3
classes each:
</p><div class="blockquote"><blockquote class="blockquote"><p>
A B C : rank 0
</p><p>
D E F : rank 1
</p></blockquote></div><p>
We give the superclasses an index in their rank (assuming that they are
already sorted):
</p><div class="blockquote"><blockquote class="blockquote"><p>
A:0, B:1, C:2
</p></blockquote></div><p>
D, E, F have the following links (A, B, C could be interfaces, so I allow
links to multiple superclasses here):
</p><div class="blockquote"><blockquote class="blockquote"><p>
D -&gt; C
</p><p>
E -&gt; A and C
</p><p>
F -&gt; A and B
</p></blockquote></div><p>
Compute the average value of the indices:
</p><div class="blockquote"><blockquote class="blockquote"><p>
D = 2 (C has index 2 / 1 link)
</p><p>
E = 0 + 2 / 2 = 1 (A=0, C=2 divide by 2 links)
</p><p>
F = 0 + 1 / 2 = 0.5 (A=0, B=1, 2 links)
</p></blockquote></div><p>
Then sort the subclasses by that value:
</p><div class="blockquote"><blockquote class="blockquote"><p>
F(is 0.5), E(is 1), D(is 2)
</p></blockquote></div><p>
So the placement is:
</p><div class="blockquote"><blockquote class="blockquote"><p>
A B C
</p><p>
(here are the links, but I can hardly paint them as ASCIIs)
</p><p>
F E D
</p></blockquote></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s06.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch05.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch05s08.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.6.&nbsp;Code Generation Component&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;5.8.&nbsp;Other languages</td></tr></table></div></body></html>