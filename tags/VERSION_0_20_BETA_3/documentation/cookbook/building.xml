<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Id$ -->
<!--
// Copyright (c) 1996-2005 The Regents of the University of California. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies.  This software program and
// documentation are copyrighted by The Regents of the University of
// California. The software program and documentation are supplied "AS
// IS", without any accompanying services from The Regents. The Regents
// does not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason.  IN NO EVENT SHALL THE
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
-->

<chapter id="buildingandtools">
  <title>Building from source</title>
  <para>
Building ArgoUML from source requires a CVS client, a current JDK (1.4 or later),
and 150MB of free disk space.  All other tools, including the Ant build tool upon which
the build is based, are included in the project source tree.

If you have these tools and are familiar with them, the next section contains
quick instructions to build ArgoUML from source.  For more detailed directions
follow that.
</para>

  <sect1 id="quickbuild">
    <title>Quick Start</title>
    <para>
If you are using Eclipse 3.0 or later, see <xref linkend="eclipse3"></xref>
for quick setup instructions.
</para>

    <para>
If you are using Windows, the follow commands will build ArgoUML from source and
run it.  If you using Unix/Linux, the comparable commands modified slightly for
your particular shell will do work.
<programlisting>
C:\Work&gt;set CVSROOT=:pserver:guest@cvs.tigris.org:/cvs
C:\Work&gt;cvs login   (use guest as password)
C:\Work&gt;cvs checkout argouml/src argouml/src_new argouml/tools argouml/lib argouml-mdr
C:\Work&gt;set JAVA_HOME=<replaceable>C:\Programs\jdkwhatever</replaceable>
C:\Work&gt;cd argouml\src_new
C:\Work\argouml\src_new&gt;build package
C:\Work\argouml\src_new&gt;cd ..\..\argouml-mdr
C:\Work\argouml-mdr&gt;build install
C:\Work\argouml-mdr&gt;cd ..\argouml\src_new
C:\Work\argouml\src_new&gt;build run
</programlisting>
A newly compiled ArgoUML will open in a new window.
</para>
  <para>Notes:
          <tip>
           JDK 1.4 or later is required
          </tip>
          <tip>
          On Windows, the directory path for the JDK installation directory
must not contain any spaces.
<!-- MVW: This is not required, 
at least the statements above work with spaces in the path. -->
          </tip>
That was the compact version for Windows + JDK.
(Note: JDK cannot be installed in a directory that contains space in its
name. <!-- MVW: idem -->)  
Modifying these steps slightly as appropriate for your shell should
work on Unix/Linux systems as well. 
</para>
  <para>
If you don't understand these instructions or they don't work, please read the rest of 
the chapter for more detailed instructions on how to build ArgoUML.
</para>
  </sect1>

  <sect1 id="starting">
    <title>Preparations</title>
    <para>
In order to develop with ArgoUML it is absolutely mandatory to get
the CVS version of ArgoUML.
How this is done is described in
<xref endterm="cvs_checkout_term" linkend="cvs_checkout"></xref>.
</para>
    <para>
Notice that the CVS contents is not only a set of source files but
instead it is the complete development environment for
all work within the ArgoUML project.
</para>

      <sect2>
	<title>Which tools do I need to build ArgoUML?</title>
	<indexterm>
	  <primary>Building</primary>
	  <secondary>tools</secondary>
	</indexterm>
	<indexterm>
	  <primary>Tools</primary>
	  <secondary>needed for building</secondary>
	</indexterm>
	<para>
These are the tools not included in the CVS repository that
you need to work with ArgoUML.
</para>
	<itemizedlist>
	  <listitem>
	    <para>
A computer with an Internet connection and free disk space for your work.
</para>
	    <para>
100MB is enough to download everything from the repository.
(Currently March 2003 it is 68MB).
150MB is enough to download all and build the tool and the documentation.
(Currently March 2003 it is 114MB).
250MB is enough to build it all 
(Javadocs, documentation, classes, packages, ...).
</para>
	  </listitem>
	  <listitem>
	    <para>
CVS for getting the files
and committing source code updates (or an IDE with a CVS client built-in).
</para>
	  </listitem>
	  <listitem>
	    <para>
JDK, at least version 1.4.2 (includes the Java compiler)
</para>
	  </listitem>
	</itemizedlist>

    <para>
For building the documentation from DocBook format, 
you futhermore needs these tools:
</para>
    <itemizedlist>
      <listitem>
	<para>
	  <indexterm>
	    <primary>DocBook</primary>
	  </indexterm>
          <indexterm>
	    <primary>XSL style sheets</primary>
	  </indexterm>
DocBook XSL style sheets.
</para>

	<para>
There exists rules in the
<filename>argouml/documentation/build.xml</filename>
for downloading this correctly.
</para>
      </listitem>

      <listitem id="download-jimi">
	<para>
          <indexterm>
	    <primary id="download-jimi-name">Jimi</primary>
	  </indexterm>
Jimi
</para>
	<para>
Used by FOP for including PNG pictures.
</para>
	<para>
Detailed instructions:
          <orderedlist>
	    <listitem>
	      <para>
Download the file 
<filename>jimi1_0.zip</filename>
from
<ulink url="http://java.sun.com/products/jimi/">java.sun.com</ulink>.
It contains a file: 
<filename>"JimiProClasses.zip"</filename>.
</para>
	    </listitem>
	    <listitem>
	      <para>
Copy this file into the
<filename>argouml\tools\lib</filename> directory.
</para>
	    </listitem>
	  </orderedlist>
</para>
      </listitem>
    </itemizedlist>
      </sect2>
      <sect2>
	<title>
Which tools are part of the ArgoUML development environment?
</title>
	<indexterm>
	  <primary>Tools</primary>
	  <secondary>used</secondary>
	</indexterm>
	<para>
These tools are provided by the development environment that you
get when you check out from CVS.
</para>
	<itemizedlist>
	  <listitem>
	    <para>
	    <indexterm>
	      <primary>Ant</primary>
	    </indexterm>
Ant, the tool to manage compiling and packaging.
</para>
	  </listitem>
	  <listitem>
	    <para>
mdrant, the integration allowing to run mdr from ant.
</para>
	</listitem>

	  <listitem>
	    <para>
	    <indexterm>
	      <primary>ANTLR</primary>
	    </indexterm>
ANTLR, for regenerating the built-in parser.
</para>
	  </listitem>
	  <listitem>
	    <para>
	    <indexterm>
	      <primary>JUnit</primary>
	    </indexterm>
JUnit, for running the JUnit test cases.
</para>
	  </listitem>
	  <listitem>
	    <para>
	    <indexterm>
	      <primary>JDepend</primary>
	    </indexterm>
JDepend, for examining the code.
</para>
	  </listitem>
	</itemizedlist>
	<para>
For building the documentation from DocBook format, 
these tools are also provided with the development environment that
you get when you check out from CVS.
</para>
	<itemizedlist>
	  <listitem>
	    <para>
Saxon for building documentation from DocBook format.
</para>
	  </listitem>
	  <listitem>
	    <para>
	    <indexterm>
	      <primary>fop</primary>
	    </indexterm>
fop for generating PDF versions of the DocBook format.
</para>
	    <para>
To build a PDF file with the pictures included you need Jimi
that is downloaded separately.
See 
<xref linkend="download-jimi" endterm="download-jimi-name"/>.
</para>
	  </listitem>
	</itemizedlist>
      </sect2>
      <sect2>
	<title>What libraries are needed and used by ArgoUML?</title>
	<para>
These libraries are provided in the development environment that
you get when you check out CVS.
They are checked by the Java compiler when compiling, 
needed for running ArgoUML and therefore distributed with ArgoUML.
</para>
	<itemizedlist>
	  <listitem>
	    <para>
	    <indexterm>
	      <primary>NSUML</primary>
	    </indexterm>
NSUML, the Novosoft UML library.
</para>
	    <para>
The ArgoUML project doesn't develop the Java classes for 
storing, saving and loading an UML Model.
That work is done by NSUML and is used by ArgoUML.
</para>
<!--
	    <para>
See <xref linkend="nsuml"/> for some reading tips on how to learn
the insides of NSUML.
</para>
-->
	  </listitem>

	  <listitem>
	    <para>
	    <indexterm>
	      <primary>GEF</primary>
	    </indexterm>

GEF graph editing framework, available from 
<ulink url="http://gef.tigris.org">gef.tigris.org</ulink>.
</para>
	    <para>
It is also recommended that you check out GEF at the same time as you
check out ArgoUML because many things in Argo relate to GEF and it is
quite handy to have the source code available.
GEF is also residing at Tigris so you can do a simple
<command>cvs <replaceable>-d :user@cvs.tigris.org:/cvs</replaceable> co gef</command>
(with the same checkout arguments you had when you checked out ArgoUML)
to get it.
</para>
	  </listitem>

	  <listitem>
	    <para>
The OCL package to parse and run the Object Constraint Language things.
</para>
	    <para>
Details about the package are available from SourceForge
<ulink url="http://dresden-ocl.sourceforge.net/">OCL Compiler</ulink>.
</para>
	  </listitem>

	  <listitem>
	    <para>
	    <indexterm>
	      <primary>log4j</primary>
	    </indexterm>
log4j, a library with infrastructure for logs.
</para>
	  </listitem>

	  <listitem>
	    <para>
antlrall, the run-time part of the ANTLR tool.
</para>
	  </listitem>



	<listitem>
	  <para>
MDR, 
the Netbeans Meta Data Repository.
</para>
	  <para>
This is included in the files
jmi.jar, jmiutils.jar, mdrapi.jar, mof.jar, nbmdr.jar, openide-util.jar
from the argouml-mdr subproject.
</para>
	</listitem>
	</itemizedlist>
      </sect2>

 </sect1>
    <sect1 id="cvs_checkout">
      <title id="cvs_checkout_term">Download from the CVS repository</title>
      <indexterm>
	<primary>CVS</primary>
	<secondary>checking out from</secondary>
      </indexterm>
      <indexterm>
	<primary>Checking out from CVS</primary>
      </indexterm>
      <para>
The CVS repository at Tigris is accessible using the pserver protocol.
The CVS root is <filename>/cvs</filename> at cvs.tigris.org.
You use your Tigris login and Tigris password.
</para>
      <para>
        The first thing you will need to do, is select the CVS client. 
        Most of the description below is about the command line CVS tool, 
        which is available for most operating systems.
      </para>
      <para>
        Whatever tool you use, 
        do not checkout into a directory that contains spaces 
        in a directory name somewhere in the path!
        E.g. <literal>c:\Documents and Settings\...\My Documents\Java Development\</literal> 
        violates this advise 3 times.
        Reason: You can not build the documentation.
        (BTW: Building ArgoUML itself works.)
      </para>
      <para>
        In case you use the command-line CVS client, the above
        means that you will set the <varname>CVSROOT</varname>-variable to
        <parameter>:pserver:<replaceable>login</replaceable>@cvs.tigris.org:/cvs</parameter>
        where <replaceable>login</replaceable> is your Tigris login.
        This needs to be done before the first checkout.
        After that the root will be remembered by the checked out copy.
      </para>

      <para>
        If you use one of the CVS clients with a graphical user interface,
        (like WinCVS, GruntSpud, ...),
        or an IDE with a built-in CVS client (like Eclipse or NetBeans)
        then configuration will be done by filling in fields. These fields mean
        the following:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Type: pserver
          </para>
        </listitem>
        <listitem>
          <para>
            User: Your Tigris login name
          </para>
        </listitem>
        <listitem>
          <para>
            Host: cvs.tigris.org
          </para>
        </listitem>
        <listitem>
          <para>
            Repository: /cvs
          </para>
        </listitem>
      </itemizedlist>
      
      <para>
        If you used the command line CVS client before, then your Tigris password 
        is stored in the file <filename>~/.cvspass</filename>. 
        Some graphical UI CVS clients are
        able to use this password, in others you'll have to enter it again.
      </para>

      <para>
The next thing to do is to login. It is done using the command:
<command>cvs login</command>.
This only needs to be done once and then the account on your machine
remembers this.
</para>
      <para>
Then you do the actual checking out.
<command>cvs checkout <replaceable>directory</replaceable></command>.
</para>
      <para>
The CVS repository directories you need to check out to work with ArgoUML are
<filename class="directory">argouml/lib</filename>,
<filename class="directory">argouml/tools</filename>,
<filename class="directory">argouml/src_new</filename>,
<filename class="directory">argouml/src</filename>,
<filename class="directory">argouml-mdr</filename>,
and
<filename class="directory">argouml/tests</filename>.
</para>
      <para>
If you just want to build the documentation you check out the directories
<filename class="directory">argouml/lib</filename>,
<filename class="directory">argouml/tools</filename>
and
<filename class="directory">argouml/documentation</filename>.
</para>
      <para>
If you want to work with any of the web sites you check out 
the corresponding directory
<parameter>argouml/www</parameter>, or
<parameter>argouml-mdr/www</parameter>.
</para>
      <para>
If you value your time more than bandwidth and diskspace,
just check out the top-level 
<parameter>argouml</parameter> project and the mandatory
<parameter>argouml-mdr</parameter> sub-project.  This
triples the size of the download, mainly due to the images
in the
<filename class="directory">argouml/documentation</filename>
and
<filename class="directory">argouml/www</filename>,
but minimizes the number of separate CVS commands.
<!-- TODO: MVW: Instead of the details above, it is better to advise 
to check out "argouml" and "argouml-mdr" completely. 
Describe the details as: "If you want to limit the download size,..." -->
</para>
      <para>
If you don't want to acquire a Tigris login to do this you can use the
"guest" account with the password "guest".
Since the checked out copy remembers the login you used to do the
check out, if you do this, you will have to remember to delete this
copy and start over if you get a developer role in the project and
want to do commits directly.
</para>
    </sect1>


  <sect1 id="Build">
    <title id="Build_term">Build Process</title>
    <indexterm>
      <primary>Building</primary>
      <secondary>ArgoUML</secondary>
    </indexterm>
    <indexterm>
      <primary>ANT</primary>
    </indexterm>
    <para>
The standard ArgoUML build process is driven by Apache Ant, and it is highly recommend
that you stick to that.
Some developers use the integrated build tools of Eclipse and NetBeans, but always
make sure that your work compiles with the standard Ant build process.
There are also some Java files generated by magic scripts in Ant that
you need to create before opening with the IDE.
     </para>
      <para>
Ant is a tool written in Java developed for Apache that reads an XML-file
with rules telling what to compile to what result and what files to include
in what jar-file.
</para>
      <indexterm>
	<primary><filename>build.xml</filename></primary>
      </indexterm>
      <para>
The rule file is named <filename>build.xml</filename>.
There is one of those in every separate build directory
(<filename class="directory">argouml/src_new</filename>,
<filename class="directory">argouml/src/<replaceable>whatever</replaceable></filename>,
<filename class="directory">argouml-mdr</filename>,
<filename class="directory">argouml/documentation</filename>, and
<filename class="directory">argouml/modules/<replaceable>whatever</replaceable></filename>).
</para>

      <sect2>
	<title>How ANT is run from the ArgoUML development environment</title>
	<indexterm>
	  <primary>ANT</primary>
	  <secondary>how it is used</secondary>
	</indexterm>
	<para>
For your convenience the ant tool of the correct version is present in the
CVS repository of ArgoUML in the file
<filename class="libraryfile">argouml/tools/ant-1.6.2/lib/ant.jar</filename>.
</para>
	<para>
It is possible to start ant with the command
<command>../tools/ant-1.6.2/bin/ant <replaceable>arg</replaceable></command>
and in the modules
<command>
../../tools/ant-1.6.2/bin/ant <replaceable>arg</replaceable>
</command>.
On windows the command
<command>..\tools\ant-1.6.2\bin\ant <replaceable>arg</replaceable></command>
runs the program <filename>ant.bat</filename>.
</para>
	<para>
To keep you from having to write this and keeping track if you are
working with a module or not
there are two scripts (one for Unix and one for
Windows) that are called <filename>build.sh</filename> and
<filename>build.bat</filename> respectively present in most
of the directories that contain a <filename>build.xml</filename> file.
These two scripts run the equivalence of the above paths.
</para>
	<para>
By setting JAVA_HOME to different values you can at different times
build with different versions of JDK and Java.
</para>
	<para>
To use different versions of ANT,
you are responsible for installing your own version.
Also, you must execute
<command>/where/ever/you/placed/your/new/ant <replaceable>target</replaceable></command>
rather than
<command>build <replaceable>target</replaceable></command>.
</para>

      <para>
ArgoUML is currently spread over two projects,
the argouml project and
the argouml-mdr project.
They depend on each other in that the argouml-mdr project requires log4j and 
argouml-model.jar from the argouml project to build and
the argouml project needs the argouml-mdr project to run using the default
settings (targets run, info, debug, tests-using-mdr).
There are also the java interfaces in the argouml-mdr project that
don't depend on anything from the argouml project.
</para>
      <para>
To get this set up you need to
<itemizedlist>
	  <listitem>
	    <para>
build the package target in the argouml project (argouml/src_new)
</para>
	  </listitem>
	  <listitem>
	    <para>
build the install target in the argouml-mdr project
</para>
	    <para>
This copies all needed libraries to the argouml/build directory.
</para>
	  </listitem>
	</itemizedlist>
</para>

	<sect3>
	  <title>Compiling for Unix</title>
	  <indexterm>
	    <primary>Compiling</primary>
	    <secondary>Unix</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>Unix</primary>
	    <secondary>compilation</secondary>
	  </indexterm>
	  <para>
Here is what you need to do in order to compile and run
your checked out copy of ArgoUML under Unix.
</para>
	  <orderedlist>
	    <listitem>
	      <para><command>JAVA_HOME=<replaceable>/where/you/have/installed/jdk</replaceable></command></para>
	      <para><command>export JAVA_HOME</command></para>
	      <para>
This is for sh-style shells like sh, ksh, zsh and bash. If you use
csh-style shells like csh and tcsh you will instead have to write
<command>setenv JAVA_HOME <replaceable>/where/you/have/installed/jdk</replaceable></command>.
</para>
	    </listitem>
	    <listitem>
	      <para>After checking out with CVS, the shell files (build.sh,...) 
	      and executables (ant,...) have the wrong attributes. 
	      The CVS documentation says: "Files also lose
          their ownerships and permissions during repository transactions." 
	      Hence, you have to make such files executable 
	      before you will be able to run them.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
Change the current directory to the directory you are building
</para>
	      <para>
<command>cd <replaceable>/your/checked/out/copy/of/argouml/src_new</replaceable></command>
</para>
	    </listitem>
	    <listitem>
	      <para>Start Ant with no parameters to get a list of build targets 
          with descriptions</para>
          <para> <command>./build.sh</command></para>
	    </listitem>
	    <listitem>
      	      <para>
Compile, create jar files, and copy them so that argouml-mdr can be compiled
using 
<command>./build.sh package</command>.
</para>
	  </listitem>

	  <listitem>
	    <para>
Change to the <filename>argouml-mdr</filename> directory using
<command>cd ../../argouml-mdr</command>.
</para>
	  </listitem>

	  <listitem>
	    <para>
Compile, create jar files, and copy them so that they are available in the
argouml project using
<command>./build.sh install</command>.
</para>
	  </listitem>

	  <listitem>
	    <para>
Change back to the <filename>argouml/src_new</filename> directory using
<command>cd ../argouml/src_new</command>.
</para>
	  </listitem>


	    <listitem>
      	      <para>
              <indexterm>
                <primary>Ant target</primary>
                <secondary>run</secondary>
              </indexterm>
              <indexterm>
                <primary>run ant target</primary>
              </indexterm>
Run ArgoUML using <command>./build.sh run</command>
</para>
	    </listitem>
	  </orderedlist>
	      <para>
If you change something, running the run target again will
build
and run.
</para>

	<para>
If something is changed in the argouml project
that affects the argouml-mdr project
or if something is change in the argouml-mdr project
you need to go through this again,
possibly using the clean target in 
either the <filename>argouml/src_new</filename>-directory
or the <filename>argouml-mdr</filename>-directory
or both directories
since we have not set up dependencies correctly.
</para>
	</sect3>
	<sect3>
	  <title>Compiling for Windows</title>
	  <indexterm>
	    <primary>Compiling</primary>
	    <secondary>Windows</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>Windows</primary>
	    <secondary>Compilation</secondary>
	  </indexterm>

  	  <indexterm>
	    <primary>Compiling</primary>
	    <secondary>Cygwin</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>Cygwin Compilation</primary>
	  </indexterm>
	  <para>
If you do this from Cygwin you work just like for Unix.
</para>

	  <orderedlist>
	    <listitem>
	      <para>
<command>set JAVA_HOME=<replaceable>\where\you\have\installed\jdk</replaceable></command>
<!-- TODO: MVW: My setting includes a "\" at the end, and works. 
Does it matter? -->
</para>
	    </listitem>
	    <listitem>
	      <para>
Change the current directory to the directory you are building
</para>
	      <para>
<command>cd <replaceable>\your\checked\out\copy\of\argouml\src_new</replaceable></command>
</para>
	    </listitem>
	    <listitem>
	      <para>Start Ant with "-p" parameter to get a list of build targets 
          with descriptions</para>
	      <para><command>build -p</command></para>
	    </listitem>
	    <listitem>
	      <para>
Compile, create jar files, and copy them so that argouml-mdr can be compiled
using 
<command>build package</command>.
</para>
	  </listitem>

	  <listitem>
	      <para>
Change to the <filename>argouml-mdr</filename> directory using
<command>cd ..\..\argouml-mdr</command>.
</para>
	    </listitem>

	  <listitem>
	  <para>
Compile, create jar files, and copy them so that they are available in the
argouml project using
<command>build install</command>.
</para>
	  </listitem>

	  <listitem>
	    <para>
Change back to the <filename>argouml\src_new</filename> directory using
<command>cd ..\argouml\src_new</command>.
</para>
	  </listitem>


	    <listitem>
      	      <para>
Run ArgoUML using <command>build run</command>
</para>
	    </listitem>
	  </orderedlist>



	</sect3>
	<sect3>
	  <title>Customizing and configuring your build</title>
	  <indexterm>
	    <primary>Compiling</primary>
	    <secondary>customized</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>build.properties</primary>
	  </indexterm>
	  <indexterm>
	    <primary>default.properties</primary>
	  </indexterm>
	  <indexterm>
	    <primary>argouml.build.properties</primary>
	  </indexterm>
	  <indexterm>
	    <primary>Ant target</primary>
            <secondary>list-property-files</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>list-property-files ant target</primary>
	  </indexterm>
	  <para>
It is possible to customize your compilation of ArgoUML.
</para>
	  <para>
If you issue the command
<command>build list-property-files</command>
you can see what files are searched for properties.
</para>
	  <para>
Don't change the
<filename class="libraryfile">argouml/src_new/default.properties</filename>
file (unless you are working with updating the development environment
itself).
Instead create one of the other files locally on you machine.
The properties in these files have precedence over the properties in
<filename class="libraryfile">argouml/src_new/default.properties</filename>.
</para>
	  <para>
Remember that if you do this, you have modified your development
environment.
To be sure that you will not break anything for
anyone else when checking in things 
developed using this modified environment, 
remove these files temporarily for the compiling and testing
you do just before you commit.
	  </para>
	</sect3>
	<sect3>
	  <title>Building Javadoc</title>
	  <indexterm>
	    <primary>Javadoc building</primary>
	  </indexterm>
	  <indexterm>
	    <primary>Building</primary>
	    <secondary>Javadoc</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>Ant target</primary>
            <secondary>prepare-docs</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>prepare-docs ant target</primary>
	  </indexterm>
	  <para>
By running ANT again using <command>build prepare-docs</command>
the Javadoc documentation is generated and put into
<filename class="directory">argouml/build/javadocs</filename>.
</para>
	</sect3>
        <sect3>
          <title>Building one of the modules</title>
          <para>
If you want to run ArgoUML with modules enabled the 
<filename>build.xml</filename>s are set up to do this in two ways:
            <orderedlist>
              <listitem>
                <para>Test just one module</para>
                <orderedlist>
                  <listitem>
                    <para>Build ArgoUML, the package</para>
                    <para>
This is done with <command>ant package</command>
in the <filename class="directory">argouml/src_new</filename>-directory.
</para>
                  </listitem>
                  <listitem>
                    <para>Run the module</para>
                    <para>
This is done with <command>ant run</command>-command 
in the 
<filename class="directory">
argouml/modules/<replaceable>whatever</replaceable>
</filename>-directory.
</para>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>Test several modules together</para>
                <orderedlist>
                  <listitem>
                    <para>Build ArgoUML, the package</para>
                    <para>
This is done with <command>ant package</command>
in the <filename class="directory">argouml/src_new</filename>-directory.
</para>
                  </listitem>
                  <listitem>
                    <para>Compile and install the modules</para>
                    <para>
This is done with <command>ant install</command>-command
in each of the 
<filename class="directory">
argouml/modules/<replaceable>whatever</replaceable>
</filename>-directories.
</para>
                  </listitem>
                  <listitem>
                    <para>Start ArgoUML</para>
                    <para>
This is done with <command>ant run</command>
in the <filename class="directory">argouml/src_new</filename>-directory.
</para>
                  </listitem>
                </orderedlist>
                <para>
This will start ArgoUML with all modules available.
</para>
              </listitem>
            </orderedlist>         
</para>
        </sect3>
      </sect2>

    <sect2>
      <title>Developing in a subproject</title>

      <para>
This describes how to do development in one of the ArgoUML sub-projects.
</para>

      <para>
If you are in a hurry:
<programlisting>
C:\Work&gt;mkdir argouml\build
</programlisting>
Download and unpack the latest release of ArgoUML into this directory.
<programlisting>
C:\Work&gt;set CVSROOT=:pserver:guest@cvs.tigris.org:/cvs
C:\Work&gt;cvs login   (use guest as password)
C:\Work&gt;cvs checkout argouml-<replaceable>XX</replaceable>
C:\Work&gt;set JAVA_HOME=<replaceable>C:\Programs\jdkwhatever</replaceable>
C:\Work&gt;cd argouml-<replaceable>XX</replaceable>
C:\Work\argouml-<replaceable>XX</replaceable>&gt;ant run
</programlisting>
An ArgoUML starts with the module from the subproject 
argouml-<replaceable>XX</replaceable> enabled.
</para>
      <para>
That was the short version provided that,
you are using Windows + JDK,
you have ant installed, and
the subproject in question does not require any of the ArgoUML tools to build.
</para>
      <para>
If you don't understand this or it doesn't work read the rest of 
the chapter that describes why and how in more detail.
</para>

      <sect3>
	<title>The sub-project's relation to ArgoUML</title>

	<para>
The purpose of a subproject to ArgoUML is to develop things
that are run within ArgoUML.
In ArgoUML we call them modules,
in other tools they are called add-ins or plug-ins.
</para>

	<para>
If you want to start working with a module of your own you could
do it by letting the ArgoUML project leader set up a subproject to ArgoUML
for you.
The benefits are:
<itemizedlist>
	    <listitem>
	      <para>You will inherit all the infrastructure
from the ArgoUML project.
</para>
	      <para>
This includes
a site for your CVS repository, mailing lists, web server...,
a common way to set up the project,
releases,
bug fixes,
Xenofarm builds,
static checks, and
coding guidelines and license.
</para>
	    </listitem>

	    <listitem>
	      <para>You get a community of ArgoUML developers
that might monitor your work.
</para>
	    </listitem>
	  </itemizedlist>
The draw-backs are:
<itemizedlist>
	    <listitem>
	      <para>You are forced to use the ArgoUML infrastructure</para>
	      <para>
CVS, BSD license, coding guidelines.
</para>
	    </listitem>
	    <listitem>
	      <para>You are forced to make your module Open Source.</para>
	    </listitem>
	  </itemizedlist>
</para>

	<para>
If you decide not to make your module a argouml subproject,
you can still benefit from using a similar set up as described here
but since you have your module repository elsewhere,
some adaptations are necessary.
</para>

	<para>
The sub-projects are developed close to the ArgoUML project and
reside in the same CVS repository.
We try to provide a working set of tools and instructions to 
fit the whole set of projects.
These tools are sometimes located in the argouml project and
sometimes in the subproject.

Also, to compile the module, you need the argouml interfaces,
and to run it you need argouml in place.
In most cases the argouml interfaces is argouml itself so this
distinction is mostly formal.
</para>

	<para>
There are two ways to get the argouml in place w.r.t. your module.
The ArgoUML source way and
the quicker ArgoUML distribution way.
</para>
	<para>
Using the ArgoUML source way you check out the argouml project
alongside the subproject you are going to work with and build it.
If you are doing development in the argouml project too,
if the subproject in question requires a tool from the argouml project, or
if your modules is on the bleeding edge of argouml development and you can't
wait for distributions,
this is the preferred way.
You will need to update and rebuild the argouml project regularly.
</para>

	<para>
Using the ArgoUML distribution way, you check out only your module
and then download the ArgoUML distribution and work against that.
This is the approach described in the beginning of this section.
You will need to download and replace the ArgoUML distribution whenever
you need a newer version to work against.
You could also, at any point, upgrade to the ArgoUML source way to get
to the bleeding edge.
</para>

	<para>
The build.xml ant configuration file in the subproject
and the argouml main project
are set up to allow for both of these ways.
</para>
      </sect3>

      <sect3 id="working-with-subproject">
	<title>Working in a subproject</title>
	<para>
Each subproject has its own web site with
documentation and plans of the subproject.
</para>
	<para>
The subproject has its own CVS mailing list that you need to join
to monitor the commits.
It also has its own dev mailing list where the people working within
that subproject discusses the subproject.
Join both of these mailing list to see what is going on in the subproject!
</para>
	<para>
The sub-projects don't use their own Issuezilla database but instead they
are subcomponents in the ArgoUML Issuezilla.
Because of this you need to acquire an Observer role in the argouml
project to work in a subproject.
</para>
      </sect3>

      <sect3>
	<title>Targets in build.xml in a subproject</title>
	<para>
The following targets have the same documented meaning in all sub-projects:

<itemizedlist>
	    <listitem>
	      <para>clean - optional</para>
	      <para>
Removes files that are generated by running any of the other targets.
</para>
	    </listitem>
	    <listitem>
	      <para>compile - optional</para>
	      <para>
Compiles the code.
The result is in <filename>build/classes</filename>.
</para>
	    </listitem>
	    <listitem>
	      <para>generate - optional</para>
	      <para>
This is a step that, if it exists, can be run before compile.
The result of this is some files that is a prerequisite for compile
so the compile target runs this automatically.
</para>
	    </listitem>
	    <listitem>
	      <para>install</para>
	      <para>
This builds the whole module and copies it into the
<filename>ext</filename> directory in the argouml installation.
</para>
	      <para>
The purpose of the ext directory is so that argouml can be started
with several different modules started at once.
</para>
	    </listitem>
	    <listitem>
	      <para>jar - optional</para>
	      <para>
This builds the whole module and puts the resulting jar file(s)
in <filename>build</filename>.
</para>
	    </listitem>
	    <listitem>
	      <para>run</para>
	      <para>
This starts argouml with this module active.
</para>
	      <para>
This is the way to start this module with the newly compiled source.
</para>
	    </listitem>
	    <listitem>
	      <para>tests - optional</para>
	      <para>
This runs all the JUnit test cases available in the module.
This probably requires the <filename>junit.jar</filename> tool
from the argouml project.
</para>
	    </listitem>
	  </itemizedlist>
</para>
      </sect3>
    </sect2>



      <sect2>
	<title>Troubleshooting the development build</title>
	<indexterm>
	  <primary>Troubleshooting</primary>
	  <secondary>development build</secondary>
	</indexterm>
	<sect3>
	  <title>Compiling failed. Any suggestions?</title>
	  <para>
It might be that some other developer has made a mistake in checking
in things that contain errors, or forgotten to check in some files
in a change.
Look at the last couple of hours on the
<ulink url="http://argouml.tigris.org/servlets/BrowseList?listName=dev">
developers mailing list</ulink>!
It is probably on fire.
</para>
          <indexterm>
            <primary>Ant target</primary>
            <secondary>clean</secondary>
          </indexterm>
          <indexterm>
            <primary>clean ant target</primary>
          </indexterm>
	  <para>
Another reason for problems is an unclean local source tree.
This means that if you have updated different parts of your source
tree at different times it might contain inconsistencies.
If you suspect this, first try to fix it by doing
<command>build clean</command> and <command>cvs update -d</command>
before trying to build again.
If that doesn't work remove your checked out copy completely and 
get it all again through CVS.
</para>
	  <para>
Another reason might be that you have an 
<filename>build.properties</filename> or
<filename>argouml.build.properties</filename>
file that you have been working with earlier
and that is doing something. If in doubt, remove those files.
</para>
	  <para>
If nothing helps, ask the 
<ulink url="mailto:dev@argouml.tigris.org">developers mailing list</ulink>!
</para>
	</sect3>
	<sect3>
	  <title>Can't commit my changes?</title>
	  <indexterm>
	    <primary>Troubleshooting</primary>
	    <secondary>committing changes</secondary>
	  </indexterm>
	  <para>
You need to have a developer role in the ArgoUML project.
If you don't then you cannot do commit yourself.
Discuss what you have done and how best to test it on the
<ulink url="mailto:dev@argouml.tigris.org">developers mailing list</ulink>!
Eventually someone will commit it for you.
</para>
	  <para>
Furthermore the checkout of your copy needs to be done with your
Tigris id that has the Developer role.
If you for some reason have earlier checked out
a copy as guest and then made modifications, changed the CVSROOT
variable you still cannot commit changes done in the repository since the
checked out copy contains information on who checked out.
For this reason, it is best to apply for an Observer role in 
the project if you are going to work with the source at all.
The Observer role is probably granted within a couple of days
(we welcome everybody!) and then you can check out with your Tigris id.
This means that when you eventually are granted a Developer role you
can continue working with the same checked out copy.
</para>
	</sect3>
      </sect2>
  </sect1>

    <sect1 id="junittests">
      <title>The JUnit test cases</title>
      <indexterm>
	<primary>JUnit testing</primary>
      </indexterm>
      <indexterm>
	<primary>Unit testing of ArgoUML</primary>
      </indexterm>
      <indexterm>
	<primary>Testing ArgoUML</primary>
      </indexterm>
      <para>
ArgoUML has a set of automatic test cases using JUnit-framework
for testing the insides of the code.
The purpose of these are to help in pin-pointing problems with
code changes before even starting ArgoUML.
</para>
      <para>
The JUnit test cases are residing in a separate directory and
run from ant targets in the
<filename>src_new/build.xml</filename>.
They are never distributed with ArgoUML but merely a tool for
developers.
</para>

        <indexterm>
          <primary>Ant target</primary>
          <secondary>tests</secondary>
        </indexterm>
        <indexterm>
          <primary>tests ant target</primary>
        </indexterm>
        <indexterm>
          <primary>Ant target</primary>
          <secondary>guitests</secondary>
        </indexterm>
        <indexterm>
          <primary>guitests ant target</primary>
        </indexterm>
	<para>
By running the command
<command>build tests guitests</command>
in <filename>src_new</filename>
these test cases are started, each in their own JVM.
</para>
	<para>
Each test case writes its result on the Ant log.
</para>
	<para>
The result is also generated into a set of files that can be found at
<filename>build/test/reports/junit/output/html/index.html</filename>.
</para>

        <para>
The test cases' Java source code is located under
<filename>argouml/tests/org/argouml</filename>.
</para>

	<sect2>
	  <title>How to write a test case</title>
	  <indexterm>
	    <primary>Unit testing of ArgoUML</primary>
	  </indexterm>
	  <indexterm>
	    <primary>Testing ArgoUML</primary>
	  </indexterm>
	  <indexterm>
	    <primary>Test cases</primary>
	    <secondary>writing</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>Writing test cases</primary>
	  </indexterm>
	  <para>
Now this will make all you Java enthusiasts go nuts!
We have both class names and method names with a special syntax.
</para>
          <indexterm>
            <primary>Ant target</primary>
            <secondary>run-with-test-panel</secondary>
          </indexterm>
          <indexterm>
            <primary>run-with-test-panel ant target</primary>
          </indexterm>
          <sect3><title>About the Test case Class</title>
  	  <para>
The name of the test case class starts with "Test" (i.e. Capital T, then
small e, s and t) or 
"GUITest" (i.e. Capital G, U, I, T then small e, s, t).
The reason for this is that the special targets in
<filename>src_new/build.xml</filename>
search for test case classes with these names.
If you write a test case class that does not comply to this rule, you still
can run the test cases in this class manually 
by starting with
<command>build run-with-test-panel</command>,
but it wont be known and run by other developers and automatic build
mechanisms so don't do it.
</para>

	<para>
Test case classes that don't require GUI components in place
have filenames like
<filename>Test<replaceable>*</replaceable>.java</filename>.
They must be able to run on a headless system.
To make sure that this works, always run your newly developed
test cases with <command>build tests</command> using 
JDK 1.4 or later.
</para>
      <para>
Test case classes that do require GUI components in place
have filenames like
<filename>GUITest<replaceable>*</replaceable>.java</filename>.
</para>
      <para>
We should try to get as many tests from a GUITest* class to 
the corresponding Test* class because the latter are run by automatic 
builds regularly.
</para>
      <para>
Every class
<classname>org.argouml.<replaceable>x.y</replaceable>.<replaceable>z</replaceable></classname>
stored in the file
<filename class="directory">src_new/org/argouml/<replaceable>x/y</replaceable>/<replaceable>z</replaceable>.java</filename>
should have a JUnit test case class called
<classname>org.argouml.<replaceable>x.y</replaceable>.Test<replaceable>z</replaceable></classname>
stored in the file
<filename class="directory">tests/org/argouml/<replaceable>x/y</replaceable>/Test<replaceable>z</replaceable>.java</filename>
containing all the Unit Test Cases for that class
that don't need the GUI components to run.
Tests that 
do need GUI components to run should be part of a class named
<classname>org.argouml.<replaceable>x.y</replaceable>.GUITest<replaceable>z</replaceable></classname>
stored in the file
<filename class="directory">tests/org/argouml/<replaceable>x/y</replaceable>/GUITest<replaceable>z</replaceable>.java</filename>
</para>
	  <para>
If you only want to run your newly written test cases and not
all the test cases, you could start with the command
<command>build run-with-test-panel</command>
and give the class name of your test case like
<classname>org.argouml.<replaceable>x.y</replaceable>.Test<replaceable>z</replaceable></classname>
or
<classname>org.argouml.<replaceable>x.y</replaceable>.GUITest<replaceable>z</replaceable></classname>.
You will then get the output in the window.
You could run all tests in this way by specifying the special test suite
<classname>org.argouml.util.DoAllTests</classname>
in the same way.
</para>

	  <para>
Every test case class imports the JUnit framework: 
<blockquote>
	      <para>
import junit.framework.*;
</para>
	    </blockquote>
and it inherits <classname>TestCase</classname>
(i.e. <classname>junit.framework.TestCase</classname>).
</para>
    </sect3>
    <sect3><title>About the Test case Method</title>
	  <para>
Methods that are tests must have names that start with "test"
(i.e. all small t, e, s, t). This is a requirement of the JUnit
framework.
</para>
	  <para>
Try to keep the test cases as short as possible.
There is no need in cluttering them up just to beautify the output.
Prefer
<programlisting>
// Example from JUnit FAQ
public void testIndexOutOfBoundsExceptionNotRaised()
        throws IndexOutOfBoundsException {
    ArrayList emptyList = new ArrayList();
    Object o = emptyList.get(0);
}
</programlisting>
over
<programlisting>
public void testIndexOutOfBoundsExceptionNotRaised() {
    try {
        ArrayList emptyList = new ArrayList();
        Object o = emptyList.get(0);
    } catch (IndexOutOfBoundsException iobe) {
        fail("Index out of bounds exception was thrown.");
    }
}
</programlisting>
because the code is shorter, easier to maintain and you get a better
error message from the JUnit framework.
</para>
	  <para>
A lot of times it is useful just to run the compiler to verify that
the signatures are correct on the interfaces. Therefor Linus has
thought it is a good idea to add methods called
<methodname>compileTestStatics</methodname>,
<methodname>compileTestConstructors</methodname>, and
<methodname>compileTestMethods</methodname>
that was thought to include correct calls to all static methods,
all public constructors, and all other public methods that are not
otherwise tested.
These methods are never called.
They serve as a guarantee that the public interface of a class will
never lose any of the functionality provided by its signature in an
uncontrolled way in just the same way as the test-methods serve as a
guarantee that no features will ever be lost.
</para>
	  <example>
	    <title>An example without Javadoc comments</title>
	    <indexterm>
	      <primary>Test cases</primary>
	      <secondary>an example</secondary>
	    </indexterm>
	    <para>
<programlisting>
package org.argouml.uml.ui;
import junit.framework.*;

public class GUITestUMLAction extends TestCase {
    public GUITestUMLAction(String name) {
	super(name);
    }

    // Testing all three constructors.
    public void testCreate1() {
	UMLAction to = new UMLAction(new String("hexagon"));
	assert("Disabled", to.shouldBeEnabled());
    }
    public void testCreate2() {
	UMLAction to = new UMLAction(new String("hexagon"), true);
	assert("Disabled", to.shouldBeEnabled());
    }
    public void testCreate3() {
	UMLAction to = new UMLAction(new String("hexagon"), true, UMLAction.NO_ICON);
	assert("Disabled", to.shouldBeEnabled());
    }
}
</programlisting>
and the corresponding no-GUI-class:
<programlisting>
package org.argouml.uml.ui;
import junit.framework.*;

public class TestUMLAction extends TestCase {
    public TestUMLAction(String name) {
	super(name);
    }

    // Functions never actually called. Provided in order to make
    // sure that the static interface has not changed.
    private void compileTestStatics() {
	boolean t1 = UMLAction.HAS_ICON;
	boolean t2 = UMLAction.NO_ICON;
	UMLAction.getShortcut(new String());
	UMLAction.getMnemonic(new String());
    }

    private void compileTestConstructors() {
	new UMLAction(new String());
	new UMLAction(new String(), true);
	new UMLAction(new String(), true, true);
    }

    private void compileTestMethods() {
	UMLAction to = new UMLAction(new String());
	to.markNeedsSave();
	to.updateEnabled(new Object());
	to.updateEnabled();
	to.shouldBeEnabled();
    }
}
</programlisting>
</para>
	  </example>
    </sect3>
      </sect2>
    </sect1>

    <sect1 id="manual_tests">
      <title>Manual Test Cases</title>
      <para>
The manual test cases are here to help us test ArgoUML in order to 
cover things that are not testable with the JUnit test cases.
Since it is a little bit more cumbersome to run them, 
a tester must 
read the test cases, 
understand what he is supposed to do,
do it, and
document the result,
we try to go as far as possible with the JUnit test cases
and have as few manual test cases as possible.
I.e. If one of these tests can be converted into a JUnit test case
we shall try to do so because it can save us a lot of time.
On the other hand, 
there are several things that cannot possibly be tested with JUnit tests,
so there probably are a lot of Manual Test Cases to be written.
</para>
      <sect2>
        <title>Running the manual tests</title>
        <para>
Anyone can run the manual tests on any version of ArgoUML.
If it doesn't work, i.e. the expected result is not seen,
then this is a defect in that version of ArgoUML and should
be reported using Issuezilla.
</para>
        <para>
At every release, 
the ambition is to run through all manual tests.
Initially, when the amount of manual tests is small, 
this is done by the release responsible while testing the newly compiled
release.
Later on,
when the amount of manual tests makes it unpractical
to this during the release work,
the work can be done by anyone,
or any group of people within the project,
after a development release is made and before a stable release is made.
A signed statement with list of run tests including version number,
a list (hopefully empty) of failed tests 
together with their Issuezilla DEFECT number,
the host type, OS, JDK version, ArgoUML version, ...
shall be mailed to the dev list when these tests are completed.
</para>
      </sect2>

      <sect2>
        <title>Writing the manual tests</title>
        <para>
Adding a new manual test to the group of already existing manual tests
or improving one of the existing tests helps the project forward.
Remember that the first priority is to test things with the JUnit
tests because they can be, to some extent, run automatically and
have their result reported automatically but then manual tests
are the next big improvement.
</para>
        <para>
Every test has several attributes to make sure that we can identify
the test and help the developers and testers.
          <itemizedlist>
            <listitem>
              <para>A name</para>
              <para>
This name is the title of the subsection where the test is described.
</para>
            </listitem>

            <listitem>
              <para>A number</para>
              <para>
These start with TEST1 and are allocated in sequence
and maintained manually in this document
(TEST2, TEST3, TEST4, ...).
They are never reused when made available by removing
a test case.
</para>
            </listitem>

            <listitem>
              <para>A revision</para>
              <para>
Every test case has a revision.
These start with REVa and are increased with one every time
the test case is changed.
</para>
            </listitem>

            <listitem>
              <para>A list of requirements tested</para>
              <para>
This list is references to the requirements as stated in
<xref linkend="requirements"/>.
</para>
            </listitem>

            <listitem>
              <para>Preparations i.e. what to do before the test</para>
              <para>
This is Optional. The default is that you have just started ArgoUML.
</para>
            </listitem>

            <listitem>
              <para>A description on what to do an what to expect</para>
              <para>
This is a description in plain English telling the tester
exactly what to do and what to expect.
If this description doesn't work or is ambiguous in any way the tester
should consider the test to be DEFECT and report it in Issuezilla.
</para>
              <para>
This is probably best written like this:
</para>
              <para>
<emphasis>Do:</emphasis>
whatever
</para>
              <para>
<emphasis>Expected output:</emphasis>
whatever
</para>
              <para>
<emphasis>Do:</emphasis>
whatever
</para>
              <para>
<emphasis>Expected output:</emphasis>
whatever
</para>
            </listitem>
          </itemizedlist>
</para>
      </sect2>

      <sect2>
        <title>The list of tests</title>
        <para>
This section contains all the tests each in a subsection of its own.
</para>
        <sect3>
          <title>Modules are enabled</title>
          <para>
TEST1 REVa (Does not test any current requirements.)
</para>
          <para>
<emphasis>Preparations:</emphasis>
Download and install ArgoUML together with the modules.
</para>
          <para>
<emphasis>Do:</emphasis>
Start in a window that allows you to see the output on Stdout.
</para>
          <para>
<emphasis>Expected output:</emphasis>
<programlisting>
Loaded Module: Java from classes
Loaded Module: GeneratorCpp
Loaded Module: GeneratorCSharp
Loaded Module: GeneratorPHP
</programlisting>
</para>
          <para>
<emphasis>Do:</emphasis>
Press F7 (or select menu Generation => Generate All Classes...)
</para>
          <para>
<emphasis>Expected output:</emphasis>
A window pops up with Class Name, Java, Cpp, CSharp, and PHP.
</para>
          <para>
<emphasis>Do:</emphasis>
Select menu File => Import sources, 
then open the drop-down box Select language for import: to the far right.
</para>
          <para>
<emphasis>Expected output:</emphasis>
The drop-down box contains Java and Java from classes.
</para>
        </sect3>

        <sect3>
          <title>Class diagram</title>
          <para>
TEST2 REVa
(Requirements tested: 
<xref linkend="REQ5"/> and
<xref linkend="REQ6"/>) 
</para>
          <para>
<emphasis>Do:</emphasis>
Select the Class Diagram.
Click the Package symbol on the Edit pane tool-bar.
Click on the diagram.
Click the Class symbol on the Edit pane tool-bar.
Click on the diagram.
Click the Interface symbol on the Edit pane tool-bar.
Click on the diagram.
</para>
          <para>
<emphasis>Expected output:</emphasis>
The Class diagram and the explorer now contains
one package,
one class, and
one interface.
</para>
          <para>
<emphasis>Do:</emphasis>
Select the class.
Drag from the four quick-buttons located along the sides of the class
and release somewhere on the diagram.
Click on the fifth quick-button (bottom-left of the class).
Select the interface.
Drag from the quick-button located along the bottom of the interface symbol
and release somewhere on the diagram.
</para>
          <para>
<emphasis>Expected output:</emphasis>
When releases on the diagram a new class is created 
both on the diagram, where released
and in the explorer.
The type of the association corresponds with the quick-button type.
The association created when clicking the fifth quick-button goes back
to the class itself.
</para>
        </sect3>

      </sect2>

    </sect1>

  <sect1 id="generating_documentation">
    <title>Generating documentation</title>
    <para>
This describes how the documentation is generated
i.e. both what to do and how the setup works.
</para>
    <para>
If you are in a hurry:
<programlisting>
C:\Work&gt;set CVSROOT=:pserver:guest@cvs.tigris.org:/cvs
C:\Work&gt;cvs login   (use guest as password)
C:\Work&gt;cvs checkout argouml/documentation argouml/tools argouml/lib
C:\Work&gt;set JAVA_HOME=<replaceable>C:\Programs\jdkwhatever</replaceable>
C:\Work&gt;cd argouml\documentation
C:\Work\argouml\documentation&gt;build defaulthtml
</programlisting>
The HTML version of the Cookbook, Quick Guide, and User Manual are
built and the result end up in.
<filename class="directory">C:\Work\argouml\build\documentation\defaulthtml\cookbook</filename>,
<filename class="directory">C:\Work\argouml\build\documentation\defaulthtml\quick-guide</filename>,
and
<filename class="directory">C:\Work\argouml\build\documentation\defaulthtml\manual</filename>
respectively.
</para>
    <note>
      <para>
From here on it is the old text that is more or less "Publishing ArgoUML"
to be reworked.
</para>
    </note>
    <sect2 id="how_the_web_site_works">
      <title>How the ArgoUML web site works</title>
      <indexterm>
	<primary>Web Site</primary>
	<secondary>maintaining</secondary>
      </indexterm>
      <para>
Tigris provides the ArgoUML site to be edited through CVS. Everything
that is checked in under <filename>argouml/www</filename>
becomes immediately available at the URL 
<ulink url="http://argouml.tigris.org/">http://argouml.tigris.org/</ulink>
with some added decorations.
</para>
      <para>
Example: The file <filename>argouml/www/project.html</filename> is
available at 
<ulink url="http://argouml.tigris.org/project.html">http://argouml.tigris.org/project.html</ulink>.
</para>
      <para>
This is the way the site is maintained and updated.
</para>
    </sect2>
    <sect2>
      <title>The ArgoUML documentation</title>
      <indexterm>
	<primary>Documentation</primary>
      </indexterm>
      <indexterm>
	<primary>Web Site</primary>
	<secondary>documentation</secondary>
      </indexterm>
      <para>
For the ArgoUML project the same documentation shall be available in both
HTML, PDF and JavaHelp. To this end the documentation is written in
DocBook XML and generated into two versions of HTML 
(one page per chapter and one page for the whole book),
PDF and JavaHelp.
</para>
      <para>
We have tools that does the conversion from DocBook XML to HTML and PDF.
The conversion is done whenever you need to look at the result or when 
you want to present the final result on the web site.
</para>
      <para>
There are currently three different books generated in this way,
each into its own directory. They are cookbook (this document), 
manual and quick-guide. They are all generated and stored in the
exact same way except for the name of the directory that is one
of <filename class="directory">cookbook</filename>,
<filename class="directory">manual</filename> or 
<filename class="directory">quick-guide</filename>.
Below I will reference these directories using
<filename class="directory"><replaceable>book</replaceable></filename>.
</para>
      <para>
When a new version of the documentation is to be made available on the
web site the responsible document release person does the following:
</para>
      <orderedlist>
	<listitem>
	  <para>
He checks out everything needed
and a copy of the <filename class="directory">argouml/www</filename>.
</para>
	  <para>
If wanted, the CVS repository could be tagged and then the tag
can be checked out. This makes it possible to know exactly
how a certain version of the documentation was generated.
</para>
	</listitem>
	<listitem>
	  <indexterm>
	    <primary>Ant target</primary>
	    <secondary>docs</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>docs ant target</primary>
	  </indexterm>
	  <para>
The documentation is generated using <command>build docs</command>.
</para>
	  <para>
This generates all three books and the result appears in
<filename class="directory">argouml/build/documentation/defaulthtml/<replaceable>book</replaceable></filename>,
<filename class="directory">argouml/build/documentation/printablehtml/<replaceable>book</replaceable></filename>, and
<filename class="directory">argouml/build/documentation/pdf/<replaceable>book</replaceable></filename>.
</para>
	  <para>
This has been done several times before while preparing the release so
no problems are expected. If there are problems then the preparations
were not good enough and the process is best stopped right here.
</para>
	</listitem>
	<listitem>
	  <para>
All the old files are removed from the checked out copy of 
<filename class="directory">argouml/www/documentation/defaulthtml/<replaceable>book</replaceable></filename>, 
<filename class="directory">argouml/www/documentation/printablehtml/<replaceable>book</replaceable></filename>.
</para>
	</listitem>
	<listitem>
	  <para>
New files are copied into the checked out copy of <filename class="directory">www</filename>
on top of the previous files there replacing them.
</para>
	  <para>
All the files are copied from
<filename class="directory">argouml/build/documentation/defaulthtml/<replaceable>book</replaceable></filename> to
<filename class="directory">argouml/www/documentation/defaulthtml/<replaceable>book</replaceable></filename>. 
The same for <filename class="directory">printablehtml</filename> and 
<filename class="directory">pdf</filename>.
</para>
	</listitem>
	<listitem>
	  <para>
No longer used files in 
<filename class="directory">argouml/www/documentation</filename>
are removed from CVS and new files are added.
</para>
	  <para><command>cvs -n update</command></para>
	  <para>Watch for "Missing" and "Unknown" files.</para>
	  <para>
The missing files are scheduled to be removed by:
<command>cvs remove <replaceable>each of the missing files</replaceable></command>
</para>
	  <para>
The "Unknown" files are scheduled to be added by:
<command>cvs add <replaceable>each of the added files</replaceable></command>
</para>
	  <para>
This removing of missing files and adding of unknown files may seem
backward but it is from the perspective of CVS.
The missing files are the ones that were present in the previous
version of the documentation and do not have a replacement,
either because that chapter does not exist anymore or that the tool
generates filenames differently.
The Unknown files are files with filenames that for the same reason
appear from one version of the documentation to the next.
</para>
	</listitem>
	<listitem>
	  <para>
Commit the changes thus publishing it on the web site.
</para>
	  <para>
<command>cvs commit -m'New version of the documentation published'</command>
</para>
	</listitem>
	<listitem>
	  <para>
The PDF book is uploaded to the download page.
</para>
	</listitem>
      </orderedlist>
    </sect2>
    <sect2>
      <title>How we work with documentation</title>
      <indexterm>
	<primary>Documentation</primary>
	<secondary>work with</secondary>
      </indexterm>
      <para>
The developers or authors that work with the documentation or with the tools 
to generate the documentation (or anyone else interested in how it works)
can generate the documentation like described above and examine
the result in
<filename class="directory">argouml/build</filename>.
It is only the last part about checking in and uploading the result
under
<filename class="directory">argouml/www/documentation</filename>
that requires write access in the CVS and 
some configuration management since it more or less is
releasing the manual.
</para>
      <para>
In order to do this you need to check out the whole of the
<filename class="directory">argouml/documentation</filename> directory.
You also need the directory
<filename class="directory">argouml/lib</filename> and
<filename class="directory">argouml/tools</filename>
that contain the tools used: Ant, FOP, Saxon, ...
</para>
      <para>
The subdirectories of
<filename class="directory">argouml/documentation</filename>,
<filename class="directory">cookbook</filename>,
<filename class="directory">manual</filename>, and
<filename class="directory">quick-guide</filename>
each contain one of the three books.
The subdirectory
<filename class="directory">docbook-setup</filename>
contains two things. 
It contains the configuration files that control how the generation is done.
It contains the XSL rules for all the generation.
The subdirectory
<filename class="directory">images</filename>
contains all the required pictures for all the books.
</para>
      <para>
When, in the <filename class="directory">documentation</filename> you run
<command>./build.sh defaulthtml</command> or one of the other targets that
builds the documentation,
all books are built.
What happens is (the target internal-dispatcher):
</para>
      <itemizedlist>
	<listitem>
	  <para>
The 
<filename><replaceable>manual</replaceable>/<replaceable>argomanual.xml</replaceable></filename>
is copied by ant to
<filename><replaceable>manual</replaceable>/<replaceable>argomanual-generated.xml</replaceable></filename>
while doing substitution of tokens:
(@VERSION@ to become the version as specified in 
<filename>default.properties</filename>)
</para>
	</listitem>

	<listitem>
	  <para>
The file 
<filename><replaceable>manual</replaceable>/<replaceable>argomanual-generated.xml</replaceable></filename>
is processed by the special 
<filename>docbook-setup/create-imglist.xsl</filename>
xsl script that generates a list of included images.
</para>
	</listitem>

	<listitem>
	  <para>
All included images are copied.
</para>
	  <para>
The purpose of this is to only get the images actually used copied
with the document that uses them and not all images.
</para>
	</listitem>

	<listitem>
	    <para>
The HTML is generated by processing the file
<filename><replaceable>manual</replaceable>/<replaceable>argomanual-generated.xml</replaceable></filename>.
</para>
	</listitem>
      </itemizedlist>
      <para>
The file
<filename><replaceable>manual</replaceable>/<replaceable>argomanual-generated.xml</replaceable></filename>
is a temporary file that only exists while processing the XML.
If editing the XML with a DocBook editors 
you open the file
<filename><replaceable>manual</replaceable>/<replaceable>argomanual.xml</replaceable></filename>
and edit the unsubstituted file.
The differences between the unsubstituted file and the substituted file
are so small that it shouldn't make any difference.
</para>

    </sect2>
  </sect1>

    <sect1 id="release_process">
      <title>Making a release</title>
      <indexterm>
	<primary>Making a release</primary>
      </indexterm>
    <para>
The purpose of this chapter is
to simplify for the person that is actually doing the release work and
to make sure that everything is done in the exact same way 
every time and nothing is forgotten.
</para>
    <para>
The scripts involved have been developed and are mostly run
on a Cygwin system.
They will hopefully work on any UNIX system but most likely they
will need some adjustments.
</para>
    <note>
      <para>
This is under rework now that the distribution is to be done using
a SVN project.
</para>
    </note>

    <para>
The artifacts in play here are
<filename>argouml/src_new/build.xml</filename>,
<filename>argouml/tools/bin/build-release.sh</filename>,
<filename>argouml/tools/bin/pack-release.sh</filename>, and
other <filename>build.xml</filename> files.
The plan for the future is that the <filename>build.xml</filename>
files contain rules on how to compile and package things into jar files.
After that the
<filename>argouml/tools/bin/build-release.sh</filename> and
<filename>argouml/tools/bin/pack-release.sh</filename>
will be taken care of
signing,
packing into tar, zipped archives, packing sources, and
uploading.

The <filename>build.xml</filename> will have rules that places the
complete runnable release in
<filename class="directory">argouml/build</filename>.
These are the same rules used by developers when compiling for testing.
The
<filename>build-release.sh</filename> and
<filename>pack-release.sh</filename>
script takes it from there.
</para>



    <para>
Prerequisites (what you need to be able to do this):
<itemizedlist>
	<listitem>
	  <para>
CVS access to the argouml project (to set tags).
</para>
	  <para>
You also need CVS access to the included sub-projects to set the tags there:
(argouml-mdr, argouml-csharp, argouml-nb, ... and this list will probably grow).
</para>
	</listitem>
	<listitem>
	  <para>
SVN access to the argouml-downloads project (to upload the result).
</para>
	</listitem>
	<listitem>
	  <para>
A machine.
</para>
	  <para>
This is probably the machine you use for your development if you are
an argouml developer.
</para>
	  <para>
The machine needs
Internet access (it is not a small download and upload so at least
128KB Internet connection to keep the time reasonable &lt; 2 hours),
the correct version of Java installed (should be a JDK 1.4.2),
CVS and SVN installed,
Unix or Cygwin to be able to run the scripts.
</para>
	</listitem>
	<listitem>
	  <para>
That you have set the CVSROOT correctly.
</para>
	  <para>
Make sure it is set to 
<command>:pserver:<replaceable>user</replaceable>@cvs.tigris.org:/cvs</command>.
</para>
	</listitem>
      </itemizedlist>
</para>

    <para>
Here are the steps to be done when one actually does a release:
</para>

    <para>
      <orderedlist>
	<listitem>
	  <para>Set the <methodname>argo.core.version</methodname>
to not include the "PRE-" part.
</para>
          <para>
This is done in the <filename>default.properties</filename>-file
in <filename>src_new</filename>
and <filename>documentation</filename>
and then, commit the files.
</para>
        </listitem>
 
	<listitem>
	  <para>Tag the CVS repository with the freeze tag!</para>
	  <para>
Normally this tag is "VERSION_<replaceable>X_Y_Z</replaceable>_F",
e.g. VERSION_0_9_7_F.
The according command line CVS command is 
<command>cvs rtag VERSION_<replaceable>X_Y_Z</replaceable>_F argouml</command>.
<note>
	      <para>
<!-- This is Issue 90 in the Tigris Issuezilla
    http://www.tigris.org/issues/show_bug.cgi?id=90
-->
Because of a problem on the Tigris site, this doesn't work. 
The workaround is that you
make sure you have a complete checked out and copy of ArgoUML,
go to the root directory 
<filename class="directory">argouml</filename>,
and run the command
<command>cvs tag VERSION_<replaceable>X_Y_Z</replaceable>_F</command>.
</para>
	    </note>
</para>
	  <para>
You also need to set the tag in the sub-projects so the following command
is more like it:
<programlisting>
for proj in argouml argouml-mdr argouml-csharp argouml-nb argouml-i18n-zh
do
    ( cd &dollar;proj &amp;&amp; cvs tag VERSION_<replaceable>X_Y_Z</replaceable>_F )
done
</programlisting>
</para>
	</listitem>

	<listitem>
	  <para>
Open the repository for commits toward the next version.
</para>
	  <para>
This is done by setting the <methodname>argo.core.version</methodname>
in <filename>default.properties</filename>
in <filename>src_new</filename>
and <filename>documentation</filename>
to PRE-<replaceable>Number of next release</replaceable>, committing
and telling everyone on the developers mailing list.
</para>
	</listitem>

	<listitem>
	  <para>
Check the key to sign the jar files for Java Web Start.
</para>
	  <para>
Run the command
<command>keytool -list -v</command>
and give the keystore password 
<parameter>secret</parameter>.
You should have a key named argouml that is valid several months
in the future.
</para>
	  <para>
This is to make sure that you have a valid key
for the purpose of signing the Java Web Start version of the files.
</para>
          <sidebar>
	  <para>
Since the ArgoUML project and the Tigris organization are loose
organizations we cannot buy a "real" key.
The keys we use are the unsigned keys
that can be generated by anyone using the keytool provided with Java.
</para>
	  </sidebar>
	  <para>
A key is generated with the command
<command>keytool -genkey -alias argouml -storepass secret</command>.
</para>
	  <para>
By default these keys have a validity of just three (3) months
but by giving the
<parameter>-validity <replaceable>days</replaceable></parameter>
the validity can be extended.
</para>
	</listitem>

	<listitem>
	  <para>
Run the script
<filename>argouml/tools/bin/build-release.sh</filename>
and give the answers to the questions.
</para>

	  <note>
	    <para>
You need to have this file checked out.
</para>
	    <para>
Actually the script assumes the following set up:
<itemizedlist>
		<listitem>
		  <para>
<filename class="directory">somedirectory/</filename> -
the directory where the script is started from.
</para>
		</listitem>

		<listitem>
		  <para>
<filename class="directory">somedirectory/argouml</filename> -
the place where a checked out copy of ArgoUML resides and the documentation
can be built.
</para>
		  <para>
The script is located here and the 
<filename>JimiProClasses.zip</filename>
is taken from this installation so if you can build the PDF documentation
correctly in this, a lot is gained.
</para>
		</listitem>

		<listitem>
		  <para>
<filename class="directory">somedirectory/<replaceable>FREEZETAG</replaceable></filename> -
the created that will be created where the whole build will take place
</para>
		</listitem>

		<listitem>
		  <para>
<filename>svn/argouml-downloads/trunk/www/</filename> -
where the files to be uploaded will go
</para>
		  <para>
Notice that this is starts one step up, on the same level as
<filename class="directory">somedirectory</filename>.
It will be accessed using a path like
<filename class="directory">../svn/argouml-downloads/trunk/www</filename>.
</para>
		  <para>
This is achieved using the following commands:
<programlisting>
cd ..
svn co -N http://argouml-downloads.tigris.org/svn/argouml-downloads/trunk/www argouml-downloads/trunk/www
</programlisting>
</para>
		</listitem>
	      </itemizedlist>
</para>
	  </note>

	  <para>
This will:
</para>
	  <orderedlist>
	    <listitem>
	      <para>
Check out the source in a new directory.
The new directory is named after the freeze tag that you have set.
</para>
	    </listitem>

	    <listitem>
	      <para>
Make the <command>ant</command> executable.
</para>
	    </listitem>

	    <listitem>
	      <para>
Build the core ArgoUML.
</para>
	      <para>
This is done in the
<filename class="directory">argouml/src_new</filename>
directory of the newly created copy
by using the <command>package</command> ant target!
</para>
	    </listitem>

	    <listitem>
	      <para>
Build the sub-projects and modules to be included in the release.
</para>
	    </listitem>

	    <listitem>
	      <para>
Download docboox-xsl.
</para>
	      <para>
This is normally done using the <command>docbook-xsl-get</command> ant target.
</para>
	    </listitem>

	    <listitem>
	      <para>
Copy the file <filename>JimiProClasses.zip</filename>.
</para>
	      <para>
This is done automatically from the working copy you have alongside.
If not, you will be asked to copy this in manually.
</para>
	      <para>
Jimi is downloaded separately.
See 
<xref linkend="download-jimi" endterm="download-jimi-name"/>.
</para>
	    </listitem>

	    <listitem>
	      <para>
Build the PDF documentation.
</para>
	    </listitem>

	    <listitem>
	      <para>
Run through the automatic tests!
</para>
	      <para>
This is done by issuing the command
<command>build alltests</command>
in the <filename class="directory">argouml/src_new</filename> directory.
</para>
		    <para>
There should not be any failed tests. 
(See details on where to find the result in
<xref linkend="junittests"></xref>).
</para>
		    <para>
If the tests did not pass See <xref linkend="release_process_test_failed"/>.
</para>
	    </listitem>

	    <listitem>
	      <para>
Sign all jar files.
</para>
	    </listitem>
	  </orderedlist>
	</listitem>

	    <listitem>
	  <para>Test the release manually!</para>
	      <para>
The purpose of this is to make sure that there isn't any problem
introduced by the release procedure and that the jar files contains
the correct list of jars.
</para>
	      <para>
Start using the command
<programlisting>
cd VERSION_<replaceable>X_Y_Z</replaceable>_F/argouml/build
java -jar argouml.jar
cd ../../..
</programlisting>
and do some ad-hoc testing.
</para>
	    </listitem>

	    <listitem>
	      <para>
Set the release tag.
</para>
	  <para>
The following command will do it for you:
<programlisting>
cd VERSION_<replaceable>X_Y_Z</replaceable>_F
for proj in *
do
    ( cd $proj &amp;&amp; cvs tag VERSION_<replaceable>X_Y_Z</replaceable> )
done
cd ..
</programlisting>
</para>
	    </listitem>

	    <listitem>
	      <para>
Run the script
<filename>argouml/tools/bin/pack-release.sh</filename>
</para>
	  <para>
This will:
</para>
	  <orderedlist>
	    <listitem>
	      <para>
Create the files
<filename>ArgoUML-<replaceable>VERSION</replaceable>-libs.tar.gz</filename>,
<filename>ArgoUML-<replaceable>VERSION</replaceable>-libs.zip</filename>,
<filename>ArgoUML-<replaceable>VERSION</replaceable>-modules.tar.gz</filename>,
<filename>ArgoUML-<replaceable>VERSION</replaceable>-modules.zip</filename>,
<filename>ArgoUML-<replaceable>VERSION</replaceable>-src.tar.gz</filename>,
<filename>ArgoUML-<replaceable>VERSION</replaceable>-src.zip</filename>,
<filename>ArgoUML-<replaceable>VERSION</replaceable>-app.tgz</filename>,
<filename>ArgoUML-<replaceable>VERSION</replaceable>.tar.gz</filename>,
<filename>ArgoUML-<replaceable>VERSION</replaceable>.zip</filename>, and
<filename>index.html</filename>.
There should also be a subdirectory
<filename class="directory">argouml/argouml-<replaceable>VERSION</replaceable>/jws</filename>
with .jar and .jnlp files.
</para>
	    </listitem>

	    <listitem>
	      <para>
Copy the files in place in the svn directory.
</para>
	      <para>
A tree with all files is located in 
<filename>argouml-<replaceable>version</replaceable></filename>.
It is copied to
<filename>svn/argouml-downloads/trunk/www/</filename>.
</para>
	    </listitem>

	  </orderedlist>
	</listitem>

	<listitem>
	  <para>
Commit the release in the SVN download project.
</para>
	  <para>
The commands you would do for this are
<programlisting>
cd ../svn/argouml-downloads/trunk/www
svn add argouml-<replaceable>VERSION</replaceable>
svn commit -m'Upload the release <replaceable>VERSION</replaceable>'
</programlisting>
</para>
	</listitem>

	<listitem id="issuezilla_release_maintenance">
	  <para>
Go through Issuezilla and check things.
</para>
	  <para>
Things to check are:
</para>
	  <orderedlist>
	    <listitem>
	      <para>
That there is a Version created in Issuezilla for the newly created release.
</para>
	      <para>
The purpose of this is to make it possible for everyone 
to report bugs on the new release.
</para>
	    </listitem>
	    <listitem>
	      <para>
Make sure that the upcoming releases have 
target milestones created for them.
This needs to be done for all components that has the same
release scheme.
Also see that the numbering is the same in all components and
that it is in the correct chronological order
except for the not yet done releases that come before the already completed.
</para>
	    </listitem>
	    <listitem>
	      <para>
Change the target milestones of all the not yet resolved issues 
for this release to ---.
</para>
	    </listitem>
	    <listitem>
	      <para>
Change the target milestones of
any fixed issue
in component argouml
with target milestone ---
to that of the current release.
</para>
	      <para>
This is probably some developer that has fixed an issue but forgotten to
set the target milestone correctly.
</para>
	    </listitem>
	    <listitem>
	      <para>
Move all issues reported on 'current' to this release
(for the component argouml).
</para>
	      <para>
These items were reported between the previous version and this version.
Since 'current' will be reused for the next release, they need to be
locked to the closest release to where they were found.
</para>
	    </listitem>
	    <listitem id="reopen_remind_and_later">
	      <para>Reopen RESOLVED/REMIND</para>
	      <para>
This can also be a good time to change all 
RESOLVED/REMIND.
Search for them and Reopen them.
</para>
	    </listitem>
	    <listitem id="check_for_later">
	      <para>Check RESOLVED/LATER</para>
	      <para>
It could also be good to check that all
RESOLVED/LATER has a valid target milestone (must be an upcoming milestone).
Search for them and Reopen the ones that haven't.
Also, if the milestone denotes or is going to be resolved in
the upcoming release, Reopen them with a comment that they are now
active.
</para>
	    </listitem>
	  </orderedlist>
	</listitem>
	  
	<listitem>
	  <para>Notify persons responsible for installers</para>
	  <para>
This is done by sending a mail on the
<ulink url="mailto:dev@argoumlinstallers.tigris.org">
  installers mailing list
</ulink>.
</para>
   	</listitem>
	  
	<listitem>
	  <para>Make announcements!</para>
	  <para>
Add the index file to the directory
<filename type="directory">argouml/www/download</filename>
so that it will show up at the URL
<ulink url="http://argouml.tigris.org/download/releaseXXX.html"
  >http://argouml.tigris.org/download/release<replaceable>012345</replaceable>.html</ulink>.
</para>
	  <para>
Add new file to the File Sharing area under the correct release.
Since a release is made, the Status of the files is "Baselined".
Use the URL added in the previous paragraph as Link.
</para>
	  <para>
Write a News announcement in the argouml project.

The announcement shall include
a statement on what kind of release this is,
information on what major things that have changed
(for stable releases this is a list of what
has changed since the last stable release).

It could also include
the list of resolved issues,
a list of serious known problems with this release 
(stable releases shouldn't have any),
technical details on how the release was built, and
the plan for the following release.
</para>
	  <para>
Write a short note on 
the users list (for development releases), and
announce lists (for stable releases or major breakthroughs).
Include the link to the new item.
</para>
	  <para>
Freshmeat: currently Thierry Lach does the Freshmeat announcements
which require a login so just inform him.
</para>
	</listitem>
      </orderedlist>
</para>

      <sect2 id="release_process_test_failed">
	<title>The release did not work</title>
	<indexterm>
	  <primary>Troubleshooting</primary>
	  <secondary>during the release work</secondary>
	</indexterm>
	<para>
This shouldn't happen! This really shouldn't happen!
</para>
	<para>
The reason that this has happened is that one of the developers 
has made a mistake.
You now must decide a way forward.
</para>
	<sect3 id="release_work_fix_problem_yourself">
	  <title>Fix the problem yourself.</title>
	  <para>
If the problem is obvious to you and you can fix it quickly, do so.
This is done by doing the following:
<itemizedlist>
	      <listitem>
		<para>Make the release tag into a branch</para>
		<para>
<command>cvs rtag -b -r VERSION_<replaceable>X_Y_Z</replaceable>_F BRANCH_<replaceable>X_Y_Z</replaceable></command>
</para>
	      </listitem>
	      <listitem>
		<para>Update your checked out copy to be on that branch</para>
		<para>
<command>cvs update -r BRANCH_<replaceable>X_Y_Z</replaceable></command>
</para>
	      </listitem>
	      <listitem>
		<para>Fix the problem in your checked out copy</para>
	      </listitem>
	      <listitem>
		<para>Commit the problem in the branch</para>
		<para>
<command>cvs commit -m'Fix of problem blabla'</command>
</para>
	      </listitem>
	      <listitem>
		<para>Continue the build process</para>
		<para>
This is done by restarting the <command>build dist-release</command>-command
and from that point on working in the branch instead of at the tag.
</para>
	      </listitem>
	      <listitem>
		<para>
Explain to the culprit what mistakes he has made and how to fix it.
</para>
		<para>
It is now his responsibility to make sure that the problem will not
appear in the next version.
He can do this either by merging in your fix or by fixing the problem
in some other way.
</para>
		<para>
At this point an in-detail description of how poor programming skills
the culprit has and how ugly his mother is, is probably in place but
please keep it constructive!
Remember, you might be mistaken when you guess who the responsible is.
</para>
	      </listitem>
	    </itemizedlist>
</para>
	</sect3>

	<sect3>
	  <title>
Delay the release waiting for someone to fix the problem.
</title>
	  <para>
Create the branch as described in 
<xref linkend="release_work_fix_problem_yourself"/>.
Then tell the culprit and everyone on the developer list
what the problem is and that it is to be fixed in the
release branch a.s.a.p.
</para>
	  <para>
Monitor the changes made to the branch to verify that
no one commits anything else but the solutions to the
problems.
</para>
	  <para>
When you get notified that it is completed, 
update your checked out copy and continue the release work.
</para>
	</sect3>
      </sect2>

</sect1>

</chapter>

<!-- Local stuff for Emacs - please do not delete

Local Variables:
mode: xml
sgml-doctype: "cookbook.xml"
sgml-parent-document: ("cookbook.xml" "chapter" nil)
sgml-validate-command: "nsgmls -wxml -sv ../docbook-setup/xml.dcl \
  cookbook.xml"
End:

-->
