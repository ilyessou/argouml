# $Id$
# Copyright (c) 2004-2005 The Regents of the University of California. All
# Rights Reserved. Permission to use, copy, modify, and distribute this
# software and its documentation without fee, and without a written
# agreement is hereby granted, provided that the above copyright notice
# and this paragraph appear in all copies.  This software program and
# documentation are copyrighted by The Regents of the University of
# California. The software program and documentation are supplied "AS
# IS", without any accompanying services from The Regents. The Regents
# does not warrant that the operation of the program will be
# uninterrupted or error-free. The end-user understands that the program
# was developed for research purposes and is advised not to rely
# exclusively on the program for any reason.  IN NO EVENT SHALL THE
# UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
# SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
# UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
#
# Created from UMLCognitiveResourceBundle_es.java
#
# The keys are generated from the class names of the classes that use them.
#

# SPECIAL CHARACTER CODES //////////////////////////////////////////
#
# To avoid breaking the build, high characters must be Unicode-encoded
# (\udddd notation). Just use the native2ascii tool (included with 
# Java2). Example for Latin-1 to Unicode: 
#     java sun.tools.native2ascii.Main -encoding ISO8859_1 native.java unicode.java
#
# To perform the reverse operation add -reverse. 
#
# See native2ascii documentation: <jdk-path>/docs/tooldocs/win32/native2ascii.html
# See supported encodings: <jdk-path>/docs/guide/intl/encoding.doc.html 
#
#
# LITTLE DICTIONARY ////////////////////////////////////////////////
#
# This translation is based on "El Lenguaje Unificado de Modelado", Booch, 
# Rumbaugh, Jacobson. Almost every term is a direct translation. This is a 
# sample..
#
# activity diagram: diagrama de actividades
# aggregation (white diamond): agregaci\u00f3n (diamante blanco)
# association: asociaci\u00f3n
# attribute: atributo
# branch transitions: transiciones de divisi\u00f3n
# call-action: evento de llamada
# class diagram: diagrama de clases
# classifier: clasificador
# collaboration diagram: diagrama de colaboraci\u00f3n
# component diagram: diagrama de componentes
# composite (black diamond): composici\u00f3n o agregaci\u00f3n compuesta (diamante negro)
# connection: conexi\u00f3n
# component: componente
# deployment diagram: diagrama de despliegue
# fork transitions: transiciones de bifurcaci\u00f3n
# framework: framework
# guard: guarda 
# join transitions: transiciones de uni\u00f3n
# node: nodo
# object diagram: diagrama de objetos
# operation: operaci\u00f3n
# rol: papel
# send-action: se\u00f1al 
# sequence diagram: diagrama de secuencia
# state diagram: diagrama de estados
# trigger: disparador
# use cases: casos de uso

critics.CrAssocNameConflict-head = Resuelve conflicto en el nombre de la asociaci\u00f3n
critics.CrAssocNameConflict-desc = Todo elemento del espacio de nombres debe tener un nombre \u00fanico. \n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente los elementos y usa la solapa Propiedades para cambiar sus nombres.

critics.CrAttrNameConflict-head = Revisa los nombres de atributos para evitar conflictos
critics.CrAttrNameConflict-desc = Los atributos deben tener nombres diferentes. Esto se debe  quiza a un atributo heredado. \n\nUsar nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el atributo en conflicto de la clase y cambia su nombre.

critics.CrOperNameConflict-head = Cambia los nombres o firmas en <ocl>self</ocl>
critics.CrOperNameConflict-desc = Dos operaciones tienen exactamente la misma firma.  Deber\u00edan ser distintas.  Una firma es una combinaci\u00f3n del nombre de la operaci\u00f3n, y sus tipos de parametros. \n\nEvitar firmas en conflicto es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente las operaciones en conflicto de esta clase y cambia su nombre o sus parametros.

critics.CrCircularAssocClass-head = MAssociation circular
critics.CrCircularAssocClass-desc = Las AssociationClasses no pueden incluir papeles que se refieran directamente a la MAssociationClass.

critics.CrCircularInheritance-head = Quita la herencia circular del <ocl>self</ocl>
critics.CrCircularInheritance-desc = Las relaciones de herencia no pueden tener ciclos. \n\nSe necesita una jerarquia legal de clases para la generaci\u00f3n de c\u00f3digo y la correcci\u00f3n del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente uno de las flechas de generalizaci\u00f3n en el ciclo y quitala.

critics.CrCircularComposition-head = Quita la composici\u00f3n circular
critics.CrCircularComposition-desc = Las relaciones de composici\u00f3n (diamantes negros) no pueden tener ciclos. \n\nUna jerarqu\u00eda legal de agregaci\u00f3n se necesita para la generaci\u00f3n de c\u00f3digo y la correcci\u00f3n del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente una de las asociaciones en el ciclo y quitala o cambia su agregaci\u00f3n a otra que no sea composici\u00f3n.

critics.CrCrossNamespaceAssoc-head = Papel agregado en una MAssociation N-caminos
critics.CrCrossNamespaceAssoc-desc = Cada clase o MInterface implicado en una MAssociation deber\u00eda estar en el MNamespace de la MAssociation.\n

critics.CrDupParamName-head = Nombre de parametro duplicado
critics.CrDupParamName-desc = Cada parametro de una operaci\u00f3n debe tener un nombre \u00fanico. \n\nUsar nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o renombra manualmente uno de los parametros de esta operaci\u00f3n.

critics.CrDupRoleNames-head = Cambia los nombres de papel de <ocl>self</ocl>
critics.CrDupRoleNames-desc = La MAssociation <ocl>self</ocl> tiene dos papeles con nombres en conflicto. \n\nUsar nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente <ocl>self</ocl> y usa la solapa de propiedades para cambiar los nombres de papel.

critics.CrFinalSubclassed-head = Quita la palabra clave final y las subclases.
critics.CrFinalSubclassed-desc = En Java, la palabra clave 'final' indica que una clase no deber\u00eda tener subclases. .  Esta clase esta etiquetada final y tiene subclases.\n\nUna jerarqu\u00eda de clases meditada y que permita la adecuada subclasificaci\u00f3n es un parte importante para conseguir un dise\u00f1o comprensible y mantenible.\n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente la clase y cambia su superclase, o selecciona la superclase y usa la solapa de propiedades para quitar la palabra clave 'final'.

critics.CrIllegalGeneralization-head = MGeneralization ilegal
critics.CrIllegalGeneralization-desc = Los elementos MModel solo pueden ser heredados por otros del mismo tipo. \n\nSe necesita una jerarqu\u00eda correcta para la generaci\u00f3n de c\u00f3digo y la correcci\u00f3n del dise\u00f1o.Se necesita una jerarqu\u00eda correcta para la generaci\u00f3n de c\u00f3digo y la correcci\u00f3n del dise\u00f1o.\n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente la flecha de generalizaci\u00f3n y quitala.

critics.CrAlreadyRealizes-head = Quita el realiza innecesario de <ocl>self</ocl>
critics.CrAlreadyRealizes-desc = La clase seleccionada ya realiza indirectamente el MInterface {item.extra}.  No hay necesidad de realizarlo otra vez.\n\nSimplificar el dise\u00f1o siempre es bueno.Simplificar el dise\u00f1o siempre es bueno.  Puedes descartar este elemento \"por hacer\" si quieres destacar que la clase seleccionada realiza este MInterface.\n\nPara arreglar esto, selecciona la Realizaci\u00f3n (l\u00ednea punteada con una flecha blanca triangular) y pulsa la tecla \"Delete\".

critics.CrInterfaceAllPublic-head = Las operaciones de los interfaces deben ser p\u00fablicas
critics.CrInterfaceAllPublic-desc = Los Interfaces especifican las operaciones que otras clases deben implementar.  Deben ser p\u00fablicos. \n\nUn conjunto de interfaces bien dise\u00f1ado es un buen modo de definir las posibles extensiones de un framework de clases. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente las operaciones del interfaz y usa la solapa de propiedades para hacerlas publicas.

critics.CrInterfaceOperOnly-head = Los interfaces solo deben tener operaciones
critics.CrInterfaceOperOnly-desc = Los Interfaces especifican las operaciones que otras clases deben implementar.  No implementan esas operaciones ellos mismos , y no pueden tener atributos. \n\nUn conjunto de interfaces bien dise\u00f1ado es un buen modo de definir las posibles extensiones de un framework de clases. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el interfaz y usa la solapa Propiedades para quitar todos los atributos.

critics.CrMultipleAgg-head = Papeles agregados multiples
critics.CrMultipleAgg-desc = Solo un papel de una MAssociation puede tener un agregado o compuesto.\n\nUna jerarqu\u00eda es-parte-de clara y consistente es clave para la claridad del dise\u00f1o, almacenamiento de objetos, e implementaci\u00f3n de m\u00e9todos recursivos.\nPara arreglar esto, selecciona la MAssociation y establece algunos de sus papeles de agregaci\u00f3n a Ninguno.

critics.CrNWayAgg-head = Papel agregado en una relaci\u00f3n de N-caminos MAssociation
critics.CrNWayAgg-desc = Las asociaciones de 3 o m\u00e1s caminos no pueden tener aggregate ends.\n\nUna consistente y clara jerarquia es-parte-de es clave para la claridad del dise\u00f1o, el almacenamiento mantenible de objetos, y la implementaci\u00f3n de m\u00e9todos recursivos.\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente the MAssociation y establece todos los role aggregations a None.

critics.CrNavFromInterface-head = Quita la navegaci\u00f3n del MInterface <ocl>self</ocl>
critics.CrNavFromInterface-desc = Las asociaciones que implican un MInterface no pueden ser navegables en la direcci\u00f3n desde el MInterface.  Esto se debe a que los interfaces contienen solo declaraciones de operaciones y no pueden contener punteros a otros objetos.\n\nEsta parte del dise\u00f1o deber\u00eda cambiarse antes de generar el c\u00f3digo de este dise\u00f1o.  Si generas c\u00f3digo antes de arreglar este problema, el c\u00f3digo no se ajustar\u00e1 al dise\u00f1o.\n\nPara arreglar esto, selecciona la MAssociation y usa la solapar \"Propiedades\" para tab to desactivar Navigable para el extremo que toca el MInterface.  La MAssociation deber\u00eda parecer entonces con una flecha apuntado fuera del MInterface.

critics.CrUnnavigableAssoc-head = Haz navegable a <ocl>self</ocl>
critics.CrUnnavigableAssoc-desc = La MAssociation <ocl>self</ocl> no es navegable en ninguna direcci\u00f3n. Todas las asociaciones deber\u00edan ser navegables al menos en una direcci\u00f3n.\n\nEstablecer la navegabilidad de las asociaciones permite al c\u00f3digo acceder a los datos siguiendo los punteros. \n\nPara arreglar esto, selecciona la asociaci\u00f3n \"<ocl>self</ocl>\" en el diagrama o panel de navegaci\u00f3n y haz click en la solapa de propiedades.  Luego usa los checkboxes al fondo del panel de propiedades para activar la navegabilidad. 

critics.CrNameConflictAC-head = El nombre del papel esta en conflicto con el miembro
critics.CrNameConflictAC-desc = Los nombres de papel MAssociation de la MAssociationClass no deben estar en conflicto con los nombres de las caracter\u00edsticas estructurales (por ejemplo las variables de instancia) de la clase.\n

critics.CrMissingClassName-head = Escoge un nombre
critics.CrMissingClassName-desc = Cada clase e interfaz de un paquete deber\u00eda tener un nombre. \n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente la clase y usa la solapa Propiedades para asignarle un nombre.

critics.CrMissingAttrName-head = Escoge un nombre
critics.CrMissingAttrName-desc = Todo atributo debe tener un nombre.. \n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el atributo y usa la solapa Propiedades para darle un nombre.

critics.CrMissingOperName-head = Escoge un nombre
critics.CrMissingOperName-desc = EToda operaci\u00f3n debe tener un nombre.. \n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el atributo y usa la solapa Propiedades para darle un nombre.

critics.CrMissingStateName-head = Escoge un nombre
critics.CrMissingStateName-desc = Todo estado de una m\u00e1quina de estados deber\u00eda tener un nombre. \n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el estado y usa la solapa Propiedades para darle un nombre, o selecciona el estado y escribe un nombre.

critics.CrNoInstanceVariables-head = A\u00f1ade variables de instancia a <ocl>self</ocl>
critics.CrNoInstanceVariables-desc = Aun no has especificado variables de instancia para <ocl>self</ocl>. Normalmente las clases tienen variables de instancia que almacenan la informaci\u00f3n para cada instancia. Las clases que solo proporcionan atributos y m\u00e9todos est\u00e1ticos deber\u00edan ser estereotipadas con <<utility>>.\n\nQuiza deber\u00edas definir las variables de instancia para completar la parte de representaci\u00f3n de la informaci\u00f3n de tu dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade variables de instancia haciendo doble click en <ocl>self</ocl> en el panel de navegaci\u00f3n o usando el menu Crear para crear un nuevo atributo. 

critics.CrNoAssociations-head = A\u00f1ade asociaciones a <ocl>self</ocl>
critics.CrNoAssociations-desc = Aun no has especificado asociaciones para <ocl>self</ocl>. Normalmente las clases, actores, y casos de uso estan asociadas con otras. \n\nDefinir las asociaciones entre objetos es una parte importante del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade las asociaciones manualmente pulsando en la herramienta de asociaci\u00f3nen la barra de tareas y arrastrando desde <ocl>self</ocl> a otro nodo. 

critics.CrNonAggDataType-head = Envuelve MDataType
critics.CrNonAggDataType-desc = Los DataTypes no son clases y no pueden ser asociadas con clases, a menos que el MDataType sea parte de una agregaci\u00f3n compuesta (diamante negro). \n\nUn buen dise\u00f1o OO depende de elecciones cuidadosas acerca de que entidades representar como objetos y cuales representar como atributos de objetos.\n\nPara arreglar esto, use el bot\u00f3n \"Siguiente>\" , o reemplace manualmente el MDataType con una clase, o cambie la asociaci\u00f3n de agregaci\u00f3n a una clase.\n

critics.CrOppEndConflict-head = Renombra los papeles MAssociation
critics.CrOppEndConflict-desc = Dos papeles de <ocl>self</ocl> tienen el mismo nombre. Los papeles deben tener nombres distintos.  Esto quiza sea debido a un atributo heredado. \n\nUsar nombres claros y no ambiguos es clave para la generaci\u00f3n de c\u00f3digo y la producci\u00f3n de un dise\u00f1o f\u00e1cil de entender y mantener.\n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el papel en conflicto en el extremo de la asociaci\u00f3n de esta clase y cambia su nombre.

critics.CrParamTypeNotImported-head = Importa el tipo MParameter en la clase
critics.CrParamTypeNotImported-desc = El tipo del parametro de cada operaci\u00f3n debe ser visible y haber sido importado en la clase que posee dicha operaci\u00f3n.\n\nImportar clases es necesario para la generaci\u00f3n de c\u00f3digo. Una buena modularizaci\u00f3n de clases en paquetes es clave para conseguir un dise\u00f1o f\u00e1cil de entender.\n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o a\u00f1ade manualmente un import a la clase que posee esta operaci\u00f3n.

critics.CrUselessAbstract-head = Define (Sub)Clases concretas
critics.CrUselessAbstract-desc = <ocl>self</ocl> resulta superfluo en el sistema porque ni \u00e9l ni sus subclases pueden tener instancias. \n\nPara areglar este problem : (1) define subclases concretas que implementen el interface de esta clase; o (2) haz concreto <ocl>self</ocl> o una de sus subclases .

critics.CrUselessInterface-head = Define una class para implementar <ocl>self</ocl>
critics.CrUselessInterface-desc = <ocl>self</ocl> no es usado porque ninguna clase lo implementa.\n\nPara arreglar este problema, pulsa el bot\u00f3n \"Siguiente>\" o usa el bot\u00f3n \"Class\" de la barra de herramientas para definir clases y el bot\u00f3n \"Realizes\" para crear una relaci\u00f3n de la clase al interfaz realzado.

critics.CrDisambigClassName-head = Escoge un nombre \u00fanico para <ocl>self</ocl>
critics.CrDisambigClassName-desc = Toda clase e interfaz de un paquete debe tener un nombre \u00fanico. Hay al menos dos elementos en este paquete llamados \"<ocl>self</ocl>\".\n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente una de las clases en conflicto y usa la solapa Propiedades para cambiar sus nombres.

critics.CrDisambigStateName-head = Escoge un nombre \u00fanico para <ocl>self</ocl>
critics.CrDisambigStateName-desc = Todo estado de una m\u00e1quina de estados debe tener un nombre \u00fanico. Hay al menos dos estados en esta m\u00e1quina llamados \"<ocl>self</ocl>\".\n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente uno de los estados en conflicto y usa la solapa \"Propiedades\" para cambiar sus nombres.

critics.CrConflictingComposites-head = Quita las agregaciones compuestas en conflicto
critics.CrConflictingComposites-desc = Un papel de composici\u00f3n (diamante negro) de una association indica que las instancias de esta clase contienen instancias de las associated classes. Puesto que cada instancia solo puede ser contenida en uno de los otros objetos, cada objeto puede ser 'parte' en al menos una relaci\u00f3n es-parte-de.\n\nUn buen dise\u00f1o OO depende de construir buenas relaciones es-parte-de.\n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o cambia manualmente una de las asociaciones para que tenga multiplicidad 0..1 o 1..1, u otra clase de agregaci\u00f3n (por ejemplo, un diamante blanco es menos estricto), o quita una de las asociaciones

critics.CrTooManyAssoc-head = Reduce las asociaciones en <ocl>self</ocl>
critics.CrTooManyAssoc-desc = Hay demasiadas asociaciones en la clase <ocl>self</ocl>.  Cuando una clase es centraliza demasiado el dise\u00f1o puede convertirse en un cuello de botella que debe ser acutalizado frecuentemente. \n\nDefinir las asociaciones entre los objetos es una parte importante del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita las asociaciones manualmente pulsando en una asociaci\u00f3n en el panel de navegaci\u00f3n o diagrama y pulsando la tecla \"Del\". 

critics.CrTooManyAttr-head = Reduce los atributos de <ocl>self</ocl>
critics.CrTooManyAttr-desc = Hay demasiados atributos en la clase <ocl>self</ocl>.  Cuando una clase es centraliza demasiado el dise\u00f1o puede convertirse en un cuello de botella que debe ser acutalizado frecuentemente. \n\nDefinir los atributos de los objetos es una parte importante del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita manualmente los atributos haciendo doble click en el compartimiento de la clase realzada en el diagrama y quitando la l\u00ednea de texto para un atributo. 

critics.CrTooManyOper-head = Reduce las operaciones de <ocl>self</ocl>
critics.CrTooManyOper-desc = Hay demasiadas operaciones en la clase <ocl>self</ocl>.  Cuando una clase es centraliza demasiado el dise\u00f1o puede convertirse en un cuello de botella que debe ser acutalizado frecuentemente. \n\nDefinir las operaciones de un objeto es una parte importante del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita manualmente los atributos haciendo doble click en el compartiemiento de la operaci\u00f3n de la clase realzada en el diagrama y quitando la l\u00ednea de texto para la operaci\u00f3n. 

critics.CrTooManyStates-head = Reduce estados en la m\u00e1quina <ocl>self</ocl>
critics.CrTooManyStates-desc = Hay demasiados estados en <ocl>self</ocl>.  Si una m\u00e1quina de estados tiene demasiados estados puede resultar dif\u00edcil de entender. \n\nDefinir un conjunto de estados f\u00e1cil de entender es una parte importante del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita manualmente los estados pulsando en los estados en el panel de navegaci\u00f3n o el diagrama y pulsando la tecla \"Del\".  O podr\u00edas anidar estados...

critics.CrTooManyTransitions-head = Reduce transitions en <ocl>self</ocl>
critics.CrTooManyTransitions-desc = Hay demasiadas transiciones en el estado <ocl>self</ocl>.  Cuando un estado queda demasiado centralizado en la m\u00e1quina puede convertirse en un cuello de botella que requiera frecuentes actualizaciones. \nDefinir las transiciones entre estados es una parte importante del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita manualmente las transiciones pulsando en una transici\u00f3n en el panel de navegaci\u00f3n o diagramay pulsando la tecla \"Del\". 

critics.CrTooManyClasses-head = Reduce clases en el diagrama <ocl>self</ocl>
critics.CrTooManyClasses-desc = Hay demasiados classes in <ocl>self</ocl>.  Si un diagrama de clases tiene demasiadas clases puede resultar dif\u00edcil de entender. \n\nDefinir un conjunto de diagramas de clases f\u00e1cil de entender es una parte importante del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita las clases manualmente pulsando en una clase en el panel de navegaci\u00f3n o diagrama y pulsando la tecla \"Del\".  O podr\u00edas hacer un nuevo diagrama...

critics.CrNoTransitions-head = A\u00f1ade transiciones a <ocl>self</ocl>
critics.CrNoTransitions-desc = MState <ocl>self</ocl> no tiene transiciones entrantes o salientes. Normalmente los estados tienen transiciones entrantes y salientes. \n\nDefinir transiciones de estados completas es necesario para la parte de especificaci\u00f3n de comportamiento de tu dise\u00f1o.  \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade transiciones manualmente pulsando en la herramienta de transiciones en la barra de herramientas y arrastrando desde otro estado a <ocl>self</ocl> o desde <ocl>self</ocl> a otro estado. 

critics.CrNoIncomingTransitions-head = A\u00f1ade transiciones entrantes a <ocl>self</ocl>
critics.CrNoIncomingTransitions-desc = MState <ocl>self</ocl> no tiene transiciones entrantes. Normalmente los estados tienen transiciones entrantes y salientes. \n\nDefinir transiciones de estados completas es clave para completar la especificaci\u00f3n de comportamiento del dise\u00f1o. Sin transiciones entrantes, este estado nunca puede ser alcanzado.\n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade manualmente transiciones pulsando en la herramienta de transiciones en la barra de herramientas y arrastrando esde otro estado a <ocl>self</ocl>. 

critics.CrNoOutgoingTransitions-head = A\u00f1ade transiciones salientes desde <ocl>self</ocl>
critics.CrNoOutgoingTransitions-desc = MState <ocl>self</ocl> no tiene transacciones salientes. Normalmente los estados tienen transiciones entrantes y salientes. \n\nDefinir transacciones de estados completas es necesario para completar la especificaci\u00f3n de comportamiento del dise\u00f1o.  Sin transiciones salientes este estado esta \"muerto\" y nunca se puede salir de \u00e9l.\n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade manualmente transiciones pulsando en la herramienta de transiciones en la barra de herramientas y arrastrando desde otro estado a <ocl>self</ocl>. 

critics.CrMultipleInitialStates-head = Quita los estados inicialies que sobran
critics.CrMultipleInitialStates-desc = Hay multiples y ambiguos estados iniciales en esta m\u00e1quina. Normalmente cada m\u00e1quina de estados o composite state tiene un estado inicial. \n\nDefinir estados no ambiguos es necesario para completar la parte de definici\u00f3n de comportamiento del dise\u00f1o.\n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o selecciona manualmente uno de los estados y quitalo. 

critics.CrNoInitialState-head = Pon un MState inicial
critics.CrNoInitialState-desc = No hay estado inicial en esta m\u00e1quina o composite state. Normalmente cada m\u00e1quina o composite state tiene un estado inicial. \n\nDefinir estados no ambiguos es necesario para completar la definici\u00f3n de comportamiento del dise\u00f1o.\n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade manualmente un estado inicial usando la barra de herramientas y a\u00f1adelo al diagrama. 

critics.CrNoTriggerOrGuard-head = A\u00f1ade un disparador o guarda a la transici\u00f3n
critics.CrNoTriggerOrGuard-desc = La transici\u00f3n destacada es incompleta porque no tiene disparador ni condici\u00f3n de guarda.  Los disparadores son eventos que producen una transici\u00f3n. Las condiciones de guarda deben ser verdaderas para que la transici\u00f3n se produzca.  Si solo se usa una guarda, la transici\u00f3n se produce cuando la condici\u00f3n es verdadera.\n\nEste problema debe ser resuelto para completar la m\u00e1quina de estados.\n\nPara arreglar esto, selecciona la transition y usa la solapa \"Propiedades\", o selecciona la transition y escribe texto con el formato:\nDISPARADOR [GUARDA] / ACCI\u00d3N\ndonde DISPARADOR es el nombre de un evento, GUARDA es una expresi\u00f3n booleana, y ACCI\u00d3N es una acci\u00f3n a realizar cuando se produce MTransition.  Las tres partes son opcionales.

critics.CrNoGuard-head = A\u00f1ade MGuard a la transici\u00f3n
critics.CrNoGuard-desc = La transici\u00f3n destacada esta incompleta porque no tiene guard condition.  Las condiciones MGuard deben ser verdaderas para que la transici\u00f3n se produzca.  Si solo se usa una guarda, la transici\u00f3n se produce cuando la condici\u00f3n es verdadera.\n\nEste problema debe ser resuelto para completar la m\u00e1quina de estado.\n\nPara arreglar esto, selecciona la MTransition y usa la solapa \"Propiedades\", o selecciona la MTransition y escribe algun texto con el formato:\n[GUARDA]\nDonde GUARDA es una expresi\u00f3n booleana.

critics.CrInvalidFork-head = Cambia las transiciones de bifurcaci\u00f3n
critics.CrInvalidFork-desc = Este estado de bifurcaci\u00f3n tiene un n\u00famero invalido de transiciones. Normalmente los fork states tienen una transici\u00f3n entrante y dos o m\u00e1s salientes. \n\nDefinir transiciones de estado correctas es neceario para completar la especificaci\u00f3n de comportamiento del dise\u00f1o.  \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita manualmente las transiciones pulsando en una transici\u00f3n en el diagrama y pulsando la tecla Delete. 

critics.CrInvalidJoin-head = Cambia las transiciones de uni\u00f3n
critics.CrInvalidJoin-desc = Este estado de uni\u00f3n tiene un n\u00famero invalido de transiciones. Normally join states tienen dos o m\u00e1s transiciones entrantes y una saliente. \n\nDefinir correctamente la transici\u00f3n de estados es necesario para completar la especificaci\u00f3n de comportamiento del dise\u00f1o.  \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita las transiciones manualmente pulsando en la transici\u00f3n en el diagrama y pulsando la tecla Delete. 

critics.CrInvalidBranch-head = Cambia las transiciones de divisi\u00f3n
critics.CrInvalidBranch-desc = Este estadod de divisi\u00f3n tiene un n\u00famero invalido de transiciones. Normalmente los estados de divisi\u00f3n tienen una transici\u00f3n entrante y dos o m\u00e1s salientes. \n\nDefinir correctamente la transici\u00f3n de estados es necesario para completar la especificaci\u00f3n de comportamiento del dise\u00f1o.  \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita transitions manualmente pulsando en la transici\u00f3n en el diagrama y pulsando la tecla Delete, o a\u00f1ade transiciones usando la herramienta de transiciones.

critics.CrEmptyPackage-head = A\u00f1ade elementos al paquete <ocl>self</ocl>
critics.CrEmptyPackage-desc = Aun no has puesto nada en el paquete <ocl>self</ocl>. Normalmente los paquetes contienen grupos de clases relacionadas.\n\nDefinir y usar paquetes es clave para un dise\u00f1o mantenible. \n\nPara arreglar esto, selecciona el paquete <ocl>self</ocl> en el panel de navegaci\u00f3n y a\u00f1ade los diagramas o modelos como clases o casos de uso. 

critics.CrNoOperations-head = A\u00f1ade operaciones a <ocl>self</ocl>
critics.CrNoOperations-desc = Aun no has especificado operaciones para <ocl>self</ocl>. Normalmente las clases proporcionan operaciones que definen su comportamiento. \n\nNecesitas definir operaciones para completar la parte de especificaci\u00f3n de la comportamiento del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade operaciones manualmente pulsando en <ocl>self</ocl> en el panel de navegaci\u00f3n y usando el menu\u00fa Crear para hacer nuevas operaciones. 

critics.CrConstructorNeeded-head = A\u00f1ade constructor a <ocl>self</ocl>
critics.CrConstructorNeeded-desc = Aun no has definido un constructor para la clase <ocl>self</ocl>. Los constructores inicializan nuevas instancias dotando de valores v\u00e1lidos a sus atributos.  Esta clase probablemente necesite un constructor porque no todos sus atributos tienen valores iniciales. \n\nDefinir buenos constructores es clave para establecer class invariants, y class invariants son una poderosa ayuda para escribir c\u00f3digo s\u00f3lido. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade manualmente un constructor pulsando en <ocl>self</ocl> en el panel de navegaci\u00f3n y usando el men\u00fa Create para hacer un constructor nuevo. 

critics.CrNameConfusion-head = Revisa los nombres para evitar confusiones
critics.CrNameConfusion-desc = Los nombres deber\u00edan distinguirse claramente unos de otros. Estos dos nombres son tan parecidos que pueden ser confundidos.\n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente los elementos y usa la solapa Propiedades para cambiar sus nombres.  Evita usar nombres que solo difieren en distinciones may\u00fasculas-min\u00fasculas, o en subrayados, o en un solo car\u00e1cter.

critics.CrMergeClasses-head = Considera combinar las clases
critics.CrMergeClasses-desc = La clase realzada, <ocl>self</ocl>, solo participa en una asociaci\u00f3n y esa asociaci\u00f3n es uno-a-uno con otra clase.  Puesto que las instancias de estas clases deben ser creadas y destruidas juntas, combinar estas clases puede simplificar el dise\u00f1o sin perdida de poder representativo.  Sin embargo, quiza la clase resultante sea demasiado grande y compleja, en cuyo caso ser\u00e1 mejor mantenerla separada.\n\nSiempre es importante organizar clases para administrar la complejidad del dise\u00f1o, especialmente cuando el dise\u00f1o ya es complejo de por s\u00ed. \n\nPara arreglar esto, pulsa en el bot\u00f3n \"Siguiente>\", o a\u00f1ade manualmente los atributos y operaciones de la clase realzada a la otra clase, luego quita la clase realzada del proyecto. 

critics.CrSubclassReference-head = Quita la referencia a la subclase especifica
critics.CrSubclassReference-desc = La clase <ocl>self</ocl> tiene una referencia a una de sus subclases. Normalmente todas las subclases deber\u00edan ser tratadas de modo similar por la superclase.  Esto permite a\u00f1adir nuevas subclases sin modificar la superclase. \n\nDefinir las asociaciones entre objetos es una parte importante del dise\u00f1o.  Algunos patrones de asociaciones son m\u00e1s f\u00e1ciles e mantener que otros, dependiendo de la naturaleza de los cambios futuros. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita manualmente la asociaci\u00f3n pulsando en ella en el diagrama y pulsando Delete. 

critics.CrComponentWithoutNode-head = Los componentes estan normalmente dentro de nodos
critics.CrComponentWithoutNode-desc = Hay nodos en el diagrama. Por tanto, tienes un diagrama de despliegue, y en los diagramas de despliegue los componentes residen normalmente en nodos.

critics.CrCompInstanceWithoutNode-head = ComponentInstances estan normalmente dentro de nodos
critics.CrCompInstanceWithoutNode-desc = Hay instancias de nodos en el diagrama. Por tanto, tienes un real diagrama de despliegue, y en los diagramas de despliegue las instancias de componentes residen normalmente en instancias de nodos.

critics.CrClassWithoutComponent-head = Las clases estan normalmente dentro de componentes
critics.CrClassWithoutComponent-desc =  En los diagramas de despliegue las clases estan normalmente dentro de componentes

critics.CrInterfaceWithoutComponent-head = Los interfaces estan normalmente dentro de componentes
critics.CrInterfaceWithoutComponent-desc =  En Deployment-diagrams los interfaces estan normalmente dentro de componentes

critics.CrObjectWithoutComponent-head = Los objetos estan normalmente dentro de componentes
critics.CrObjectWithoutComponent-desc = En los diagramas de despliegue los objetos estan normalmente dentro de componentes or component-instances

critics.CrNodeInsideElement-head = Los nodos normalmente no tienen contenedores
critics.CrNodeInsideElement-desc =  Los nodos normalmente no estan dentro de otros elementos. Los nodos representan objetos f\u00edsicos en tiempo de ejecuci\u00f3n con un recurso de procesamiento, generalmente tienen al menos memoria y capacidad de procesamiento.

critics.CrNodeInstanceInsideElement-head = Las NodeInstances normalmente no tienen contenedores
critics.CrNodeInstanceInsideElement-desc = Las NodeInstances normalmente no estan dentro de otros elementos. Las instancias de nodos representan objetos f\u00edsicos en tiempo de ejecuci\u00f3n con un recurso de procesamiento, generalmente tienen al menos memoria y capacidad de procesamiento.

critics.CrWrongLinkEnds-head = Los LinkEnds no tienen el mismo emplazamiento
critics.CrWrongLinkEnds-desc =  En los diagramas de despliegue los objetos pueden residir en componentes o en instancias de componentes. Por tanto, no es posible tener dos objetos conectados con un Link, estando un objeto en un componente y otro en una instancia de un componente.\n\n Para arreglar esto quita un objetos de los dos conectados de su emplazamiento a un elemento que tenga el mismo tipo que el emplazamiento del otro objeto

critics.CrInstanceWithoutClassifier-head = Establece un clasificador
critics.CrInstanceWithoutClassifier-desc = Las instancias tienen un clasificador

critics.CrCallWithoutReturn-head = Acci\u00f3n de retorno ausente
critics.CrCallWithoutReturn-desc = Toda se\u00f1al o evento de llamada requiere una acci\u00f3n de retorno, pero este enlace no tiene una acci\u00f3n de retorno.\n

critics.CrReturnWithoutCall-head = Ausencia de se\u00f1al o evento de llamada
critics.CrReturnWithoutCall-desc = Toda acci\u00f3n de retorno requiere una se\u00f1al o evento de llamada, pero este enlace no tiene su correspondiente se\u00f1al o evento de llamada.\n

critics.CrLinkWithoutStimulus-head = No hay est\u00edmulo en estos enlaces
critics.CrLinkWithoutStimulus-desc = En los diagramas de secuencia un objeto emisor env\u00eda un est\u00edmulo a un objeto que lo recibe a traves de un enlace. El enlace solo es la comunicaci\u00f3n-conexi\u00f3n, asi que se necesita un est\u00edmulo.

critics.CrSeqInstanceWithoutClassifier-head = Establece un clasificador
critics.CrSeqInstanceWithoutClassifier-desc =  Las instancias tienen un clasificador

critics.CrStimulusWithWrongPosition-head = Posici\u00f3n incorrecta de estos estimulos
critics.CrStimulusWithWrongPosition-desc = En los diagramas de secuencia la parte de env\u00edo de la comunicaci\u00f3n-conexi\u00f3n de estos est\u00edmulos es conectada al comienzo de una activaci\u00f3n. Para ser un emisor, un objeto ha de tener primero un foco-de-control.

critics.CrUnconventionalOperName-head = Escoge un nombre de MOperation m\u00e1s adecuado
critics.CrUnconventionalOperName-desc = Normalmente los nombres de operaci\u00f3n comienzan con una letra min\u00fascula. El nombre '<ocl>self</ocl>' no es convencional porque no comienza por min\u00fascula.\n\nSeguir buenas convenciones de nombres facilita el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente <ocl>self</ocl> y usa la solapa Propiedades para darle un nombre.

critics.CrUnconventionalAttrName-head = Escoge un nombre de MAttribute m\u00e1s adecuado
critics.CrUnconventionalAttrName-desc = Normalmente los nombres de atributos comienzan con una letra min\u00fascula. El nombre '<ocl>self</ocl>' es poco convencional porque no comienza por min\u00fascula.\n\nSeguir buenas convenciones de nombres facilita el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente <ocl>self</ocl> y usa la solapa Propiedades para give it a name.

critics.CrUnconventionalClassName-head = Capitaliza el nombre de clase <ocl>self</ocl>
critics.CrUnconventionalClassName-desc = Normalmente el nombre de las clases comienza con may\u00fascula. El nombre '<ocl>self</ocl>' es poco convencional porque no comienza con may\u00fascula.\n\nSeguir buenas convenciones de nombres facilita el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente <ocl>self</ocl> y usa la solapa Propiedades para asignarle un nombre diferente.

critics.CrUnconventionalPackName-head = Revisa el nombre del paquete <ocl>self</ocl>
critics.CrUnconventionalPackName-desc = Normalmente los nombres de paquetes estan escritos en min\u00fasculas con puntos para indicar paquetes \"anidados\".  El nombre '<ocl>self</ocl>' no es aconsejable porque no esta formado por min\u00fasculas y puntos.\n\nSeguir las convenciones para asignar nombres ayuda a entender y mantener el dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente <ocl>self</ocl> y usa la solapa Propiedades para asignarle un nombre diferente.

critics.CrClassMustBeAbstract-head = La clase debe ser abstracta
critics.CrClassMustBeAbstract-desc = Las clases que incluyen o heredan m\u00e9todos abstractos de sus clases base o interfaces deben ser Abstract.\n\nDecidir que clases son abstractas o concretas es una parte clave del dise\u00f1o de la jerarqu\u00eda de clases.\n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente la clase y usa la solapa Propiedades para a\u00f1adir la palabra clave abstract, o manualmente sobrepon cada operaci\u00f3n abstracta que es heredada de una clase base o interface.

critics.CrReservedName-head = Cambia <ocl>self</ocl> a una palabra no reservada
critics.CrReservedName-desc = \"<ocl>self</ocl>\" es una palabra reservada o muy parecida a una.  Los nombres de los elementos del modelo no deben estar en conflicto con palabras reservadas de lenguajes de programaci\u00f3n o del UML.\n\nEs necesario usar nombres legales para generar c\u00f3digo compilable.. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el elemento realzado y usa la solapa Propiedades para darle un nombre diferente.

critics.CrMultipleInheritance-head = Sustituye la herencia multiple por interfaces
critics.CrMultipleInheritance-desc = <ocl>self</ocl> tiene multiples clases base, pero Java no soporta herencia multiple.  Debes implementar interfaces en vez de usar multiples clases base. \n\nEste cambio se requiere antes de poder generar c\u00f3digo Java.\n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o manualmente (1) quita una de las clases base y luego (2) opcionalmente define un nuevo interfaz con las mismas declaraciones de m\u00e9todos y (3) a\u00f1adelo como un interface de <ocl>self</ocl>, y (4) mueve los cuerpos de los m\u00e9todos de la antigua clase base a <ocl>self</ocl>.

critics.CrIllegalName-head = Escoge un nombre legal
critics.CrIllegalName-desc = Los nombres de los elementos del modelo deben ser secuencias de letras, n\u00fameros, y subrayados.  No pueden contener puntuaci\u00f3n.\n\nLa generaci\u00f3n de c\u00f3digo requiere nombres legales para que el c\u00f3digo resultante compile correctamente. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el elemento destacado y usa la solapa Propiedades para darle un nombre diferente.

critics.CrConsiderSingleton-head = Considera el uso del patr\u00f3n Singelton 
critics.CrConsiderSingleton-desc = Esta clase no tiene atributos ni asociaciones que sean navegables fuera de la instancias de esta clase.  Esto significa que cada instancia de esta clase sera igual a cualquier otra debido a que no habr\u00e1 variables de instancia para diferenciarlas. Si esta no es tu intenci\u00f3n, deber\u00edas definir atributos o asociaciones que representen diferencias entre las instancias. Si no hay atributos o asociaciones para realizar esta diferenciaci\u00f3n, deber\u00edas considerar el uso de solo una instancia de esta clase, tal como se indica en el patr\u00f3n Singelton.\n\nDefinir la multiplicidad de instancias es necesario para completar la parte de representaci\u00f3n de informaci\u00f3n del dise\u00f1o. Usar el patr\u00f3n Singelton puede ahorrar tiempo y memoria.\n\nPara aplicar autom\u00e1ticamente el patr\u00f3n Singleton, pulsa el bot\u00f3n \"Siguiente>\"; o manualmente (1) marca la clase con el estereotipo Singlton, (2) a\u00f1ade una variable est\u00e1tica que contenga la instancia de esta clase, (3) y haz privados todos los constructores.\n\nPara saber m\u00e1s del patr\u00f3n Singleton, pulsa el icono MoreInfo.

critics.CrSingletonViolated-head = Infracci\u00f3n del Singleton Stereotype 
critics.CrSingletonViolated-desc = Esta clase esta marcada con el estereotipo Singelton, pero no satisface las restricciones correspondientes.  Una clase singleton puede tener como m\u00e1ximo una instancia.  Esto significa que la clase debe tener (1) una variable static haciendo referencia a la instancia, (2) solo constructores privados de modo que no puedan crearse m\u00e1s instancias desde otras clases, y (3) debe haber al menos un constructor que sobreponga el constructor por defecto.\n\nCuando marcas una clase con un estereotipo, la clase debe satisfacer todas las restricciones del estereotipo.  Esto contribuir\u00e1 a obtener un dise\u00f1o consistente y f\u00e1cil de entender. Usar el patr\u00f3n Singleton ahorrar\u00e1 tiempo y espacio.\n\nSi ya no quieres que esta clase sea un Singelton , quita el estereotipo Singleton haciendo click sobre la clase y borrando Singleton de la solapa de propiedades. \nPara aplicar autom\u00e1ticamente el patr\u00f3n Singleton, pulsa el bot\u00f3n \"Siguiente>\"; o manualmente (1) marca la clase con el estereotipo Singelton, (2) a\u00f1ade una variable est\u00e1tica que guarde la referencia a la instancia de esta clase, (3) y haz privados todos los constructores.\n\nPara aprender m\u00e1s del patr\u00f3n Singleton, pulsa el icono MoreInfo.

critics.CrNodesOverlap-head = Limpia el diagrama
critics.CrNodesOverlap-desc = Algunos objetos en este diagrama se solapan sobre otros. Esto puede ocultar informaci\u00f3n importante y hacer el dise\u00f1o m\u00e1s dif\u00edcil de entender. Una apariencia cuidada ayuda a otros dise\u00f1adores, implementadores, y analistas.\n\nConstruir un conjunto de diagramas de clases f\u00e1cil de entender es una parte importante del dise\u00f1o. \n\nPara arreglar esto, mueve los nodos destacados en el diagrama.

critics.CrZeroLengthEdge-head = Haz el borde m\u00e1s visible
critics.CrZeroLengthEdge-desc = Esta l\u00ednea es demasiado peque\u00f1a para ser vista con facilidad. Esto puede ocultar informaci\u00f3n importante y hacer el dise\u00f1o m\u00e1s dif\u00edcil de entender. Una apariencia cuidada ayuda a otros dise\u00f1adores, implementadores, y analistas.\n\nConstruir un conjunto de diagramas de clases f\u00e1cil de entender es una parte importante del dise\u00f1o. \n\nPara arreglar esto, mueve uno o m\u00e1s nodos de modo que las l\u00edneas realzadas sean m\u00e1s largas, o pulsa en el centro de la l\u00ednea y arrastra para hacer un nuevo vertice.

