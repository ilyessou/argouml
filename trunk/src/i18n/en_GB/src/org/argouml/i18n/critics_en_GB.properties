# $Id$
# Copyright (c) 2004 The Regents of the University of California. All
# Rights Reserved. Permission to use, copy, modify, and distribute this
# software and its documentation without fee, and without a written
# agreement is hereby granted, provided that the above copyright notice
# and this paragraph appear in all copies.  This software program and
# documentation are copyrighted by The Regents of the University of
# California. The software program and documentation are supplied "AS
# IS", without any accompanying services from The Regents. The Regents
# does not warrant that the operation of the program will be
# uninterrupted or error-free. The end-user understands that the program
# was developed for research purposes and is advised not to rely
# exclusively on the program for any reason.  IN NO EVENT SHALL THE
# UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
# SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
# UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
#
# Created from UMLCognitiveResourceBundle.java
#
# The keys are generated from the class names of the classes that use them.
#


critics.CrAssocNameConflict-head = Resolve Association Name Conflict
critics.CrAssocNameConflict-desc = Every element of a namespace must have a unique name. \n\nClear and unambiguous naming is key to code generation and the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select the elements and use the Properties tab to change their names.

critics.CrAttrNameConflict-head = Revise Attribute Names to Avoid Conflict
critics.CrAttrNameConflict-desc = Attributes must have distinct names.  This may be because of an inherited attribute. \n\nClear and unambiguous names are key to code generation and producing an understandable and maintainable design.\n\nTo fix this, use the \"Next>\" button, or manually select the one of the conflicting attributes of this class and change its name.

critics.CrOperNameConflict-head = Change Operation Names or Signatures in <ocl>self</ocl>
critics.CrOperNameConflict-desc = Two operations in <ocl>self</ocl> have the exact same signature.  Operations must have distinct signatures.  A signature is the combination of the operation's name, and parameter types (excluding return parameters).\n\nWhere there are conflicting signatures, correct code cannot be generated for mainstream OO languages. It also leads to very unclear semantics of the design.\n\nTo fix this, select the one of the conflicting operations of this class and change its name or parameters.

critics.CrCircularAssocClass-head = Circular Association
critics.CrCircularAssocClass-desc = AssociationClasses cannot include roles that refer directly back to the AssociationClass.

critics.CrCircularInheritance-head = Remove <ocl>self</ocl>'s Circular Inheritance
critics.CrCircularInheritance-desc = Inheritances relationships cannot have cycles. \n\nA legal class inheritance hierarchy is needed for code generation and the correctness of the design. \n\nTo fix this, use the \"Next>\" button, or manually select one of the  generalisation arrows in the cycle and remove it.

critics.CrCircularComposition-head = Remove Circular Composition
critics.CrCircularComposition-desc = Composition relationships (black diamonds) cannot have cycles. \n\nA legal aggregation hierarchy is needed for code generation and the correctness of the design. \n\nTo fix this, use the \"Next>\" button, or manually select one of the  associations in the cycle and remove it or change its aggregation to something other than composite.

critics.CrCrossNamespaceAssoc-head = Classifier not in Namespace of its Association
critics.CrCrossNamespaceAssoc-desc = Each Class, Interface or other Classifier involved in an Association should be in the Namespace of the Association.\n\nIf this is not the case, then there will be no way for the Classes, Interfaces or other Classifiers to name the reference to each other using the Association.\n\nNote that this critic currently does not interpret hierarchical namespaces. It will trigger if the final components of the namespaces are different, even if they share a common root, and this critic should be interpreted in the light of this.\n\nTo fix this, delete the association, and recreate it in a diagram, whose namespace includes the classes, interfaces and classifiers involved.

critics.CrDupParamName-head = Duplicate Parameter Name
critics.CrDupParamName-desc = Each parameter of an operation must have a unique name. \n\nClean and unambigous naming is needed for code generation and to achieve clear and maintainable designs.\n\nTo fix this, use the \"Next>\" button, or manually rename one of the parameters to this operation.

critics.CrDupRoleNames-head = Duplicate end (role) names for <ocl>self</ocl>
critics.CrDupRoleNames-desc = Association <ocl>self</ocl> has two (or more) roles with the same name.\n\nClear and unambiguous naming is key to code generation and the understandability and maintainability of the design.\n\nTo fix this manually select <ocl>self</ocl> and use the Properties tab to change one or more of the conflicting role names.

critics.CrFinalSubclassed-head = Remove final keyword or remove subclasses
critics.CrFinalSubclassed-desc = In Java, the keyword 'final' indicates that a class is not intended to have subclasses.  This class is marked final and has subclasses.\n\nA well thought-out class inheritance hierarchy that conveys and supports intended extensions is an important part of achieving an understandable and maintainable design.\n\nTo fix this, use the \"Next>\" button, or manually select the class and change its base class, or select the base class and use the properties tab to remove the 'final' keyword.

critics.CrIllegalGeneralization-head = Illegal Generalization 
critics.CrIllegalGeneralization-desc = Model elements can only be inherit from others of the same type. \n\nA legal inheritance hierarchy is needed for code generation and the correctness of the design. \n\nTo fix this, use the \"Next>\" button, or manually select the  generalisation arrow and remove it.

critics.CrAlreadyRealizes-head = Remove Unneeded Realises from <ocl>self</ocl>
critics.CrAlreadyRealizes-desc = The selected class already indirectly realises Interface {item.extra}.  There is no need to directly realise it again.\n\nSimplifying the design is always a good idea.  You might dismiss this \"to do\" item if you want to make it very explicit that the selected Class realises this Interface.\n\nTo fix this, select the Realisation (dashed line with white triangular arrowhead) and press the \"Delete\" key.

critics.CrInterfaceAllPublic-head = Operations in Interfaces must be public
critics.CrInterfaceAllPublic-desc = Interfaces are intended to specify the set of operations that other classes must implement.  They must be public. \n\nA well-designed set of interfaces is a good way to define the possible extensions of a class framework. \n\nTo fix this, use the \"Next>\" button, or manually select the operations of the interface and use the Properties tab to make them public.

critics.CrInterfaceOperOnly-head = Interfaces may only have operations
critics.CrInterfaceOperOnly-desc = Interfaces are intended to specify the set of operations that \nother classes must implement.  They do not implement these \noperations themselves, and cannot have attribues. \n\nA well-designed set of interfaces is a good way to define the \npossible extensions of a class framework. \n\nTo fix this, use the \"Next>\" button, or manually select the  \ninterface and use the Properties tab to remove all attributes.

critics.CrMultipleAgg-head = Two aggregate ends (roles) in binary Association
critics.CrMultipleAgg-desc = Only one end (role) of a binary Association can be aggregate or composite.\n\nAggregation and composition are used to indicate whole-part relationships and by defintion, the \"part\" end cannot be aggregate.\n\nTo fix this, select \"Next>\" to use the wizard, or manually select the Association and set some of its role aggregations to None.

critics.CrNWayAgg-head = Aggregate end (role) in 3-way (or more) Association
critics.CrNWayAgg-desc = Three-way (or more) Associations can not have aggregate ends (roles).\n\nAggregation and composition are used to indicated whole-part relationships, and by definition can only apply to binary associations between artifacts.\n\nTo fix this, manually select the Association and set the aggregation of each of its ends (roles) to None.

critics.CrNavFromInterface-head = Remove Navigation from Interface via Association <ocl>self</ocl>
critics.CrNavFromInterface-desc = Associations involving an interface can be not be navigable in the direction from the interface.  This is because interfaces contain only operation declarations and cannot hold pointers to other objects.\n\nThis part of the design should be changed before you can generate code from this design.  If you do generate code before fixing this problem, the code will not match the design.\n\nTo fix this, select the association and use the \"Properties\" tab to select in turn each association end that is NOT connected to the interface. Uncheck \"Navigable\" for each of these ends.\n\nThe association should then appear with a stick arrowhead pointed towards the interface\n\nNOTE. In an ideal world, ArgoUML would not permit associations to be created that were navigable from interfaces.\n\nWARNING. The current version of ArgoUML has a known defect where it creates an association between a class and interface that is either navigable in both directions, or navigable only from the interface to the class. The fix is to remove the navigation from the class end of the association and if necessary add navigation to the interface end (navigation refers to navigability TOWARDS the end) if this critic is triggered.

critics.CrUnnavigableAssoc-head = Make <ocl>self</ocl> Navigable
critics.CrUnnavigableAssoc-desc = The Association <ocl>self</ocl> is not navigable in any direction. All associations should be navigable at least one way.\n\nSetting the navigablility of associations allows your code to access data by following pointers. \n\nTo fix this, select association \"<ocl>self</ocl>\" in the diagram or navigator panel and click the properties tab.  Then use the checkboxes at the bottom of the properties panel to turn on navigablility.

critics.CrNameConflictAC-head = Role name conflicts with member
critics.CrNameConflictAC-desc = Association role names of an AssociationClass must not conflict \nwith the names of structural features (e.g., instance variables) \nof the class.

critics.CrMissingClassName-head = Choose a Name
critics.CrMissingClassName-desc = Every class and interface within a package must have a name. \n\nClear and unambiguous naming is key to code generation and the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select the class and use the Properties tab to give it a name.

critics.CrMissingAttrName-head = Choose a name
critics.CrMissingAttrName-desc = Every attribute must have a name. \n\nClear and unambiguous naming is key to code generation and \nthe understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select the \nattribute and use the Properties tab to give it a name.

critics.CrMissingOperName-head = Choose a name
critics.CrMissingOperName-desc = Every operation must have a name. \n\nClear and unambiguous naming is key to code generation and \nthe understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select the \noperation and use the Properties tab to give it a name.

critics.CrMissingStateName-head = Choose a Name
critics.CrMissingStateName-desc = Every state within a state machine should have a name. \n\nClear and unambiguous naming is key to code generation and the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select the state and use the Properties tab to give it a name, or select the state and type a name.

critics.CrNoInstanceVariables-head = Add Instance Variables to <ocl>self</ocl>
critics.CrNoInstanceVariables-desc = You have not yet specified instance variables for <ocl>self</ocl>. Normally classes have instance variables that store state information for each instance. Classes that provide only static attributes and methods should be stereotyped <<utility>>.\n\nDefining instance variables is needed to complete the information representation part of your design. \n\nTo fix this, press the \"Next>\" button, or add instance variables by double clicking on <ocl>self</ocl> in the navigator pane and using the Create menu to make a new attribute.

critics.CrNoAssociations-head = Add Associations to <ocl>self</ocl>
critics.CrNoAssociations-desc = You have not yet specified any Associations for <ocl>self</ocl>. Normally classes, actors and use cases are associated with others. \n\nDefining the associations between objects an important part of your design. \n\nTo fix this, press the \"Next>\" button, or add associations manually by clicking on the association tool in the tool bar and dragging from <ocl>self</ocl> to another node.

critics.CrNonAggDataType-head = Wrap DataType
critics.CrNonAggDataType-desc = DataTypes are not full classes and cannot be associated with classes, unless the DataType is part of a composite (black diamond) aggregation. \n\nGood OO design depends on careful choices about which entities to represent as full objects and which to represent as attributes of objects.\n\nTo fix this, use the \"Next>\" button, or manually replace the DataType with a full class or change the association aggregation to containment by a full class.

critics.CrOppEndConflict-head = Rename Association Roles
critics.CrOppEndConflict-desc = Two roles of <ocl>self</ocl> have the same name. Roles must have distinct names. \n\nClear and unambiguous names are key to code generation and producing an understandable and maintainable design.\n\nTo fix this, use the \"Next>\" button, or manually select the one of the conflicting roles at the far end of an association from this class and change its name.

critics.CrParamTypeNotImported-head = Import Parameter Type into Class
critics.CrParamTypeNotImported-desc = The type of each operation parameter must be visible and imported into the class that owns the operation.\n\nImporting classes is needed for code generation. Good modularisation of classes into packages is key to an understandable design.\n\nTo fix this, use the \"Next>\" button, or manually add an import to the class that owns this operation.

critics.CrUselessAbstract-head = Define Concrete (Sub)Class
critics.CrUselessAbstract-desc = <ocl>self</ocl> can never influence the running system because it can never have any instances, and none of its subclasses can have instances either. \n\nTo fix this problem: (1) define concrete subclasses that implement the interface of this class; or (2) make <ocl>self</ocl> or one of its existing subclasses concrete.

critics.CrUselessInterface-head = Define Class to Implement <ocl>self</ocl>
critics.CrUselessInterface-desc = <ocl>self</ocl> can never be used because no classes implement it.\n\nTo fix this problem, press the \"Next>\" button or manually use the toolbar \"Class\" button to define classes and the \"Realises\" button to make a relationship from the class to the highlighted interface.

critics.CrDisambigClassName-head = Choose a Unique Name for <ocl>self</ocl>
critics.CrDisambigClassName-desc = Every class and interface within a package must have a unique name. There are at least two elements in this package named \"<ocl>self</ocl>\".\n\nClear and unambiguous naming is key to code generation and the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select one of the conflicting classes and use the Properties tab to change their names.

critics.CrDisambigStateName-head = Choose a Unique Name for <ocl>self</ocl>
critics.CrDisambigStateName-desc = Every state within a state machine must have a unique name. There are at least two states in this machine named \"<ocl>self</ocl>\".\n\nClear and unambiguous naming is key to code generation and the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select one of the conflicting states and use the \"Properties\" tab to change their names.

critics.CrConflictingComposites-head = Remove Conflicting Composite Associations
critics.CrConflictingComposites-desc = A composite (black diamond) role of an association indicates that instances of that class contain instances of the associated classes. Since each instance can only be contained in one other object, each object can be the 'part' in at most one is-part-of relationship.\n\nGood OO design depends on building good is-part-of relationships.\n\nTo fix this, use the \"Next>\" button, or manually change one association to have multiplicity to 0..1 or 1..1, or another kind of aggregation (e.g., a white diamond is less strict), or remove one of the associations

critics.CrTooManyAssoc-head = Reduce Associations on <ocl>self</ocl>
critics.CrTooManyAssoc-desc = There are too many Associations on class <ocl>self</ocl>.  Whenever one class becomes too central to the design it may become a maintenance bottleneck that must be updated frequently. \n\nDefining the associations between objects is an important part of your design. \n\nTo fix this, press the \"Next>\" button, or remove associations manually by clicking on an association in the navigator pane or diagram and pressing the \"Del\" key.

critics.CrTooManyAttr-head = Reduce Attributes on <ocl>self</ocl>
critics.CrTooManyAttr-desc = There are too many Attributes on class <ocl>self</ocl>.  Whenever one class becomes too central to the design it may become a maintenance bottleneck that must be updated frequently. \n\nDefining the attributes of objects is an important part of your design. \n\nTo fix this, press the \"Next>\" button, or remove attributes manually by double-clicking on the attribute compartment of the  highlighted class in the diagram and removing the line of text for an attribute.

critics.CrTooManyOper-head = Reduce Operations on <ocl>self</ocl>
critics.CrTooManyOper-desc = There are too many Operations on class <ocl>self</ocl>.  Whenever one class becomes too central to the design it may become a maintenance bottleneck that must be updated frequently. \n\nDefining the operations of objects is an important part of your design. \n\nTo fix this, press the \"Next>\" button, or remove operations manually by double-clicking on the operation compartment of the  highlighted class in the diagram and removing the line of text for an operation.

critics.CrTooManyStates-head = Reduce States in machine <ocl>self</ocl>
critics.CrTooManyStates-desc = There are too many States in <ocl>self</ocl>.  If one state machine has too many states it may become very difficult for humans to understand. \n\nDefining an understandable set of states is an important part of your design. \n\nTo fix this, press the \"Next>\" button, or remove states manually by clicking on a states in the navigator pane or diagram and pressing the \"Del\" key.  Or you can nest states...

critics.CrTooManyTransitions-head = Reduce Transitions on <ocl>self</ocl>
critics.CrTooManyTransitions-desc = There are too many Transitions on state <ocl>self</ocl>.  Whenever one state becomes too central to the machine it may become a maintenance bottleneck that must be updated frequently. \n\nDefining the transitions between states is an important part of your design. \n\nTo fix this, press the \"Next>\" button, or remove transitions manually by clicking on a transition in the navigator pane or diagram and pressing the \"Del\" key.

critics.CrTooManyClasses-head = Reduce Classes in diagram <ocl>self</ocl>
critics.CrTooManyClasses-desc = There are too many classes in <ocl>self</ocl>.  If one class diagram has too many classes it may become very difficult for humans to understand. \n\nDefining an understandable set of class diagrams is an important part of your design. \n\nTo fix this, press the \"Next>\" button, or remove classes manually by clicking on a class in the navigator pane or diagram and pressing the \"Del\" key.  Or you can make a new diagram...

critics.CrNoTransitions-head = Add Transitions to <ocl>self</ocl>
critics.CrNoTransitions-desc = State <ocl>self</ocl> has no Incoming or Outgoing transitions. Normally states have both incoming and outgoing transitions. \n\nDefining complete state transitions is needed to complete the behavioral specification part of your design.  \n\nTo fix this, press the \"Next>\" button, or add transitions manually by clicking on transition tool in the tool bar and dragging from another state to <ocl>self</ocl> or from <ocl>self</ocl> to another state.

critics.CrNoIncomingTransitions-head = Add Incoming Transitions to <ocl>self</ocl>
critics.CrNoIncomingTransitions-desc = State <ocl>self</ocl> has no incoming transitions. Normally states have both incoming and outgoing transitions. \n\nDefining complete state transitions is needed to complete the behavioral specification part of your design. Without incoming transitions, this state can never be reached.\n\nTo fix this, press the \"Next>\" button, or add transitions manually by clicking on transition tool in the tool bar and dragging from another state to <ocl>self</ocl>.

critics.CrNoOutgoingTransitions-head = Add Outgoing Transitions from <ocl>self</ocl>
critics.CrNoOutgoingTransitions-desc = State <ocl>self</ocl> has no Outgoing transitions. Normally states have both incoming and outgoing transitions. \n\nDefining complete state transitions is needed to complete the behavioral specification part of your design.  Without outgoing transitions, this state is a \"dead\" state that can naver be exited.\n\nTo fix this, press the \"Next>\" button, or add transitions manually by clicking on transition tool in the tool bar and dragging from <ocl>self</ocl> to another state.

critics.CrMultipleInitialStates-head = Remove Extra Initial States
critics.CrMultipleInitialStates-desc = There are multiple, ambiguous initial states in this machine or composite state. Normally each state machine or composite state has one initial state. \n\nDefining unambiguous states is needed to complete the behavioral specification part of your design.\n\nTo fix this, press the \"Next>\" button, or manually select one of the extra initial states and remove it.

critics.CrNoInitialState-head = Place an Initial State
critics.CrNoInitialState-desc = There is no initial state in this machine or composite state. Normally each state machine or composite state has one initial state. \n\nDefining unambiguous states is needed to complete the behavioral specification part of your design.\n\nTo fix this, press the \"Next>\" button, or manually select initial state from the tool bar and place it in the diagram.

critics.CrNoTriggerOrGuard-head = Add Trigger or Guard to Transistion
critics.CrNoTriggerOrGuard-desc = The highlighted Transition is incomplete because it has no trigger or guard condition.  Triggers are events that cause a transition to be taken.  Guard conditions must be true for the transition to be taken.  If only a guard is used, the transition is taken when the condition becomes true.\n\nThis problem must be resolved to complete the state machine.\n\nTo fix this, select the Transition and use the \"Properties\" tab, or select the Transition and type some text of the form:\nTRIGGER [GUARD] / ACTION\nWhere TRIGGER is an event name, GUARD is a boolean expression, and ACTION is an action to be performed when the Transition is taken.  All three parts are optional.

critics.CrNoGuard-head = Add Guard to Transistion
critics.CrNoGuard-desc = The highlighted Transisition is incomplete because it has no guard condition.  Guard conditions must be true for the transition to be taken.  If only a guard is used, the transition is taken when the condition becomes true.\n\nThis problem must be resolved to complete the state machine.\n\nTo fix this, select the Transition and use the \"Properties\" tab, or select the Transition and type some text of the form:\n[GUARD]\nWhere GUARD is a boolean expression.

critics.CrInvalidFork-head = Change Fork Transitions
critics.CrInvalidFork-desc = This fork state has an invalid number of transitions. Normally fork states have one incoming and two or more outgoing transitions. \n\nDefining correct state transitions is needed to complete the  behavioral specification part of your design.  \n\nTo fix this, press the \"Next>\" button, or remove transitions  manually by clicking on transition in the diagram and pressing the Delete key.

critics.CrInvalidJoin-head = Change Join Transitions
critics.CrInvalidJoin-desc = This join state has an invalid number of transitions. Normally join states have two or more incoming and one outgoing transitions. \n\nDefining correct state transitions is needed to complete the  behavioral specification part of your design.  \n\nTo fix this, press the \"Next>\" button, or remove transitions  manually by clicking on transition in the diagram and pressing the Delete key.

critics.CrInvalidBranch-head = Change Branch Transitions
critics.CrInvalidBranch-desc = This branch state has an invalid number of transitions. Normally branch states have one incoming and two or more outgoing transitions. \n\nDefining correct state transitions is needed to complete the  behavioral specification part of your design.  \n\nTo fix this, press the \"Next>\" button, or remove transitions  manually by clicking on transition in the diagram and pressing the Delete key, or add transitions using the transition tool.

critics.CrEmptyPackage-head = Add Elements to Package <ocl>self</ocl>
critics.CrEmptyPackage-desc = You have not yet put anything in package <ocl>self</ocl>. Normally packages contain groups of related classes.\n\nDefining and using packages is key to making a maintainable design. \n\nTo fix this, select package <ocl>self</ocl> in the navigator panel and add  diagrams or model elements such as classes or use cases.

critics.CrNoOperations-head = Add Operations to <ocl>self</ocl>
critics.CrNoOperations-desc = You have not yet specified operations for <ocl>self</ocl>. Normally classes provide operations that define their behavior. \n\nDefining operations is needed to complete the behavioral specification part of your design. \n\nTo fix this, press the \"Next>\" button, or add operations manually by clicking on <ocl>self</ocl> in the navigator pane and using the Create menu to make a new operations.

critics.CrConstructorNeeded-head = Add Constructor to <ocl>self</ocl>
critics.CrConstructorNeeded-desc = You have not yet defined a constructor for class <ocl>self</ocl>. Constructors initialise new instances such that their attributes have valid values.  This class probably needs a constructor because not all of its attributes have initialvalues. \n\nDefining good constructors is key to establishing class invariants, and class invariants are a powerful aid in writing solid code. \n\nTo fix this, add a constructor manually by clicking on <ocl>self</ocl> in the navigator pane and adding an operation using the context sensitive pop-up menu in the property tab, orselect <ocl>self</ocl> where it appears on a class diagram and use the \"Add Operation\" tool.\n\nA constructor is an operation with the stereotype <<create>>.\n\nBy convention (Java, C++) a constructor has the same name as theclass, is not static, and returns no value (which means you mustremove the return parameter that ArgoUML adds by default).ArgoUML will accept any operation that follows these conventionsas a constructor even if it is not stereotyped <<create>>.

critics.CrNameConfusion-head = Revise Name to Avoid Confusion
critics.CrNameConfusion-desc = Names should be clearly distinct from each other. These two names are so close to each other that readers might be confused.\n\nClear and unambiguous naming is key to code generation and the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select the elements and use the Properties tab to change their names.  Avoid names that differ from other names only in capitalisation, or use of underscore characters, or by only one character.

critics.CrMergeClasses-head = Consider Combining Classes
critics.CrMergeClasses-desc = The highlighted class, <ocl>self</ocl>, only participates in one association and that association is one-to-one with another class.  Since instances of these two classes must always be created together and destroyed together, combining these classes might simplify your design without loss of any representation power.  However, you may find the combined class too large and complex, in which case separating them is usually better.\n\nOrganising classes to manage complexity of the design is always important, especially when the design is already complex. \n\nTo fix this, click on the \"Next>\" button, or manually add the attribues and operations of the highlighted class to the other class, then remove the highlighted class from the project.

critics.CrSubclassReference-head = Remove Reference to Specific Subclass
critics.CrSubclassReference-desc = Class <ocl>self</ocl> has a reference to one of it's subclasses. Normally all subclasses should be treated \"equally\" by the superclass.  This allows for addition of new subclasses without modification to the superclass. \n\nDefining the associations between objects is an important part of your design.  Some patterns of associations are easier to maintain than others, depending on the nature of future changes. \n\nTo fix this, press the \"Next>\" button, or remove the association  manually by clicking on it in the diagram and pressing Delete.

critics.CrComponentWithoutNode-head = Components normally are inside nodes
critics.CrComponentWithoutNode-desc = There are nodes in the diagram. So you have got a real\n deployment-diagram, and in deployment-diagrams components\n normally resides on nodes.

critics.CrCompInstanceWithoutNode-head = ComponentInstances normally are inside nodes
critics.CrCompInstanceWithoutNode-desc = There are node-instances in the Diagram. So you have got a real\n deployment-diagram, and in deployment-diagrams Component-instances\n normally resides on node-instances.

critics.CrClassWithoutComponent-head = Classes normally are inside components
critics.CrClassWithoutComponent-desc = In Deployment-diagrams classes are normally inside components

critics.CrInterfaceWithoutComponent-head = Interfaces normally are inside components
critics.CrInterfaceWithoutComponent-desc = In Deployment-diagrams interfaces are normally inside components

critics.CrObjectWithoutComponent-head = Objects normally are inside components
critics.CrObjectWithoutComponent-desc = In Deployment-diagrams objects are normally inside components or component-instances

critics.CrNodeInsideElement-head = Nodes normally have no enclosers
critics.CrNodeInsideElement-desc = Nodes normally are not inside other Elements. They represent\n run-time physical objects with a processing resource, generally having\n at least a memory and often processing capability as well.

critics.CrNodeInstanceInsideElement-head = NodeInstances normally have no enclosers
critics.CrNodeInstanceInsideElement-desc = NodeInstances normally are not inside other Elements. They represent\n run-time physical objects with a processing resource, generally having\n at least a memory and often processing capability as well.

critics.CrWrongLinkEnds-head = LinkEnds have not the same locations
critics.CrWrongLinkEnds-desc = In deployment-diagrams objects can reside either on components\n or on component-instances. So it is not possible to have two objects\n connected with a Link, while one object resides on an component and\n an the other object on a component-instance.\n\n\n To fix this remove one object of the two connected objects from its location to an element that has the\n same type as the location of the other object

critics.CrInstanceWithoutClassifier-head = Set classifier
critics.CrInstanceWithoutClassifier-desc =  Instances have a classifier

critics.CrCallWithoutReturn-head = Missing return-actions
critics.CrCallWithoutReturn-desc = Every call- or send-action requires a return-action,\n but this Link has no return-action.

critics.CrReturnWithoutCall-head = Missing call(send)-action
critics.CrReturnWithoutCall-desc = Every return-action requires a call- or send-action,\n but this Link has no corresponding call- or send-action.

critics.CrLinkWithoutStimulus-head = No Stimuli on these links
critics.CrLinkWithoutStimulus-desc = In sequence-diagrams a sender-object sends stimuli\nto a receiving object over a link. The link is only the communication-\nconnection, so a stimulus is needed.

critics.CrSeqInstanceWithoutClassifier-head = Set classifier
critics.CrSeqInstanceWithoutClassifier-desc =  Instances have a classifier

critics.CrStimulusWithWrongPosition-head = Wrong position of these stimuli
critics.CrStimulusWithWrongPosition-desc = In sequence-diagrams the sender-side of the communication-connections of these\nstimuli are connected at the beginning of an activation. To be a sender an object must\nhave a focus-of-control first.

critics.CrUnconventionalOperName-head = Choose a Better Operation Name
critics.CrUnconventionalOperName-desc = Normally operation names begin with a lowercase letter. The name '<ocl>self</ocl>' is unconventional because it does not.\n\nFollowing good naming conventions help to improve the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select <ocl>self</ocl> and use the Properties tab to give it a new name.

critics.CrUnconventionalAttrName-head = Choose a Better Attribute Name
critics.CrUnconventionalAttrName-desc = Normally attributes begin with a lowercase letter. The name '<ocl>self</ocl>' is unconventional because it does not.\n\nFollowing good naming conventions help to improve the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select <ocl>self</ocl> and use the Properties tab to give it a different name.

critics.CrUnconventionalClassName-head = Capitalise Class Name <ocl>self</ocl>
critics.CrUnconventionalClassName-desc = Normally classes begin with a capital letter. The name '<ocl>self</ocl>' is unconventional because it does not begin with a capital.\n\nFollowing good naming conventions help to improve the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select <ocl>self</ocl> and use the Properties tab to give it a different name.

critics.CrUnconventionalPackName-head = Revise Package Name <ocl>self</ocl>
critics.CrUnconventionalPackName-desc = Normally package names are written in all lower case with periods used to indicate \"nested\" packages.  The name '<ocl>self</ocl>' is unconventional because it is not all lower case with periods.\n\nFollowing good naming conventions help to improve the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select <ocl>self</ocl> and use the Properties tab to give it a different name.

critics.CrClassMustBeAbstract-head = Class Must be Abstract
critics.CrClassMustBeAbstract-desc = Classes that include or inherit abstract methods from base classes or interfaces must be marked Abstract.\n\nDeciding which classes are abstract or concrete is a key part of class hierarchy design.\n\nTo fix this, use the \"Next>\" button, or manually select the class and use the properties tab to add the Abstract keyword, or manually implement each abstract operation that is inherited from a base class or interface.

critics.CrReservedName-head = Change <ocl>self</ocl> to a Non-Reserved Word
critics.CrReservedName-desc = \"<ocl>self</ocl>\" is a reserved word or very close to one.  The names of model elements must not conflict with reserved words of programming languages or UML.\n\nUsing legal names is needed to generate compilable code. \n\nTo fix this, use the \"Next>\" button, or manually select the highlighted element and use the Properties tab to give it a different name.

critics.CrMultipleInheritance-head = Change Multiple Inheritance to Interfaces
critics.CrMultipleInheritance-desc = <ocl>self</ocl> has multiple base classes, but Java does not support multiple inheritance.  You must use interfaces instead. \n\nThis change is required before you can generate Java code.\n\nTo fix this, use the \"Next>\" button, or manually (1) remove one of the base classes and then (2) optionally define a new interface with the same method declarations and (3) add it as an interface of <ocl>self</ocl>, and (4) move the method bodies from the old base class down into <ocl>self</ocl>.

critics.CrIllegalName-head = Choose a Legal Name for <ocl>self</ocl>
critics.CrIllegalName-desc = The names of model elements must be sequences of letters, numbers, and underscores.  They cannot contain punctuation.\n\nCode generation requires legal names for the resulting code to compile correctly. \n\nTo fix this, use the \"Next>\" button, or manually select the highlighted element and use the Properties tab to give it a different name.

critics.CrConsiderSingleton-head = Consider using Singleton Pattern for <ocl>self</ocl>
critics.CrConsiderSingleton-desc = <ocl>self</ocl> has no non-static attributes nor any associations that are navigable away from instances of this class.  This means that every instance of this class will be identical to every other instance, since there will be nothing about the instances that can differentiate them.\n\nUnder these circumstances you should consider making explicit that you have exactly one instance of this class, by using the Singleton Pattern. Using the Singleton Pattern can save time and memory space. Within ArgoUML; this can be done by using the <<singleton>> stereotype on this class.\n\nIf it is not your intent to have a single instance, you should define instance variables (i.e. non-static attributes) and/or outgoing associations that will represent differences between instances.\n\nHaving specified <ocl>self</ocl> as a Singleton, you need to define the class so there can only be a single instance. This will complete the information representation part of your design. To achieve this you need to do the following.\n\n1. Define a static attribute (a class variable) holding the instance. This must therefore have <ocl>self</ocl> as its type.\n\n2. Provide only private constructors for <ocl>self</ocl> so that new instances cannot be made by other code. The creation of the single instance could be through a suitable helper operation, which invokes this private constructor just once.\n\n3. Provide at least one constructor to override the default constructor, so that the default constructor is not used to create multiple instances.\n\nIn the UML 1.3 standard, a constructor is an operation with the stereotype <<create>>. Although not strictly standard, ArgoUML will also accept <<Create>> as a stereotype for constructors.\n\nBy convention in Java and C++ a constructor has the same name as the class, is not static, and returns no value. Note that in ArgoUML this means you must remove the return value created by default for an operation. ArgoUML; will also accept any operation that follows these conventions as a constructor even ifit is not stereotyped <<create>> or <<Create>>.

critics.CrSingletonViolated-head = Singleton Stereotype Violated in <ocl>self</ocl>
critics.CrSingletonViolated-desc = <ocl>self</ocl> is marked with the <<singleton>>; stereotype, but it does not satisfy the constraints imposed on Singletons (ArgoUML will also accept <<Singleton>> stereotype as defining a Singleton).\n\nA Singleton class can have at most one instance.  This means that the class must meet the design criteria for a singleton.\n\n1. It should have a static attribute (a class variable) to hold the instance.\n\n2. It must have only private constructors so that new instances cannot be made by other code.\n\n3.  It must have at least one constructor to override the default constructor, so that the default constructor is not used to create multiple instances.\n\nWhenever you mark a class with a stereotype, the class should satisfy all constraints of the stereotype.  This is an important part of making a self-consistent and understandable design. Using the Singleton Pattern can save time and memory space.\n\nIf you no longer want this class to be a Singleton, remove the <<singleton>> or <<Singleton>> stereotype by clicking on the class and selecting the blank selection on the stereotype drop-down within the properties tab.\n\nTo apply the Singleton Pattern you should do the following.\n\n1. Define a static attribute (a class variable) holding the instance. This must therefore have <ocl>self</ocl> as its type.\n\n2. Provide only private constructors for <ocl>self</ocl> so that new instances cannot be made by other code. The creation of the single instance could be through a suitable helper operation, which invokes this private constructor just once.\n\n3. Provide at least one constructor to override the default constructor, so that the default constructor is not used to create multiple instances.\n\nIn the UML 1.3 standard, a constructor is an operation with the stereotype <<create>>. Although not strictly standard, ArgoUML will also accept <<Create>> as a stereotype for constructors.\n\nBy convention in Java and C++ a constructor has the same name as the class, is not static, and returns no value. Note that in ArgoUML this means you must remove the return value created by default for an operation. ArgoUML; will also accept any operation that follows these conventions as a constructor even if it is not stereotyped <<create>> or <<Create>>.

critics.CrNodesOverlap-head = Clean Up Diagram
critics.CrNodesOverlap-desc = Some of the objects in this diagram overlap and obscure each other. This may hide important information and make it difficult for humans to understand. A neat appearance may also make your diagrams more influencial on other designers, implementors, and decision makers.\n\nConstructing an understandable set of class diagrams is an important part of your design. \n\nTo fix this, move the highlighted nodes in the diagram.

critics.CrZeroLengthEdge-head = Make Edge More Visible
critics.CrZeroLengthEdge-desc = This edge is too small to see easily. This may hide important information and make it difficult for humans to understand. A neat appearance may also make your diagrams more influencial on other designers, implementors, and decision makers.\n\nConstructing an understandable set of diagrams is an important part of your design. \n\nTo fix this, move one or more nodes so that the highlighted edges will be longer, or click in the center of the edge and drag to make a new vertex.
