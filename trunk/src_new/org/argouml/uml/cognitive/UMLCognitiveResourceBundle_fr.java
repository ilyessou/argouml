// Copyright (c) 1996-2001 The Regents of the University of California. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies.  This software program and
// documentation are copyrighted by The Regents of the University of
// California. The software program and documentation are supplied "AS
// IS", without any accompanying services from The Regents. The Regents
// does not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason.  IN NO EVENT SHALL THE
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.


package org.argouml.uml.cognitive;
import java.util.*;
import org.argouml.util.*;

/**
 *   This class is the default member of a resource bundle that
 *   provides strings for UML related critiques and check lists
 *
 *   @author Curt Arnold
 *   @since 0.9
 *   @see java.util.ResourceBundle
 *   @see UMLCognitiveResourceBundle_de
 *   @see org.argouml.util.CheckResourceBundle
 *   @see org.argouml.uml.cognitive.critics.CrUML
 */
public class UMLCognitiveResourceBundle_fr extends ListResourceBundle {

    private static final Object[][] _contents = {
        { "CrAssocNameConflict_head" ,
                "Supprimez les conflits de noms d'associations" },
        { "CrAssocNameConflict_desc" ,
                "Chacun des \u00e9l\u00e9ments d'un espace de nommage doit avoir un nom unique.\n\nUne d\u00e9nomination claire et sans ambigu\u00eft\u00e9 est indispensable \u00e0 la g\u00e9n\u00e9ration de code et \u00e0 la maintenabilit\u00e9 de la conception et facilite sa compr\u00e9hension.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou s\u00e9lectionnez manuellement les \u00e9l\u00e9ments et changez leurs noms \u00e0 l'aide de l'onglet des propri\u00e9t\u00e9s." },
        { "CrAttrNameConflict_head" ,
                "Supprimez les conflits de noms d'attributs" },
        { "CrAttrNameConflict_desc" ,
                "Les attributs doivent avoir des noms distincts les uns des autres. Le probl\u00e8me peut provenir d'un attribut h\u00e9rit\u00e9.\n\nUne d\u00e9nomination claire et sans ambigu\u00eft\u00e9 est indispensable \u00e0 la g\u00e9n\u00e9ration de code et \u00e0 la maintenabilit\u00e9 de la conception et facilite sa compr\u00e9hension.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou s\u00e9lectionnez manuellement l'un des attributs en conflit de la classe et changez son nom" },
        { "CrOperNameConflict_head" ,
                "Changez les noms ou les signatures dans <ocl>self</ocl>" },
        { "CrOperNameConflict_desc" ,
                "Deux op\u00e9rations ont exactement la m\u00eame signature. Les op\u00e9rations doivent avoir des signatures distinctes les unes des autres. Une signature est la combinaison du nom de l'op\u00e9ration et des types de ses param\u00e8tres.\n\n\u00c9viter les conflits de signatures est indispensable \u00e0 la g\u00e9n\u00e9ration de code et \u00e0 la maintenabilit\u00e9 de la conception et facilite sa compr\u00e9hension.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou s\u00e9lectionnez manuellement l'une des op\u00e9rations en conflit et changez son nom ou ses param\u00e8tres." },
        { "CrCircularAssocClass_head" ,
                "Supprimez l'association circulaire" },
        { "CrCircularAssocClass_desc" ,
                "Les classes-associations ne peuvent comporter des r\u00f4les qui les r\u00e9f\u00e9rencent directement." },
        { "CrCircularInheritance_head" ,
                "Supprimez le cycle d'h\u00e9ritage de <ocl>self</ocl>" },
        { "CrCircularInheritance_desc" ,
                "Les relations d'h\u00e9ritage ne peuvent pas comporter de cycle.\n\nUne hi\u00e9rarchie d'h\u00e9ritage correcte est n\u00e9cessaire \u00e0 la g\u00e9n\u00e9ration de code et pour la justesse de la conception.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb o\u00f9 s\u00e9lectionnez manuellement l'un des liens de g\u00e9n\u00e9ralisation et supprimez-le." },
        { "CrCircularComposition_head" ,
                "Supprimez le cycle de composition" },
        { "CrCircularComposition_desc" ,
                "Les relations de composition (losanges noirs) ne peuvent pas comporter de cycle.\n\nUne hi\u00e9rarchie d'agr\u00e9gation correcte est n\u00e9cessaire \u00e0 la g\u00e9n\u00e9ration de code et pour la justesse de la conception.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb o\u00f9 s\u00e9lectionnez manuellement l'une des associations et supprimez-la ou changez sa cat\u00e9gorie en autre chose que composite" },
        { "CrCrossNamespaceAssoc_head" ,
                "Agr\u00e9gation de r\u00f4les dans une association n-aire" },
        { "CrCrossNamespaceAssoc_desc" ,
                "Toutes les classes et interfaces impliqu\u00e9es dans une association doivent appartenir au m\u00eame espace de nommage que l'association.\n" },
        { "CrDupParamName_head" ,
                "Supprimez les conflits de noms de param\u00e8tres" },
        { "CrDupParamName_desc" ,
                "Les param\u00e8tres d'une op\u00e9ration doivent avoir des noms distincts les uns des autres.\n\nUne d\u00e9nomination claire et sans ambigu\u00eft\u00e9 est indispensable \u00e0 la g\u00e9n\u00e9ration de code et \u00e0 la maintenabilit\u00e9 de la conception et facilite sa compr\u00e9hension.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou s\u00e9lectionnez manuellement l'un des param\u00e8tres en conflit de la l'op\u00e9ration et changez son nom" },
        { "CrDupRoleNames_head" ,
                "Changez les noms de r\u00f4les de <ocl>self</ocl>" },
        { "CrDupRoleNames_desc" ,
                "L'association <ocl>self</ocl> a deux r\u00f4les aux noms conflictuels.\n\nUne d\u00e9nomination claire et sans ambigu\u00eft\u00e9 est indispensable \u00e0 la g\u00e9n\u00e9ration de code et \u00e0 la maintenabilit\u00e9 de la conception et facilite sa compr\u00e9hension.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou s\u00e9lectionnez manuellement <ocl>self</ocl> et changez le nom de l'un des r\u00f4les." },
        { "CrFinalSubclassed_head" ,
                "Supprimez le mot-clef \u00ab final \u00bb ou supprimez les sous-classes" },
        { "CrFinalSubclassed_desc" ,
                "Dans le langage Java, le mot-clef \u00ab final \u00bb sp\u00e9cifie que la classe ne doit pas avoir de sous-classe. Cette classe est \u00e9tiquet\u00e9e avec ce mot-clef et elle a des sous-classes.\n\nUne hi\u00e9rarchie d'h\u00e9ritage bien pens\u00e9e qui supporte et indique clairement des extensions pr\u00e9visibles est une \u00e9tape importante vers une conception maintenable et compr\u00e9hensible.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou s\u00e9lectionnez manuellement la classe et changez sa classe de base ou s\u00e9lectionnez la classe de base et supprimez le mot-clef \u00ab final \u00bb \u00e0 l'aide de l'onglet des propri\u00e9t\u00e9s." },
        { "CrIllegalGeneralization_head" ,
                "Supprimez la g\u00e9n\u00e9ralisation non valide" },
        { "CrIllegalGeneralization_desc" ,
                "L'h\u00e9ritage n'est possible qu'entre \u00e9l\u00e9ments de mod\u00e8le de m\u00eame type.\n\nMModel elements can only be inherit from others of the same type.\n\nUne hi\u00e9rarchie d'h\u00e9ritage correcte est n\u00e9cessaire \u00e0 la g\u00e9n\u00e9ration de code et pour la justesse de la conception.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb o\u00f9 s\u00e9lectionnez manuellement le lien de g\u00e9n\u00e9ralisation et supprimez-le." },
        { "CrAlreadyRealizes_head" ,
                "Supprimez les r\u00e9alisations inutiles de <ocl>self</ocl>" },
        { "CrAlreadyRealizes_desc" ,
                "La classe s\u00e9lectionn\u00e9e r\u00e9alise d\u00e9j\u00e0 la sp\u00e9cification {item.extra}. Il est inutile de la r\u00e9aliser directement en plus.\n\nIl est toujours bon de simplifier la conception. Vous pouvez ignorer cette entr\u00e9e \u00ab \u00c0 Faire \u00bb si vous pr\u00e9f\u00e9rez faire appara\u00eetre explicitement que la classe s\u00e9lectionn\u00e9e r\u00e9alise la sp\u00e9cification.\n\nPour corriger, s\u00e9lectionnez le lien de r\u00e9alisation (ligne pointill\u00e9e termin\u00e9e par un triangle blanc) et supprimez-le avec la touche \u00ab Suppr \u00bb." },
        { "CrInterfaceAllPublic_head" ,
                "Rendez publiques les op\u00e9rations des interfaces" },
        { "CrInterfaceAllPublic_desc" ,
                "Les interfaces ont pour objectif de sp\u00e9cifier des ensembles d'op\u00e9rations que d'autres classes impl\u00e9mentent. Ces op\u00e9rations doivent \u00eatre publiques.\n\nUn ensemble d'interfaces bien con\u00e7u constitue un bon moyen de d\u00e9finir les extensions possible d'une architecture.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou s\u00e9lectionnez manuellement les op\u00e9rations de l'interface et rendez-les publiques \u00e0 l'aide de l'onglet des propri\u00e9t\u00e9s." },
        { "CrInterfaceOperOnly_head" ,
                "Supprimez les attributs de l'interface" },
        { "CrInterfaceOperOnly_desc" ,
                "Les interfaces ont pour objectif de sp\u00e9cifier des ensembles d'op\u00e9rations que d'autres classes impl\u00e9mentent. Elles n'impl\u00e9mentent pas ces op\u00e9rations par elles-m\u00eames et ne peuvent pas avoir d'attributs.\n\nUn ensemble d'interfaces bien con\u00e7u constitue un bon moyen de d\u00e9finir les extensions possible d'une architecture.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou s\u00e9lectionnez manuellement l'interface et supprimez tous ses attributs \u00e0 l'aide de l'onglet des propri\u00e9t\u00e9s." },
        { "CrMultipleAgg_head" ,
                "Supprimez l'agr\u00e9gation surnum\u00e9raire de l'un des r\u00f4les" },
        { "CrMultipleAgg_desc" ,
                "Seul l'un des r\u00f4les d'une association peut \u00eatre une agr\u00e9gation ou une composition.\n\nUne hi\u00e9rarchie d'appartenance claire et coh\u00e9rente est n\u00e9cessaire \u00e0 la clart\u00e9 de la conception, \u00e0 la facilit\u00e9 de gestion du stockage des objets et \u00e0 l'impl\u00e9mentation des m\u00e9thodes r\u00e9cursives.\nPour corriger, s\u00e9lectionnez l'association et changez l'agr\u00e9gation d'un de ses r\u00f4les en \u00ab Aucun \u00bb" },
        { "CrNWayAgg_head" ,
                "Supprimez l'agr\u00e9gation des r\u00f4les d'une association n-aire" },
        { "CrNWayAgg_desc" ,
                "Les association ternaires (ou plus) ne peuvent pas \u00eatre des agr\u00e9gations.\n\nUne hi\u00e9rarchie d'appartenance claire et coh\u00e9rente est n\u00e9cessaire \u00e0 la clart\u00e9 de la conception, \u00e0 la facilit\u00e9 de gestion du stockage des objets et \u00e0 l'impl\u00e9mentation des m\u00e9thodes r\u00e9cursives.\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou s\u00e9lectionnez l'association manuellement et changez toutes les agr\u00e9gations de ses r\u00f4les en \u00ab Aucun \u00bb." },
        { "CrNavFromInterface_head" ,
                "Supprimez la navigation en provenance de l'interface <ocl>self</ocl>" },
        { "CrNavFromInterface_desc" ,
                "Les associations impliquant une interface ne peuvent pas \u00eatre navigables depuis l'interface. Ceci est d\u00fb au fait que les interfaces ne contiennent que des d\u00e9clarations d'op\u00e9rations et ne peuvent pas contenir de pointeurs vers d'autres objets.\n\nCette partie de la conception doit \u00eatre chang\u00e9e avant de pouvoir \u00eatre utilis\u00e9e pour g\u00e9n\u00e9rer du code. Si vous tentez de g\u00e9n\u00e9rer du code avant de r\u00e9soudre ce probl\u00e8me, le code ne sera pas coh\u00e9rent avec la conception.\n\nPour corriger, s\u00e9lectionnez l'association et d\u00e9cochez la case de navigabilit\u00e9 du c\u00f4t\u00e9 de l'interface dans l'onglet des propri\u00e9t\u00e9s. Une fl\u00e8che doit alors appara\u00eetre sur l'extr\u00e9mit\u00e9 de l'association vers l'interface." },
        { "CrUnnavigableAssoc_head" ,
                "Rendez l'association <ocl>self</ocl> navigable" },
        { "CrUnnavigableAssoc_desc" ,
          "L'association <ocl>self</ocl> n'est navigable dans aucune direction. Toutes les associations doivent \u00eatre navigables au moins dans un sens.\n\nParam\u00e9trer la navigabilit\u00e9 des associations permet \u00e0 votre code d'acc\u00e9der aux donn\u00e9es en suivant des pointeurs.\n\nPour corriger, s\u00e9lectionnez l'association \u00ab <ocl>self</ocl> \u00bb et changez la navigabilit\u00e9 \u00e0 l'aide des cases \u00e0 cocher de l'onglet des propri\u00e9t\u00e9s." },
        { "CrNameConflictAC_head" ,
                "Supprimez le conflit de nom entre un r\u00f4le et un membre" },
        { "CrNameConflictAC_desc" ,
                "Les noms de r\u00f4le des associations d'une classe-association ne doivent pas entrer en conflit avec les \u00e9l\u00e9ments structuraux (par exemple les variables d'instance) de la classe." },
        { "CrMissingClassName_head" ,
                "Choisissez un nom" },
        { "CrMissingClassName_desc" ,
                "Toutes les classes et toutes les interfaces d'un paquetage doivent avoir un nom.\n\nUne d\u00e9nomination claire et sans ambigu\u00eft\u00e9 est indispensable \u00e0 la g\u00e9n\u00e9ration de code et \u00e0 la maintenabilit\u00e9 de la conception et facilite sa compr\u00e9hension.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou s\u00e9lectionnez manuellement la classe et donnez-lui un nom \u00e0 l'aide de l'onglet des propri\u00e9t\u00e9s." },
        { "CrMissingAttrName_head" ,
                "Choisissez un nom" },
        { "CrMissingAttrName_desc" ,
                "Tous les attributs doivent avoir un nom.\n\nUne d\u00e9nomination claire et sans ambigu\u00eft\u00e9 est indispensable \u00e0 la g\u00e9n\u00e9ration de code et \u00e0 la maintenabilit\u00e9 de la conception et facilite sa compr\u00e9hension.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou s\u00e9lectionnez manuellement l'attribut et donnez-lui un nom \u00e0 l'aide de l'onglet des propri\u00e9t\u00e9s." },
        { "CrMissingOperName_head" ,
                "Choisissez un nom" },
        { "CrMissingOperName_desc" ,
                "Toutes les op\u00e9rations doivent avoir un nom.\n\nUne d\u00e9nomination claire et sans ambigu\u00eft\u00e9 est indispensable \u00e0 la g\u00e9n\u00e9ration de code et \u00e0 la maintenabilit\u00e9 de la conception et facilite sa compr\u00e9hension.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou s\u00e9lectionnez manuellement l'op\u00e9ration et donnez-lui un nom \u00e0 l'aide de l'onglet des propri\u00e9t\u00e9s." },
        { "CrMissingStateName_head" ,
                "Choisissez un nom" },
        { "CrMissingStateName_desc" ,
                "Tous les \u00e9tats d'un automate \u00e0 \u00e9tats doivent avoir un nom.\n\nUne d\u00e9nomination claire et sans ambigu\u00eft\u00e9 est indispensable \u00e0 la g\u00e9n\u00e9ration de code et \u00e0 la maintenabilit\u00e9 de la conception et facilite sa compr\u00e9hension.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou s\u00e9lectionnez manuellement l'\u00e9tat et donnez-lui un nom \u00e0 l'aide de l'onglet des propri\u00e9t\u00e9s." },
        { "CrNoInstanceVariables_head" ,
                "Ajoutez des variables d'instance \u00e0 <ocl>self</ocl>" },
        { "CrNoInstanceVariables_desc" ,
                "Vous n'avez pas encore sp\u00e9cifi\u00e9 de variable d'instance pour <ocl>self</ocl>. Normalement, les classes ont des variables d'instance qui stockent les informations d'\u00e9tat des instances. Les classes qui n'ont que des attributs et des m\u00e9thodes sttiques doivent \u00eatre qualifi\u00e9es avec le st\u00e9r\u00e9otype <<utility>>.\n\nVous devez d\u00e9finir des variables d'instance pour compl\u00e9ter la partie \u00ab repr\u00e9sentation de l'information \u00bb de votre conception.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou ajoutez des variables d'instance en double-cliquant sur <ocl>self</ocl> dans l'explorateur et en utilisant le menu \u00ab Cr\u00e9er \u00bb pour construire un nouvel attribut." },
        { "CrNoAssociations_head" ,
                "Ajoutez des associations \u00e0 <ocl>self</ocl>" },
        { "CrNoAssociations_desc" ,
                "Vous n'avez pas encore sp\u00e9cifi\u00e9 d'association pour <ocl>self</ocl>. Normalement, les classes, les acteurs et les cas d'utilisation sont reli\u00e9s par des associations.\n\nLa d\u00e9finition d'associations entre objets est une partie importante de votre conception\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou ajoutez des associations manuellement en cliquant sur l'outil d'association dans la barre d'outils puis en faisant un glisser-d\u00e9poser entre <ocl>self</ocl> et un autre n\u0153ud." },
        { "CrNonAggDataType_head" ,
                "Encapsulez le type de donn\u00e9e" },
        { "CrNonAggDataType_desc" ,
                "Les types de donn\u00e9e (DataTypes) ne sont pas des classes compl\u00e8tes et ne peuvent pas \u00eatre associ\u00e9s avec des classes, sauf par des agr\u00e9gations de type composition (losanges noirs).\n\nUne bonne conception orient\u00e9e objet d\u00e9pend du soin apport\u00e9 au choix des entit\u00e9s qui doivent \u00eatre des objets complets et des entit\u00e9s qui doivent \u00eatre des attributs d'objets.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb, remplacez manuellement le type de donn\u00e9e par une classe compl\u00e8te, ou changez l'association en appartenance \u00e0 une classe compl\u00e8te." },
        { "CrOppEndConflict_head" ,
                "Renommez les noms de r\u00f4les de l'association" },
        { "CrOppEndConflict_desc" ,
                "Deux r\u00f4les de <ocl>self</ocl> ont le m\u00eame nom. Les r\u00f4les doivent avoir des noms distincts.\n\nUne d\u00e9nomination claire et sans ambigu\u00eft\u00e9 est indispensable \u00e0 la g\u00e9n\u00e9ration de code et \u00e0 la maintenabilit\u00e9 de la conception et facilite sa compr\u00e9hension.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb ou s\u00e9lectionnez manuellement l'un des r\u00f4les et changez son nom \u00e0 l'aide de l'onglet des propri\u00e9t\u00e9s." },
        { "CrParamTypeNotImported_head" ,
                "Importez le type de param\u00e8tre dans la classe" },
        { "CrParamTypeNotImported_desc" ,
          "Le type de chacun des param\u00e8tres d'une op\u00e9ration doit \u00eatre visible et import\u00e9 dans la classe qui contient l'op\u00e9ration.\n\nImporter les classes est n\u00e9cessaire \u00e0 la g\u00e9n\u00e9ration de code. Une bonne modularisation des classes en paquetages est n\u00e9cessaire \u00e0 une conception compr\u00e9hensibles.\n\nPour corriger, appuyez sur le bouton \u00ab Next> \u00bb, ou ajoutez manuellement une directive d'importation dans la classe qui contient l'op\u00e9ration." },
        { "CrSignatureConflict_head" ,
                "Resolvez le conflit de signature" },
        { "CrSignatureConflict_desc" ,
                "Deux op\u00e9rations de <ocl>self</ocl> ont la m\u00eame signature. Une signature est la combinaison du nom de l'op\u00e9ration, du nombre et des types de ses param\u00e8tres.\n\nLes op\u00e9rations doivent avoir des signatures distinctes pour pouvoir g\u00e9n\u00e9rer du code qui soit compilable.Pour corriger, appuyez sur le bouton \u00ab Next> \u00bb, ou double-cliquez manuellement sur l'une des op\u00e9rations en conflit et changez son nom ou ses param\u00e8tres \u00e0 l'aide de l'onglet des propri\u00e9t\u00e9s." },
        { "CrUselessAbstract_head" ,
                "D\u00e9finissez des sous-classes concr\u00e8tes" },
        { "CrUselessAbstract_desc" ,
                "<ocl>self</ocl> can never influence the running system because it can never have any instances, and none of its subclasses can have instances either. \n\nTo fix this problem: (1) define concrete subclasses that implement the interface of this class; or (2) make <ocl>self</ocl> or one of its existing subclasses concrete." },
        { "CrUselessInterface_head" ,
                "D\u00e9finissez des classes impl\u00e9mentant <ocl>self</ocl>" },
        { "CrUselessInterface_desc" ,
                "<ocl>self</ocl> can never be used because no classes implement it.\n\nTo fix this problem, press the \"Next>\" button or manually use the toolbar \"Class\" button to define classes and the \"Realizes\" button to make a relationship from the class to the highlighted interface." },
        { "CrDisambigClassName_head" ,
                "Choisissez un nom unique pour <ocl>self</ocl>" },
        { "CrDisambigClassName_desc" ,
                "Every class and interface within a package must have a unique name. There are at least two elements in this package named \"<ocl>self</ocl>\".\n\nClear and unambiguous naming is key to code generation and the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select one of the conflicting classes and use the Properties tab to change their names." },
        { "CrDisambigStateName_head" ,
                "Choisissez un nom unique pour <ocl>self</ocl>" },
        { "CrDisambigStateName_desc" ,
                "Every state within a state machine must have a unique name. There are at least two states in this machine named \"<ocl>self</ocl>\".\n\nClear and unambiguous naming is key to code generation and the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select one of the conflicting states and use the \"Properties\" tab to change their names." },
        { "CrConflictingComposites_head" ,
                "Supprimez les relations de composition conflictuelles" },
        { "CrConflictingComposites_desc" ,
                "A composite (black diamond) role of an association indicates that instances of that class contain instances of the associated classes. Since each instance can only be contained in one other object, each object can be the 'part' in at most one is-part-of relationship.\n\nGood OO design depends on building good is-part-of relationships.\n\nTo fix this, use the \"Next>\" button, or manually change one association to have multiplicity to 0..1 or 1..1, or another kind of aggregation (e.g., a white diamond is less strict), or remove one of the associations" },
        { "CrTooManyAssoc_head" ,
                "R\u00e9duisez le nombre d'associations sur <ocl>self</ocl>" },
        { "CrTooManyAssoc_desc" ,
                "There are too many Associations on class <ocl>self</ocl>.  Whenever one class becomes too central to the design it may become a maintenance bottleneck that must be updated frequently. \n\nDefining the associations between objects is an important part of your design. \n\nTo fix this, press the \"Next>\" button, or remove associations manually by clicking on an association in the navigator pane or diagram and presing the \"Del\" key. " },
        { "CrTooManyAttr_head" ,
                "R\u00e9duisez le nombre d'attribut de <ocl>self</ocl>" },
        { "CrTooManyAttr_desc" ,
                "There are too many Attributes on class <ocl>self</ocl>.  Whenever one class becomes too central to the design it may become a maintenance bottleneck that must be updated frequently. \n\nDefining the attributes of objects is an important part of your design. \n\nTo fix this, press the \"Next>\" button, or remove attributes manually by double-clicking on the attribute compartment of the  highlighted class in the diagram and removing the line of text for an attribute. " },
        { "CrTooManyOper_head" ,
                "R\u00e9duisez le nombre d'op\u00e9rations de <ocl>self</ocl>" },
        { "CrTooManyOper_desc" ,
                "There are too many Operations on class <ocl>self</ocl>.  Whenever one class becomes too central to the design it may become a maintenance bottleneck that must be updated frequently. \n\nDefining the operations of objects is an important part of your design. \n\nTo fix this, press the \"Next>\" button, or remove attributes manually by double-clicking on the operation compartment of the  highlighted class in the diagram and removing the line of text for an operation. " },
        { "CrTooManyStates_head" ,
                "R\u00e9duisez le nombre d'\u00e9tats de <ocl>self</ocl>" },
        { "CrTooManyStates_desc" ,
                "There are too many States in <ocl>self</ocl>.  If one state machine has too many states it may become very difficult for humans to understand. \n\nDefining an understandable set of states is an important part of your design. \n\nTo fix this, press the \"Next>\" button, or remove states manually by clicking on a states in the navigator pane or diagram and presing the \"Del\" key.  Or you can nest states..." },
        { "CrTooManyTransitions_head" ,
                "R\u00e9duisez le nombre de transitions de <ocl>self</ocl>" },
        { "CrTooManyTransitions_desc" ,
                "There are too many Transitions on state <ocl>self</ocl>.  Whenever one state becomes too central to the machine it may become a maintenance bottleneck that must be updated frequently. \n\nDefining the transitions between states is an important part of your design. \n\nTo fix this, press the \"Next>\" button, or remove transitions manually by clicking on a transition in the navigator pane or diagram and presing the \"Del\" key. " },
        { "CrTooManyClasses_head" ,
                "R\u00e9duisez le nombre de classes du diagramme <ocl>self</ocl>" },
        { "CrTooManyClasses_desc" ,
                "There are too many classes in <ocl>self</ocl>.  If one class diagram has too many classes it may become very difficult for humans to understand. \n\nDefining an understandable set of class diagrams is an important part of your design. \n\nTo fix this, press the \"Next>\" button, or remove classes manually by clicking on a class in the navigator pane or diagram and presing the \"Del\" key.  Or you can make a new diagram..." },
        { "CrNoTransitions_head" ,
                "Ajoutez des transitions \u00e0 <ocl>self</ocl>" },
        { "CrNoTransitions_desc" ,
                "MState <ocl>self</ocl> has no Incoming or Outgoing transitions. Normally states have both incoming and outgoing transitions. \n\nDefining complete state transitions is needed to complete the behavioral specification part of your design.  \n\nTo fix this, press the \"Next>\" button, or add transitions manually by clicking on transition tool in the tool bar and dragging from another state to <ocl>self</ocl> or from <ocl>self</ocl> to another state. " },
        { "CrNoIncomingTransitions_head" ,
                "Ajoutez des transitions entrantes dans <ocl>self</ocl>" },
        { "CrNoIncomingTransitions_desc" ,
                "MState <ocl>self</ocl> has no incoming transitions. Normally states have both incoming and outgoing transitions. \n\nDefining complete state transitions is needed to complete the behavioral specification part of your design. Without incoming transitions, this state can never be reached.\n\nTo fix this, press the \"Next>\" button, or add transitions manually by clicking on transition tool in the tool bar and dragging from another state to <ocl>self</ocl>. " },
        { "CrNoOutgoingTransitions_head" ,
                "Ajoutez des transitions sortantes de <ocl>self</ocl>" },
        { "CrNoOutgoingTransitions_desc" ,
                "MState <ocl>self</ocl> has no Outgoing transitions. Normally states have both incoming and outgoing transitions. \n\nDefining complete state transitions is needed to complete the behavioral specification part of your design.  Without outgoing transitions, this state is a \"dead\" state that can naver be exited.\n\nTo fix this, press the \"Next>\" button, or add transitions manually by clicking on transition tool in the tool bar and dragging from another state to <ocl>self</ocl>. " },
        { "CrMultipleInitialStates_head" ,
                "Supprimez les \u00e9tats initiaux surnum\u00e9raires" },
        { "CrMultipleInitialStates_desc" ,
                "There are multiple, ambiguous initial states in this machine. Normally each state machine or composite state has one initial state. \n\nDefining unabiguous states is needed to complete the behavioral specification part of your design.\n\nTo fix this, press the \"Next>\" button, or add manually select one of the extra initial states and remove it. " },
        { "CrNoInitialState_head" ,
                "Mettez un \u00e9tat initial" },
        { "CrNoInitialState_desc" ,
                "There is no initial state in this machine or composite state. Normally each state machine or composite state has one initial state. \n\nDefining unabiguous states is needed to complete the behavioral specification part of your design.\n\nTo fix this, press the \"Next>\" button, or add manually select initial state from the tool bar and place it in the diagram. " },
        { "CrNoTriggerOrGuard_head" ,
                "Ajoutez un \u00e9v\u00e9nement ou une garde" },
        { "CrNoTriggerOrGuard_desc" ,
                "The highlighted Transition is incomplete because it has no trigger or guard condition.  Triggers are events that cause a transition to be taken.  Guard conditions must be true for the transition to be taken.  If only a guard is used, the transition is taken when the condition becomes true.\n\nThis problem must be resolved to complete the state machine.\n\nTo fix this, select the Transition and use the \"Properties\" tab, or select the Transition and type some text of the form:\nTRIGGER [GUARD] / ACTION\nWhere TRIGGER is an event name, GUARD is a boolean expression, and ACTION is an action to be performed when the MTransition is taken.  All three parts are optional." },
        { "CrNoGuard_head" ,
                "Ajoutez une garde \u00e0 la transition" },
        { "CrNoGuard_desc" ,
                "The highlighted Transisition is incomplete because it has no guard condition.  MGuard conditions must be true for the transition to be taken.  If only a guard is used, the transition is taken when the condition becomes true.\n\nThis problem must be resolved to complete the state machine.\n\nTo fix this, select the MTransition and use the \"Properties\" tab, or select the MTransition and type some text of the form:\n[GUARD]\nWhere GUARD is a boolean expression." },
        { "CrInvalidFork_head" ,
                "Changez les transitions de la fourche" },
        { "CrInvalidFork_desc" ,
                "This fork state has an invalid number of transitions. Normally fork states have one incoming and two or more outgoing transitions. \n\nDefining correct state transitions is needed to complete the  behavioral specification part of your design.  \n\nTo fix this, press the \"Next>\" button, or remove transitions  manually by clicking on transition in the diagram and pressing the Delete key. " },
        { "CrInvalidJoin_head" ,
                "Changez les transitions de la jonction" },
        { "CrInvalidJoin_desc" ,
                "This join state has an invalid number of transitions. Normally join states have two or more incoming and one outgoing transitions. \n\nDefining correct state transitions is needed to complete the  behavioral specification part of your design.  \n\nTo fix this, press the \"Next>\" button, or remove transitions  manually by clicking on transition in the diagram and pressing the Delete key. " },
        { "CrInvalidBranch_head" ,
                "Changez les transitions de la branche" },
        { "CrInvalidBranch_desc" ,
                "This branch state has an invalid number of transitions. Normally branch states have one incoming and two or more outgoing transitions. \n\nDefining correct state transitions is needed to complete the  behavioral specification part of your design.  \n\nTo fix this, press the \"Next>\" button, or remove transitions  manually by clicking on transition in the diagram and pressing the Delete key, or add transitions using the transition tool. " },
        { "CrEmptyPackage_head" ,
                "Ajoutez des \u00e9l\u00e9ments au paquetage <ocl>self</ocl>" },
        { "CrEmptyPackage_desc" ,
                "You have not yet put anything in package <ocl>self</ocl>. Normally packages contain groups of related classes.\n\nDefining and using packages is key to making a maintainable design. \n\nTo fix this, select package <ocl>self</ocl> in the navigator panel and add  diagrams or model elements such as classes or use cases. " },
        { "CrNoOperations_head" ,
                "Ajoutez des op\u00e9rations \u00e0 <ocl>self</ocl>" },
        { "CrNoOperations_desc" ,
                "You have not yet specified operations for <ocl>self</ocl>. Normally classes provide operations that define their behavior. \n\nDefining operations is needed to complete the behavioral specification part of your design. \n\nTo fix this, press the \"Next>\" button, or add operations manually by clicking on <ocl>self</ocl> in the navigator pane and using the Create menu to make a new operations. " },
        { "CrConstructorNeeded_head" ,
                "Ajouter un constructeur \u00e0 <ocl>self</ocl>" },
        { "CrConstructorNeeded_desc" ,
                "You have not yet defined a constructor for class <ocl>self</ocl>. Constructors initialize new instances such that their attributes have valid values.  This class probably needs a constructor because not all of its attributes have initial values. \n\nDefining good constructors is key to establishing class invariants, and class invariants are a powerful aid in writing solid code. \n\nTo fix this, press the \"Next>\" button, or add a constructor manually by clicking on <ocl>self</ocl> in the navigator pane and using the Create menu to make a new constructor. " },
        { "CrNameConfusion_head" ,
                "Modifiez les noms pour \u00e9viter des confusions" },
        { "CrNameConfusion_desc" ,
                "Names should be clearly distinct from each other. These two names are so close to each other that readers might be confused.\n\nClear and unambiguous naming is key to code generation and the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select the elements and use the Properties tab to change their names.  Avoid names that differ from other names only in capitalization, or use of underscore characters, or by only one character." },
        { "CrMergeClasses_head" ,
                "\u00c9tudiez la possibilit\u00e9 de combiner les classes" },
        { "CrMergeClasses_desc" ,
                "The highlighted class, <ocl>self</ocl>, only participates in one association and that association is one-to-one with another class.  Since instances of these two classes must always be created together and destroyed together, combining these classes might simplify your design without loss of any representation power.  However, you may find the combined class too large and complex, in which case separating them is usually better.\n\nOrganizing classes to manage complexity of the design is always important, especially when the design is already complex. \n\nTo fix this, click on the \"Next>\" button, or manually add the attribues and operations of the highlighted class to the other class, then remove the highlighted class from the project. " },
        { "CrSubclassReference_head" ,
                "Supprimez les r\u00e9f\u00e9rences \u00e0 une sous-classe sp\u00e9cifique" },
        { "CrSubclassReference_desc" ,
                "Class <ocl>self</ocl> has a reference to one of it's subclasses. Normally all subclasses should be treated \"equally\" by the superclass.  This allows for addition of new subclasses without modification to the superclass. \n\nDefining the associations between objects is an important part of your design.  Some patterns of associations are easier to maintain than others, depending on the natre of future changes. \n\nTo fix this, press the \"Next>\" button, or remove the association  manually by clicking on it in the diagram and pressing Delete. " },
        { "CrComponentWithoutNode_head" ,
                "Mettez les composants dans les n\u0153uds" },
        { "CrComponentWithoutNode_desc" ,
                "There are nodes in the diagram. So you have got a real\n deployment-diagram, and in deployment-diagrams components\n normally resides on nodes." },
        { "CrCompInstanceWithoutNode_head" ,
                "Mettez les instances de composants dans les n\u0153uds" },
        { "CrCompInstanceWithoutNode_desc" ,
                "There are node-instances in the Diagram. So you have got a real\n deployment-diagram, and in deployment-diagrams Component-instances\n normally resides on node-instances." },
        { "CrClassWithoutComponent_head" ,
                "Mettez les classes dans les composants" },
        { "CrClassWithoutComponent_desc" ,
                " In Deployment-diagrams classes are normally inside components" },
        { "CrInterfaceWithoutComponent_head" ,
                "Mettez les interfaces dans les composants" },
        { "CrInterfaceWithoutComponent_desc" ,
                " In Deployment-diagrams interfaces are normally inside components" },
        { "CrObjectWithoutComponent_head" ,
                "Mettez les objets dans les composants" },
        { "CrObjectWithoutComponent_desc" ,
                " In Deployment-diagrams objects are normally inside components or component-instances" },
        { "CrNodeInsideElement_head" ,
                "Otez les n\u0153uds inclus dans d'autres \u00e9l\u00e9ments" },
        { "CrNodeInsideElement_desc" ,
                " Nodes normally are not inside other Elements. They represent\n run-time physical objects with a processing resource, generally having\n at least a memory and often processing capability as well." },
        { "CrNodeInstanceInsideElement_head" ,
                "Otez les instances de n\u0153uds incluses dans d'autres \u00e9l\u00e9ments" },
        { "CrNodeInstanceInsideElement_desc" ,
                " NodeInstances normally are not inside other Elements. They represent\n run-time physical objects with a processing resource, generally having\n at least a memory and often processing capability as well." },
        { "CrWrongLinkEnds_head" ,
                "Corrigez les extr\u00e9mit\u00e9s de liens qui ne sont pas au m\u00eame endroit" },
        { "CrWrongLinkEnds_desc" ,
                " In deployment-diagrams objects can reside either on components\n or on component-instances. So it is not possible to have two objects\n connected with a Link, while one object resides on an component and\n an the other object on a component-instance.\n\n\n To fix this remove one object of the two connected objects from its location to an element that has the\n same type as the location of the other object" },
        { "CrInstanceWithoutClassifier_head" ,
                "Mettez un qualificateur" },
        { "CrInstanceWithoutClassifier_desc" ,
                " Instances have a classifier" },
        { "CrCallWithoutReturn_head" ,
                "Ajoutez une action en retour" },
        { "CrCallWithoutReturn_desc" ,
                "Every call- or send-action requires a return-action,\n but this Link has no return-action.\n" },
        { "CrReturnWithoutCall_head" ,
                "Ajouter une action d'appel ou d'envoi" },
        { "CrReturnWithoutCall_desc" ,
                "Every return-action requires a call- or send-action,\n but this Link has no corresponding call- or send-action.\n" },
        { "CrLinkWithoutStimulus_head" ,
                "Ajoutez un message au lien" },
        { "CrLinkWithoutStimulus_desc" ,
                "In sequence-diagrams a sender-object sends stimuli\nto a receiving object over a link. The link is only the communication-\nconnection, so a stimulus is needed." },
        { "CrSeqInstanceWithoutClassifier_head" ,
                "Ajoutez un qualificateur" },
        { "CrSeqInstanceWithoutClassifier_desc" ,
                " Instances have a classifier" },
        { "CrStimulusWithWrongPosition_head" ,
                "Changez la position des messages" },
        { "CrStimulusWithWrongPosition_desc" ,
                "In sequence-diagrams the sender-side of the communication-connections of these\nstimuli are connected at the beginning of an activation. To be a sender an object must\nhave a focus-of-control first." },
        { "CrUnconventionalOperName_head" ,
                "Choisissez un meilleur nom d'op\u00e9ration" },
        { "CrUnconventionalOperName_desc" ,
                "Normally operation names begin with a lowercase letter. The name '<ocl>self</ocl>' is unconventional because it does not.\n\nFollowing good naming conventions help to improve the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select <ocl>self</ocl> and use the Properties tab to give it a new name." },
        { "CrUnconventionalAttrName_head" ,
                "Choisissez un meilleur nom d'attribut" },
        { "CrUnconventionalAttrName_desc" ,
                "Normally attributes begin with a lowercase letter. The name '<ocl>self</ocl>' is unconventional because it does not.\n\nFollowing good naming conventions help to improve the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select <ocl>self</ocl> and use the Properties tab to give it a different name." },
        { "CrUnconventionalClassName_head" ,
                "Capitalisez le nom de la classe <ocl>self</ocl>" },
        { "CrUnconventionalClassName_desc" ,
                "Normally classes begin with a capital letter. The name '<ocl>self</ocl>' is unconventional because it does not begin with a capital.\n\nFollowing good naming conventions help to improve the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select <ocl>self</ocl> and use the Properties tab to give it a different name." },
        { "CrUnconventionalPackName_head" ,
                "Modifiez le nom du paquetage <ocl>self</ocl>" },
        { "CrUnconventionalPackName_desc" ,
                "Normally package names are written in all lower case with periods used to indicate \"nested\" packages.  The name '<ocl>self</ocl>' is unconventional because it is not all lower case with periods.\n\nFollowing good naming conventions help to improve the understandability and maintainability of the design. \n\nTo fix this, use the \"Next>\" button, or manually select <ocl>self</ocl> and use the Properties tab to give it a different name." },
        { "CrClassMustBeAbstract_head" ,
                "Qualifiez la classe d'abstraite" },
        { "CrClassMustBeAbstract_desc" ,
                "Classes that include or inherit abstract methods from base classes or interfaces must be marked Abstract.\n\nDeciding which classes are abstract or concrete is a key part of class hierarchy design.\n\nTo fix this, use the \"Next>\" button, or manually select the class and use the properties tab to add the Abstract keyword, or manually override each abstract operation that is inherited from a base class or interface." },
        { "CrReservedName_head" ,
                "Changez <ocl>self</ocl> en un mot non r\u00e9serv\u00e9" },
        { "CrReservedName_desc" ,
                "\"<ocl>self</ocl>\" is a reserved word or very close to one.  The names of model elements must not conflict with reserved words of programming languages or UML.\n\nUsing legal names is needed to generate compilable code. \n\nTo fix this, use the \"Next>\" button, or manually select the highlighted element and use the Properties tab to give it a different name." },
        { "CrMultipleInheritance_head" ,
                "Remplacez l'h\u00e9ritage multiple par des interfaces" },
        { "CrMultipleInheritance_desc" ,
                "<ocl>self</ocl> has multiple base classes, but Java does not support multiple inheritance.  You must use interfaces instead. \n\nThis change is required before you can generate Java code.\n\nTo fix this, use the \"Next>\" button, or manually (1) remove one of the base classes and then (2) optionally define a new interface with the same method declarations and (3) add it as an interface of <ocl>self</ocl>, and (4) move the method bodies from the old base class down into <ocl>self</ocl>." },
        { "CrIllegalName_head" ,
                "Choisissez un nom autoris\u00e9" },
        { "CrIllegalName_desc" ,
                "The names of model elements must be sequences of letters, numbers, and underscores.  They cannot contain punctuation.\n\nCode generation requires legal names for the resulting code to compile correctly. \n\nTo fix this, use the \"Next>\" button, or manually select the highlighted element and use the Properties tab to give it a different name." },
        { "CrConsiderSingleton_head" ,
                "\u00c9tudiez la possibilit\u00e9 d'utiliser le mod\u00e8le de conception du singleton" },
        { "CrConsiderSingleton_desc" ,
                "This class has no attributes or associations that are navigable away from instances of this class.  This means that every instance of this class will be equal() to every other instance, since there will be no instance variables to differentiate them. If this not your intent, you should define some attributes or associations that will represent differences bewteen instances. If there are no attributes or associations that differentiate instances, the you shoudld consider having exatly one instance of this class, as in the Singleton Pattern.\n\nDefining the multiplicity of instances is needed to complete the information representation part of your design.  Using the Singleton Pattern can save time and memory space.\n\nTo automatically apply the Singleton Pattern, press the \"Next>\" button; or manually (1) mark the class with the Singleton stereotype, (2) add a static variable that holds one instance of this class, (3) and make all constructors private.\n\nTo learn more about the Singleton Pattern, press the MoreInfo icon." },
        { "CrSingletonViolated_head" ,
                "Corrigez l'utilisation du st\u00e9r\u00e9otype du singleton" },
        { "CrSingletonViolated_desc" ,
                "This class is marked with the Singleton stereotype, but it does not satisfy the constraints imposed on singletons.  A singleton class can have at most one instance.  This means that the class must have (1) a static variable holding the instance, (2) only private constructors so that new instances cannot be made by other code, and (3) there must be at least one constructor to override the default constructor.\n\nWhenever you mark a class with a stereotype, the class should satisfy all constraints of the stereotype.  This is an important part of making a self-consistent and understangle design. Using the Singleton Pattern can save time and memory space.\n\nIf you no longer want this class to be a Singleton, remove the Singleton stereotype by clicking on the class and deleting Singleton from the Props tab. \nTo automatically apply the Singleton Pattern, press the \"Next>\" button; or manually (1) mark the class with the Singleton stereotype, (2) add a static variable that holds one instance of this class, (3) and make all constructors private.\n\nTo learn more about the Singleton Pattern, press the MoreInfo icon." },
        { "CrNodesOverlap_head" ,
                "R\u00e9organisez votre diagramme" },
        { "CrNodesOverlap_desc" ,
                "Some of the objects in this diagram overlap and obscure each other. This may hide important information and make it difficult for humans to understand. A neat appearance may also make your diagrams more influencial on other designers, implementors, and decision makers.\n\nConstructing an understandable set of class diagrams is an important part of your design. \n\nTo fix this, move the highlighted nodes in the diagram." },
        { "CrZeroLengthEdge_head" ,
                "Allongez cette ligne" },
        { "CrZeroLengthEdge_desc" ,
                "This edge is too small to see easily. This may hide important information and make it difficult for humans to understand. A neat appearance may also make your diagrams more influencial on other designers, implementors, and decision makers.\n\nConstructing an understandable set of diagrams is an important part of your design. \n\nTo fix this, move one or more nodes so that the highlighted edges will be longer, or click in the center of the edge and drag to make a new vertex." },
        //
        //   these phrases should be localized here
        //      not in the following check list section
        { "Naming", "Nommage" },
        { "Encoding", "Encodage" },
        { "Value", "Valeur" },
        { "Location", "Position" },
        { "Updates", "Mises \u00e0 jour" },
        { "General", "G\u00e9n\u00e9ral" },
        { "Actions" , "Actions" },
        { "Transitions", "Transitions" },
        { "Structure", "Structure" },
        { "Trigger", "\u00c9v\u00e9nements" },
        { "MGuard", "Garde" },
        //
        //   The following blocks define the UML related
        //      Checklists.  The key is the name of
        //      the non-deprecated implementing class,
        //      the value is an array of categories which
        //      are each an array of Strings.  The first
        //      string in each category is the name of the
        //      category and should not be localized here
        //      but should be in the immediate preceeding
        //      section
        //
        { "ChClass",
            new String[][] {
                new String[] { "Naming",
                  "Does the name '<ocl>self</ocl>' clearly describe the class?",
                  "Is '<ocl>self</ocl>' a noun or noun phrase?",
                  "Could the name '<ocl>self</ocl>' be misinterpreted to mean something else?"
                },
                new String[] { "Encoding",
                  "Should <ocl>self</ocl> be its own class or a simple attribute of another class?",
                  "Does <ocl>self</ocl> do exactly one thing and do it well?",
                  "Could <ocl>self</ocl> be broken down into two or more classes?"
                },
                new String[] { "Value",
                  "Do all attributes of <ocl>self</ocl> start with meaningful values?",
                  "Could you write an invariant for this class?",
                  "Do all constructors establish the class invariant?",
                  "Do all operations maintain the class invariant?"
                },
                new String[] { "Location",
                  "Could <ocl>self</ocl> be defined in a different location in the class hierarchy?",
                  "Have you planned to have subclasses of <ocl>self</ocl>?",
                  "Could <ocl>self</ocl> be eliminated from the model?",
                  "Is there another class in the model that should be revised or eliminated because it serves the same purpose as <ocl>self</ocl>?"
                },
                new String[] { "Updates",
                  "For what reasons will an instance of <ocl>self</ocl> be updated?",
                  "Is there some other object that must be updated whenever <ocl>self</ocl> is updated?"
                }
            }
        },
        { "ChAttribute",
            new String[][] {
                new String[] { "Naming",
                  "Does the name '<ocl>self</ocl>' clearly describe the attribute?",
                  "Is '<ocl>self</ocl>' a noun or noun phrase?",
                  "Could the name '<ocl>self</ocl>' be misinterpreted to mean something else?"
                },
                new String[] { "Encoding",
                  "Is the type <ocl>self.type</ocl> too restrictive to represent all possible values of <ocl>self</ocl>?",
                  "Does the type <ocl>self.type</ocl> allow values for <ocl>self</ocl> that could never be correct?",
                  "Could <ocl>self</ocl> be combined with some other attribute of <ocl>self.owner</ocl> (e.g., {owner.structuralFeature})?",
                  "Could <ocl>self</ocl> be broken down into two or more parts (e.g., a phonenumber can be broken down into area code, prefix, and number)?",
                  "Could <ocl>self</ocl> be computed from other attributes instead of stored?"
                },
                new String[] { "Value",
                  "Should <ocl>self</ocl> have an initial (or default) value?",
                  "Is the initial value <ocl>self.initialValue</ocl> correct?",
                  "Could you write an expression to check if <ocl>self</ocl> is correct? Plausible?"
                },
                new String[] { "Location",
                  "Could <ocl>self</ocl> be defined in a different class that is associated with <ocl>self.owner</ocl>?",
                  "Could <ocl>self</ocl> be moved up the inheritance hierarchy to apply to owner.name and to other classes?",
                  "Does <ocl>self</ocl> apply to all instances of class <ocl>self.owner</ocl> including instances of subclasses?",
                  "Could <ocl>self</ocl> be eliminated from the model?",
                  "Is there another attribute in the model that should be revised or eliminated because it serves the same purpose as <ocl>self</ocl>?"
                },
                new String[] { "Updates",
                  "For what reasons will <ocl>self</ocl> be updated?",
                  "Is there some other attribute that must be updated whenever <ocl>self</ocl> is updated?",
                  "Is there a method that should be called when <ocl>self</ocl> is updated?",
                  "Is there a method that should be called when <ocl>self</ocl> is given a certain kind of value?"
                }
            }
        },
        { "ChOperation",
            new String[][] {
                new String[] { "Naming",
                  "Does the name '<ocl>self</ocl>' clearly describe the operation?",
                  "Is '<ocl>self</ocl>' a verb or verb phrase?",
                  "Could the name '<ocl>self</ocl>' be misinterpreted to mean something else?",
                  "Does <ocl>self</ocl> do one thing and do it well?"
                },
                new String[] { "Encoding",
                  "Is the return type '<ocl>self.returnType</ocl>' too restrictive to represent all possible values returned by <ocl>self</ocl>?",
                  "Does '<ocl>self.returnType</ocl>' allow return values that could never be correct?",
                  "Could <ocl>self</ocl> be combined with some other operation of <ocl>self.owner</ocl> (e.g., <ocl sep=', '>self.owner.behavioralFeature</ocl>)?",
                  "Could <ocl>self</ocl> be broken down into two or more parts (e.g., pre-process, main processing, and post-processing)?",
                  "Could <ocl>self</ocl> be replaced by a series of client calls to simpler operations?",
                  "Could <ocl>self</ocl> be combined with other operations to reduce the number of calls clients must make?"
                },
                new String[] { "Value",
                  "Can <ocl>self</ocl> handle all possible inputs?",
                  "Are there special case inputs that must be handled separately?",
                  "Could you write an expression to check if the arguments to <ocl>self</ocl> are correct? Plausible?",
                  "Can you express the preconditions of <ocl>self</ocl>?",
                  "Can you express the postconditions of <ocl>self</ocl>?",
                  "How will <ocl>self</ocl> behave if preconditions are violated?",
                  "How will <ocl>self</ocl> behave if postconditions cannot be achieved?"
                },
                new String[] { "Location",
                  "Could <ocl>self</ocl> be defined in a different class that is associated with <ocl>self.owner</ocl>?",
                  "Could <ocl>self</ocl> be moved up the inheritance hierarchy to apply to <ocl>self.owner</ocl> and to other classes?",
                  "Does <ocl>self</ocl> apply to all instances of class <ocl>self.owner</ocl> including instances of subclasses?",
                  "Could <ocl>self</ocl> be eliminated from the model?",
                  "Is there another operation in the model that should be revised or eliminated because it serves the same purpose as <ocl>self</ocl>?"
                }
            }
        },
        { "ChAssociation",
            new String[][] {
                new String[] { "Naming",
                  "Does the name '<ocl>self</ocl>' clearly describe the class?",
                  "Is '<ocl>self</ocl>' a noun or noun phrase?",
                  "Could the name '<ocl>self</ocl>' be misinterpreted to mean something else?"
                },
                new String[] { "Encoding",
                  "Should <ocl>self</ocl> be its own class or a simple attribute of another class?",
                  "Does <ocl>self</ocl> do exactly one thing and do it well?",
                  "Could <ocl>self</ocl> be broken down into two or more classes?"
                },
                new String[] { "Value",
                  "Do all attributes of <ocl>self</ocl> start with meaningful values?",
                  "Could you write an invariant for this class?",
                  "Do all constructors establish the class invariant?",
                  "Do all operations maintain the class invariant?"
                },
                new String[] { "Location",
                  "Could <ocl>self</ocl> be defined in a different location in the class hierarchy?",
                  "Have you planned to have subclasses of <ocl>self</ocl>?",
                  "Could <ocl>self</ocl> be eliminated from the model?",
                  "Is there another class in the model that should be revised or eliminated because it serves the same purpose as <ocl>self</ocl>?"
                },
                new String[] { "Updates",
                  "For what reasons will an instance of <ocl>self</ocl> be updated?",
                  "Is there some other object that must be updated whenever <ocl>self</ocl> is updated?"
                }
            }
        },
        { "ChInterface",
            new String[][] {
                new String[] { "Naming",
                  "Does the name '<ocl>self</ocl>' clearly describe the class?",
                  "Is '<ocl>self</ocl>' a noun or noun phrase?",
                  "Could the name '<ocl>self</ocl>' be misinterpreted to mean something else?"
                },
                new String[] { "Encoding",
                  "Should <ocl>self</ocl> be its own class or a simple attribute of another class?",
                  "Does <ocl>self</ocl> do exactly one thing and do it well?",
                  "Could <ocl>self</ocl> be broken down into two or more classes?"
                },
                new String[] { "Value",
                  "Do all attributes of <ocl>self</ocl> start with meaningful values?",
                  "Could you write an invariant for this class?",
                  "Do all constructors establish the class invariant?",
                  "Do all operations maintain the class invariant?"
                },
                new String[] { "Location",
                  "Could <ocl>self</ocl> be defined in a different location in the class hierarchy?",
                  "Have you planned to have subclasses of <ocl>self</ocl>?",
                  "Could <ocl>self</ocl> be eliminated from the model?",
                  "Is there another class in the model that should be revised or eliminated because it serves the same purpose as <ocl>self</ocl>?"
                },
                new String[] { "Updates",
                  "For what reasons will an instance of <ocl>self</ocl> be updated?",
                  "Is there some other object that must be updated whenever <ocl>self</ocl> is updated?"
                }
            }
        },
        { "ChInstance",
            new String[][] {
                new String[] { "General",
                  "Does this instance <ocl>self</ocl> clearly describe the instance?"
                },
                new String[] { "Naming",
                  "Does the name '<ocl>self</ocl>' clearly describe the instance?",
                  "Does '<ocl>self</ocl>' denote a state rather than an activity?",
                  "Could the name '<ocl>self</ocl>' be misinterpreted to mean something else?"
                },
                new String[] { "Structure",
                  "Should <ocl>self</ocl> be its own state or could it be merged with another state?",
                  "Does <ocl>self</ocl> do exactly one thing and do it well?",
                  "Could <ocl>self</ocl> be broken down into two or more states?",
                  "Could you write a characteristic equation for <ocl>self</ocl>?",
                  "Does <ocl>self</ocl> belong in this state machine or another?",
                  "Should <ocl>self</ocl> be be an initial state?",
                  "Is some state in another machine exclusive with <ocl>self</ocl>?"
                },
                new String[] { "Actions",
                  "What action should be preformed on entry into <ocl>self</ocl>?",
                  "Should some attribute be updated on entry into <ocl>self</ocl>?",
                  "What action should be preformed on exit from <ocl>self</ocl>?",
                  "Should some attribute be updated on exit from <ocl>self</ocl>?",
                  "What action should be preformed while in <ocl>self</ocl>?",
                  "Do state-actions maintain <ocl>self</ocl> as the current state?"
                },
                new String[] { "Transitions",
                  "Should there be another transition into <ocl>self</ocl>?",
                  "Can all the transitions into <ocl>self</ocl> be used?",
                  "Could some incoming transitions be combined?",
                  "Should there be another transition out of <ocl>self</ocl>?",
                  "Can all the transitions out of <ocl>self</ocl> be used?",
                  "Is each outgoing transition exclusive?",
                  "Could some outgoing transitions be combined?"
                }
            }
        },
        { "ChLink",
            new String[][] {
                new String[] { "Naming",
                  "Does the name '<ocl>self</ocl>' clearly describe the class?",
                  "Is '<ocl>self</ocl>' a noun or noun phrase?",
                  "Could the name '<ocl>self</ocl>' be misinterpreted to mean something else?"
                },
                new String[] { "Encoding",
                  "Should <ocl>self</ocl> be its own class or a simple attribute of another class?",
                  "Does <ocl>self</ocl> do exactly one thing and do it well?",
                  "Could <ocl>self</ocl> be broken down into two or more classes?"
                },
                new String[] { "Value",
                  "Do all attributes of <ocl>self</ocl> start with meaningful values?",
                  "Could you write an invariant for this class?",
                  "Do all constructors establish the class invariant?",
                  "Do all operations maintain the class invariant?"
                },
                new String[] { "Location",
                  "Could <ocl>self</ocl> be defined in a different location in the class hierarchy?",
                  "Have you planned to have subclasses of <ocl>self</ocl>?",
                  "Could <ocl>self</ocl> be eliminated from the model?",
                  "Is there another class in the model that should be revised or eliminated because it serves the same purpose as <ocl>self</ocl>?"
                },
                new String[] { "Updates",
                  "For what reasons will an instance of <ocl>self</ocl> be updated?",
                  "Is there some other object that must be updated whenever <ocl>self</ocl> is updated?"
                }
            }
        },
        { "ChState",
            new String[][] {
                new String[] { "Naming",
                  "Does the name '<ocl>self</ocl>' clearly describe the state?",
                  "Does '<ocl>self</ocl>' denote a state rather than an activity?",
                  "Could the name '<ocl>self</ocl>' be misinterpreted to mean something else?"
                },
                new String[] { "Structure",
                  "Should <ocl>self</ocl> be its own state or could it be merged with another state?",
                  "Does <ocl>self</ocl> do exactly one thing and do it well?",
                  "Could <ocl>self</ocl> be broken down into two or more states?",
                  "Could you write a characteristic equation for <ocl>self</ocl>?",
                  "Does <ocl>self</ocl> belong in this state machine or another?",
                  "Should <ocl>self</ocl> be be an initial state?",
                  "Is some state in another machine exclusive with <ocl>self</ocl>?"
                },
                new String[] { "Actions",
                  "What action should be preformed on entry into <ocl>self</ocl>?",
                  "Should some attribute be updated on entry into <ocl>self</ocl>?",
                  "What action should be preformed on exit from <ocl>self</ocl>?",
                  "Should some attribute be updated on exit from <ocl>self</ocl>?",
                  "What action should be preformed while in <ocl>self</ocl>?",
                  "Do state-actions maintain <ocl>self</ocl> as the current state?"
                },
                new String[] { "Transitions",
                  "Should there be another transition into <ocl>self</ocl>?",
                  "Can all the transitions into <ocl>self</ocl> be used?",
                  "Could some incoming transitions be combined?",
                  "Should there be another transition out of <ocl>self</ocl>?",
                  "Can all the transitions out of <ocl>self</ocl> be used?",
                  "Is each outgoing transition exclusive?",
                  "Could some outgoing transitions be combined?"
                }
            }
        },
        { "ChTransition",
            new String[][] {
                new String[] { "Structure",
                  "Should this transition start at a different source?",
                  "Should this transition end at a different destination?",
                  "Should there be another transition \"like\" this one?",
                  "Is another transition unneeded because of this one?"
                },
                new String[] { "Trigger",
                  "Does this transition need a trigger?",
                  "Does the trigger happen too often?",
                  "Does the trigger happen too rarely?"
                },
                new String[] { "MGuard",
                  "Could this transition be taken too often?",
                  "Is this transition's condition too restrictive?",
                  "Could it be broken down into two or more transitions?"
                },
                new String[] { "Actions",
                  "Should this transition have an action?",
                  "Should this transition's action be an exit action?",
                  "Should this transition's action be an entry action?",
                  "Is the precondition of the action always met?",
                  "Is the action's postcondition consistent with the destination?"
                }
            }
        },
        { "ChUseCase",
            new String[][] {
                new String[] { "Naming",
                  "Does the name '<ocl>self</ocl>' clearly describe the class?",
                  "Is '<ocl>self</ocl>' a noun or noun phrase?",
                  "Could the name '<ocl>self</ocl>' be misinterpreted to mean something else?"
                },
                new String[] { "Encoding",
                  "Should <ocl>self</ocl> be its own class or a simple attribute of another class?",
                  "Does <ocl>self</ocl> do exactly one thing and do it well?",
                  "Could <ocl>self</ocl> be broken down into two or more classes?"
                },
                new String[] { "Value",
                  "Do all attributes of <ocl>self</ocl> start with meaningful values?",
                  "Could you write an invariant for this class?",
                  "Do all constructors establish the class invariant?",
                  "Do all operations maintain the class invariant?"
                },
                new String[] { "Location",
                  "Could <ocl>self</ocl> be defined in a different location in the class hierarchy?",
                  "Have you planned to have subclasses of <ocl>self</ocl>?",
                  "Could <ocl>self</ocl> be eliminated from the model?",
                  "Is there another class in the model that should be revised or eliminated because it serves the same purpose as <ocl>self</ocl>?"
                },
                new String[] { "Updates",
                  "For what reasons will an instance of <ocl>self</ocl> be updated?",
                  "Is there some other object that must be updated whenever <ocl>self</ocl> is updated?"
                }
            }
        },
        { "ChActor",
            new String[][] {
                new String[] { "Naming",
                  "Does the name '<ocl>self</ocl>' clearly describe the class?",
                  "Is '<ocl>self</ocl>' a noun or noun phrase?",
                  "Could the name '<ocl>self</ocl>' be misinterpreted to mean something else?"
                },
                new String[] { "Encoding",
                  "Should <ocl>self</ocl> be its own class or a simple attribute of another class?",
                  "Does <ocl>self</ocl> do exactly one thing and do it well?",
                  "Could <ocl>self</ocl> be broken down into two or more classes?"
                },
                new String[] { "Value",
                  "Do all attributes of <ocl>self</ocl> start with meaningful values?",
                  "Could you write an invariant for this class?",
                  "Do all constructors establish the class invariant?",
                  "Do all operations maintain the class invariant?"
                },
                new String[] { "Location",
                  "Could <ocl>self</ocl> be defined in a different location in the class hierarchy?",
                  "Have you planned to have subclasses of <ocl>self</ocl>?",
                  "Could <ocl>self</ocl> be eliminated from the model?",
                  "Is there another class in the model that should be revised or eliminated because it serves the same purpose as <ocl>self</ocl>?"
                },
                new String[] { "Updates",
                  "For what reasons will an instance of <ocl>self</ocl> be updated?",
                  "Is there some other object that must be updated whenever <ocl>self</ocl> is updated?"
                }
            }
        }
    };

    public Object[][] getContents() {
        return _contents;
    }
}
