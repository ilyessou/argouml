// Copyright (c) 1996-2001 The Regents of the University of California. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies.  This software program and
// documentation are copyrighted by The Regents of the University of
// California. The software program and documentation are supplied "AS
// IS", without any accompanying services from The Regents. The Regents
// does not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason.  IN NO EVENT SHALL THE
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.


package org.argouml.uml.cognitive;
import java.util.*;
import org.argouml.util.*;

/**
 *   This class is the default member of a resource bundle that
 *   provides strings for UML related critiques and check lists
 *
 *   @author Curt Arnold
 *   @since 0.9
 *   @see java.util.ResourceBundle
 *   @see UMLCognitiveResourceBundle_de
 *   @see org.argouml.util.CheckResourceBundle
 *   @see org.argouml.uml.cognitive.critics.CrUML
 */
public class UMLCognitiveResourceBundle_es extends ListResourceBundle {

    private static final Object[][] _contents = {
        { "CrAssocNameConflict_head" ,
                "Resuelve conflicto en el nombre de la asociación" },
        { "CrAssocNameConflict_desc" ,
                "Todo elemento del espacio de nombres debe tener un nombre único. \n\nLa asignación de nombres claros e inequívocos es clave para la generación de código y el entendimiento y mantenibilidad del diseño. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente los elementos y usa la solapa Propiedades para cambiar sus nombres." },
        { "CrAttrNameConflict_head" ,
                "Revisa los nombres de atributos para evitar conflictos" },
        { "CrAttrNameConflict_desc" ,
                "Los atributos deben tener nombres diferentes. Esto se debe  quiza a un atributo heredado. \n\nUsar nombres claros e inequívocos es clave para la generación de código y el entendimiento y mantenibilidad del diseño. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente el atributo en conflicto de la clase y cambia su nombre." },
        { "CrOperNameConflict_head" ,
                "Cambia los nombres o firmas en <ocl>self</ocl>" },
        { "CrOperNameConflict_desc" ,
                "Dos operaciones tienen exactamente la misma firma.  Deberían ser distintas.  Una firma es una combinación del nombre de la operación, y sus tipos de parametros. \n\nEvitar firmas en conflicto es clave para la generación de código y el entendimiento y mantenibilidad del diseño. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente las operaciones en conflicto de esta clase y cambia su nombre o sus parametros." },
        { "CrCircularAssocClass_head" ,
                "MAssociation circular" },
        { "CrCircularAssocClass_desc" ,
                "Las AssociationClasses no pueden incluir roles que se refieran directamente a la MAssociationClass." },
        { "CrCircularInheritance_head" ,
                "Quita la herencia circular del <ocl>self</ocl>" },
        { "CrCircularInheritance_desc" ,
                "Las relaciones de herencia no pueden tener ciclos. \n\nSe necesita una jerarquia legal de clases para la generación de código y la corrección del diseño. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente uno de las flechas de generalización en el ciclo y quitala." },
        { "CrCircularComposition_head" ,
                "Quita la composición circular" },
        { "CrCircularComposition_desc" ,
                "Las relaciones de composición (diamantes negros) no pueden tener ciclos. \n\nUna jerarquía legal de agregación se necesita para la generación de código y la corrección del diseño. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente una de las asociaciones en el ciclo y quitala o cambia su agregación a otra que no sea composición." },
        { "CrCrossNamespaceAssoc_head" ,
                "Rol agregado en una MAssociation N-caminos" },
        { "CrCrossNamespaceAssoc_desc" ,
                "Cada clase o MInterface implicado en una MAssociation debería estar en el MNamespace de la MAssociation.\n" },
        { "CrDupParamName_head" ,
                "Nombre de parametro duplicado" },
        { "CrDupParamName_desc" ,
                "Cada parametro de una operación debe tener un nombre único. \n\nUsar nombres claros e inequívocos es clave para la generación de código y el entendimiento y mantenibilidad del diseño. \n\nPara arreglar esto, usa el botón \"Next>\", o renombra manualmente uno de los parametros de esta operación." },
        { "CrDupRoleNames_head" ,
                "Cambia los nombres de rol de <ocl>self</ocl>" },
        { "CrDupRoleNames_desc" ,
                "La MAssociation <ocl>self</ocl> tiene dos roles con nombres en conflicto. \n\nUsar nombres claros e inequívocos es clave para la generación de código y el entendimiento y mantenibilidad del diseño. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente <ocl>self</ocl> y usa la solapa de propiedades para cambiar los nombres de rol." },
        { "CrFinalSubclassed_head" ,
                "Quita la palabra clave final y las subclases." },
        { "CrFinalSubclassed_desc" ,
                "En Java, la palabra clave 'final' indica que una clase no debería tener subclases. .  Esta clase esta etiquetada final y tiene subclases.\n\nUna jerarquía de clases meditada y que permita la adecuada subclasificación es un parte importante para conseguir un diseño comprensible y mantenible.\n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente la clase y cambia su superclase, o selecciona la superclase y usa la solapa de propiedades para quitar la palabra clave 'final'." },
        { "CrIllegalGeneralization_head" ,
                "MGeneralization ilegal" },
        { "CrIllegalGeneralization_desc" ,
                "Los elementos MModel solo pueden ser heredados por otros del mismo tipo. \n\nSe necesita una jerarquía correcta para la generación de código y la corrección del diseño.Se necesita una jerarquía correcta para la generación de código y la corrección del diseño.\n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente la flecha de generalización y quitala." },
        { "CrAlreadyRealizes_head" ,
                "Quita el realiza innecesario de <ocl>self</ocl>" },
        { "CrAlreadyRealizes_desc" ,
                "La clase seleccionada ya realiza indirectamente el MInterface {item.extra}.  No hay necesidad de realizarlo otra vez.\n\nSimplificar el diseño siempre es bueno.Simplificar el diseño siempre es bueno.  Puedes descartar este elemento \"to do\" si quieres destacar que la clase seleccionada realiza este MInterface.\n\nPara arreglar esto, selecciona la Realización (línea punteada con una flecha blanca triangular) y pulsa la tecla \"Delete\"." },
        { "CrInterfaceAllPublic_head" ,
                "Las operaciones de los interfaces deben ser públicas" },
        { "CrInterfaceAllPublic_desc" ,
                "Los Interfaces especifican las operaciones que otras clases deben implementar.  Deben ser públicos. \n\nUn conjunto de interfaces bien diseñado es un buen modo de definir las posibles extensiones de un framework de clases. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente las operaciones del interfaz y usa la solapa de propiedades para hacerlas publicas." },
        { "CrInterfaceOperOnly_head" ,
                "Los interfaces solo deben tener operaciones" },
        { "CrInterfaceOperOnly_desc" ,
                "Los Interfaces especifican las operaciones que \notras clases deben implementar.  No implementan esas \noperaciones ellos mismos , y no pueden tener atributos. \n\nUn conjunto de interfaces bien diseñado es un buen modo de definir las \nposibles extensiones de un class framework. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente el  \ninterfaz y usa la solapa Propiedades para quitar todos los atributos." },
        { "CrMultipleAgg_head" ,
                "Roles agregados multiples" },
        { "CrMultipleAgg_desc" ,
                "Solo un rol de una MAssociation puede tener un agregado o compuesto.\n\nUna jerarquía es-parte-de clara y consistente es clave para la claridad del diseño, \nalmacenamiento de objetos, e implementación de métodos recursivos.\nPara arreglar esto, selecciona la MAssociation y establece algunos de sus roles de \nagregación a Ninguno." },
        { "CrNWayAgg_head" ,
                "Rol agregado en una relación de N-caminos MAssociation" },
        { "CrNWayAgg_desc" ,
                "Las asociaciones de 3 o más caminos no pueden tener aggregate ends.\n\nA clear and consistent is-part-of hierarchy is a key to design clarity, \nmanagable object storage, and the implementation of recursive methods.\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente the MAssociation \nand set all of its role aggregations to None." },
        { "CrNavFromInterface_head" ,
                "Quita la navegación del MInterface <ocl>self</ocl>" },
        { "CrNavFromInterface_desc" ,
                "Las asociaciones que implican un MInterface no pueden ser navegables en la dirección desde el MInterface.  Esto se debe a que los interfaces contienen solo declaraciones de operaciones y no pueden contener punteros a otros objetos.\n\nEsta parte del diseño debería cambiarse antes de generar el código de este diseño.  Si generas código antes de arreglar este problema, el código no se ajustará al diseño.\n\nPara arreglar esto, selecciona la MAssociation y usa la solapar \"Propiedades\" para tab to desactivar Navigable para el extremo que toca el MInterface.  La MAssociation debería parecer entonces con una flecha apuntado fuera del MInterface." },
        { "CrUnnavigableAssoc_head" ,
                "Haz navegable a <ocl>self</ocl>" },
        { "CrUnnavigableAssoc_desc" ,
                "The MAssociation <ocl>self</ocl> is not navigable in any direction. All associations should be navigable at least one way.\n\nSetting the navigablility of associations allows your code to access data by following pointers. \n\nPara arreglar esto, select association \"<ocl>self</ocl>\" in the diagram or navigator panel and click the properties tab.  Then use the checkboxes at the bottom of the properties panel to turn on navigablility. " },
        { "CrNameConflictAC_head" ,
                "El nombre del rol esta en conflicto con el miembro" },
        { "CrNameConflictAC_desc" ,
                "MAssociation role names of an MAssociationClass must not conflict \nwith the names of structral features (e.g., instance variables) \nof the class.\n" },
        { "CrMissingClassName_head" ,
                "Escoge un nombre" },
        { "CrMissingClassName_desc" ,
                "Every class and interface within a package debe tener un nombre.. \n\nLa asignación de nombres claros e inequívocos es clave para la generación de código y el entendimiento y mantenibilidad del diseño. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente la clase y usa la solapa Propiedades para asignarle un nombre." },
        { "CrMissingAttrName_head" ,
                "Escoge un nombre" },
        { "CrMissingAttrName_desc" ,
                "Todo atributo debe tener un nombre.. \n\nLa asignación de nombres claros e inequívocos es clave para la generación de código y\nel entendimiento y mantenibilidad del diseño. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente the \nattribute y usa la solapa Propiedades para give it a name." },
        { "CrMissingOperName_head" ,
                "Escoge un nombre" },
        { "CrMissingOperName_desc" ,
                "Every operation debe tener un nombre.. \n\nLa asignación de nombres claros e inequívocos es clave para la generación de código y\nel entendimiento y mantenibilidad del diseño. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente the \nattribute y usa la solapa Propiedades para give it a name." },
        { "CrMissingStateName_head" ,
                "Escoge un nombre" },
        { "CrMissingStateName_desc" ,
                "Every state within a state machine should have a name. \n\nLa asignación de nombres claros e inequívocos es clave para la generación de código y el entendimiento y mantenibilidad del diseño. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente the state y usa la solapa Propiedades para give it a name, or select the state and type a name." },
        { "CrNoInstanceVariables_head" ,
                "Añade variables de instancia a <ocl>self</ocl>" },
        { "CrNoInstanceVariables_desc" ,
                "Aun no has especificado variables de instancia para <ocl>self</ocl>. Normalmente las clases tienen variables de instancia que almacenan la información para cada instancia. Las clases que solo proporcionan atributos y métodos estáticos deberían ser estereotipadas con <<utility>>.\n\nQuiza deberías definir las variables de instancia para completar la parte de representación de la información de tu diseño. \n\nPara arreglar esto, pulsa el botón \"Next>\", o añade variables de instancia haciendo doble click en <ocl>self</ocl> en el panel de navegación o usando el menu Crear para crear un nuevo atributo. " },
        { "CrNoAssociations_head" ,
                "Añade asociaciones a <ocl>self</ocl>" },
        { "CrNoAssociations_desc" ,
                "You have not yet specified any Associations for <ocl>self</ocl>. Normally classes, actors and use cases are associated with others. \n\nDefining the associations between objects an important part of your design. \n\nPara arreglar esto, pulsa el botón \"Next>\", or add associations manually by clicking on the association tool in the tool bar and dragging from <ocl>self</ocl> to another node. " },
        { "CrNonAggDataType_head" ,
                "Envuelve MDataType" },
        { "CrNonAggDataType_desc" ,
                "DataTypes are not full classes and cannot be associated with classes, unless the MDataType is part of a composite (black diamond) aggregation. \n\nGood OO design depends on careful choices about which entities to represent as full objects and which to represent as attributes of objects.\n\nPara arreglar esto, use the \"Next>\" button, or manually replace the MDataType with a full class or change the association aggregation to containmentby a full class.\n" },
        { "CrOppEndConflict_head" ,
                "Renombra los roles MAssociation" },
        { "CrOppEndConflict_desc" ,
                "Two roles of <ocl>self</ocl> have the same name. Roles must have distinct names.  This may because of an inherited attribute. \n\nClear and unambiguous names are key to code generation and producing an understandable and maintainable design.\n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente the one of the conflicting roles at the far end of an association from this class and change its name." },
        { "CrParamTypeNotImported_head" ,
                "Importa el tipo MParameter en la clase" },
        { "CrParamTypeNotImported_desc" ,
                "The type of each operation parameter must be visible and imported into the class that owns the operation.\n\nImporting classes is needed for code generation. Good modularization of classes into packages is key to an understandable design.\n\nPara arreglar esto, use the \"Next>\" button, or manually add in import to the class that owns this operation." },
        { "CrSignatureConflict_head" ,
                "Soluciona el conflicto de firmas" },
        { "CrSignatureConflict_desc" ,
                "Two operations of <ocl>self</ocl> have same signature.  A signature consists of the operation's name and the number and types of its parameters.\n\nOperations must have distinct signatures for code generation to produce code that will compile.\n\nPara arreglar esto, use the \"Next>\" button, or manually double click on una de las operaciones en conflicto in the navigator pane y usa la solapa Propiedades para change this name or parameters." },
        { "CrUselessAbstract_head" ,
                "Define (Sub)Clases concretas" },
        { "CrUselessAbstract_desc" ,
                "<ocl>self</ocl> can never influence the running system because it can never have any instances, and none of its subclasses can have instances either. \n\nTo fix this problem: (1) define concrete subclasses that implement the interface of this class; or (2) make <ocl>self</ocl> or one of its existing subclasses concrete." },
        { "CrUselessInterface_head" ,
                "Define Class to Implement <ocl>self</ocl>" },
        { "CrUselessInterface_desc" ,
                "<ocl>self</ocl> can never be used because no classes implement it.\n\nTo fix this problem, pulsa el botón \"Next>\" or manually use the toolbar \"Class\" button to define classes and the \"Realizes\" button to make a relationship from the class to the highlighted interface." },
        { "CrDisambigClassName_head" ,
                "Choose a Unique Name for <ocl>self</ocl>" },
        { "CrDisambigClassName_desc" ,
                "Every class and interface within a package must have a unique name. There are at least two elements in this package named \"<ocl>self</ocl>\".\n\nLa asignación de nombres claros e inequívocos es clave para la generación de código y el entendimiento y mantenibilidad del diseño. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente una de las clases en conflicto y usa la solapa Propiedades para cambiar sus nombres." },
        { "CrDisambigStateName_head" ,
                "Choose a Unique Name for <ocl>self</ocl>" },
        { "CrDisambigStateName_desc" ,
                "Every state within a state machine must have a unique name. There are at least two states in this machine named \"<ocl>self</ocl>\".\n\nLa asignación de nombres claros e inequívocos es clave para la generación de código y el entendimiento y mantenibilidad del diseño. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente one of the conflicting states and use the \"Properties\" tab to change their names." },
        { "CrConflictingComposites_head" ,
                "Remove Conflicting Composite Associations" },
        { "CrConflictingComposites_desc" ,
                "A composite (black diamond) role of an association indicates that instances of that class contain instances of the associated classes. Since each instance can only be contained in one other object, each object can be the 'part' in at most one is-part-of relationship.\n\nGood OO design depends on building good is-part-of relationships.\n\nPara arreglar esto, use the \"Next>\" button, or manually change one association to have multiplicity to 0..1 or 1..1, or another kind of aggregation (e.g., a white diamond is less strict), or remove one of the associations" },
        { "CrTooManyAssoc_head" ,
                "Reduce Associations on <ocl>self</ocl>" },
        { "CrTooManyAssoc_desc" ,
                "There are too many Associations on class <ocl>self</ocl>.  Whenever one class becomes too central to the design it may become a maintenance bottleneck that must be updated frequently. \n\nDefining the associations between objects is an important part of your design. \n\nPara arreglar esto, pulsa el botón \"Next>\", or remove associations manually by clicking on an association in the navigator pane or diagram and presing the \"Del\" key. " },
        { "CrTooManyAttr_head" ,
                "Reduce Attributes on <ocl>self</ocl>" },
        { "CrTooManyAttr_desc" ,
                "There are too many Attributes on class <ocl>self</ocl>.  Whenever one class becomes too central to the design it may become a maintenance bottleneck that must be updated frequently. \n\nDefining the attributes of objects is an important part of your design. \n\nPara arreglar esto, pulsa el botón \"Next>\", or remove attributes manually by double-clicking on the attribute compartment of the  highlighted class in the diagram and removing the line of text for an attribute. " },
        { "CrTooManyOper_head" ,
                "Reduce Operations on <ocl>self</ocl>" },
        { "CrTooManyOper_desc" ,
                "There are too many Operations on class <ocl>self</ocl>.  Whenever one class becomes too central to the design it may become a maintenance bottleneck that must be updated frequently. \n\nDefining the operations of objects is an important part of your design. \n\nPara arreglar esto, pulsa el botón \"Next>\", or remove attributes manually by double-clicking on the operation compartment of the  highlighted class in the diagram and removing the line of text for an operation. " },
        { "CrTooManyStates_head" ,
                "Reduce States in machine <ocl>self</ocl>" },
        { "CrTooManyStates_desc" ,
                "There are too many States in <ocl>self</ocl>.  If one state machine has too many states it may become very difficult for humans to understand. \n\nDefining an understandable set of states is an important part of your design. \n\nPara arreglar esto, pulsa el botón \"Next>\", or remove states manually by clicking on a states in the navigator pane or diagram and presing the \"Del\" key.  Or you can nest states..." },
        { "CrTooManyTransitions_head" ,
                "Reduce Transitions on <ocl>self</ocl>" },
        { "CrTooManyTransitions_desc" ,
                "There are too many Transitions on state <ocl>self</ocl>.  Whenever one state becomes too central to the machine it may become a maintenance bottleneck that must be updated frequently. \n\nDefining the transitions between states is an important part of your design. \n\nPara arreglar esto, pulsa el botón \"Next>\", or remove transitions manually by clicking on a transition in the navigator pane or diagram and presing the \"Del\" key. " },
        { "CrTooManyClasses_head" ,
                "Reduce Classes in diagram <ocl>self</ocl>" },
        { "CrTooManyClasses_desc" ,
                "There are too many classes in <ocl>self</ocl>.  If one class diagram has too many classes it may become very difficult for humans to understand. \n\nDefining an understandable set of class diagrams is an important part of your design. \n\nPara arreglar esto, pulsa el botón \"Next>\", or remove classes manually by clicking on a class in the navigator pane or diagram and presing the \"Del\" key.  Or you can make a new diagram..." },
        { "CrNoTransitions_head" ,
                "Add Transitions to <ocl>self</ocl>" },
        { "CrNoTransitions_desc" ,
                "MState <ocl>self</ocl> has no Incoming or Outgoing transitions. Normally states have both incoming and outgoing transitions. \n\nDefining complete state transitions is needed to complete the behavioral specification part of your design.  \n\nPara arreglar esto, pulsa el botón \"Next>\", or add transitions manually by clicking on transition tool in the tool bar and dragging from another state to <ocl>self</ocl> or from <ocl>self</ocl> to another state. " },
        { "CrNoIncomingTransitions_head" ,
                "Add Incoming Transitions to <ocl>self</ocl>" },
        { "CrNoIncomingTransitions_desc" ,
                "MState <ocl>self</ocl> has no incoming transitions. Normally states have both incoming and outgoing transitions. \n\nDefining complete state transitions is needed to complete the behavioral specification part of your design. Without incoming transitions, this state can never be reached.\n\nPara arreglar esto, pulsa el botón \"Next>\", or add transitions manually by clicking on transition tool in the tool bar and dragging from another state to <ocl>self</ocl>. " },
        { "CrNoOutgoingTransitions_head" ,
                "Add Outgoing Transitions from <ocl>self</ocl>" },
        { "CrNoOutgoingTransitions_desc" ,
                "MState <ocl>self</ocl> has no Outgoing transitions. Normally states have both incoming and outgoing transitions. \n\nDefining complete state transitions is needed to complete the behavioral specification part of your design.  Without outgoing transitions, this state is a \"dead\" state that can naver be exited.\n\nPara arreglar esto, pulsa el botón \"Next>\", or add transitions manually by clicking on transition tool in the tool bar and dragging from another state to <ocl>self</ocl>. " },
        { "CrMultipleInitialStates_head" ,
                "Remove Extra Initial States" },
        { "CrMultipleInitialStates_desc" ,
                "There are multiple, ambiguous initial states in this machine. Normally each state machine or composite state has one initial state. \n\nDefining unabiguous states is needed to complete the behavioral specification part of your design.\n\nPara arreglar esto, pulsa el botón \"Next>\", or add manually select one of the extra initial states and remove it. " },
        { "CrNoInitialState_head" ,
                "Place an Initial MState" },
        { "CrNoInitialState_desc" ,
                "There is no initial state in this machine or composite state. Normally each state machine or composite state has one initial state. \n\nDefining unabiguous states is needed to complete the behavioral specification part of your design.\n\nPara arreglar esto, pulsa el botón \"Next>\", or add manually select initial state from the tool bar and place it in the diagram. " },
        { "CrNoTriggerOrGuard_head" ,
                "Add Trigger or Guard to Transistion" },
        { "CrNoTriggerOrGuard_desc" ,
                "The highlighted Transition is incomplete because it has no trigger or guard condition.  Triggers are events that cause a transition to be taken.  Guard conditions must be true for the transition to be taken.  If only a guard is used, the transition is taken when the condition becomes true.\n\nThis problem must be resolved to complete the state machine.\n\nPara arreglar esto, select the Transition and use the \"Properties\" tab, or select the Transition and type some text of the form:\nTRIGGER [GUARD] / ACTION\nWhere TRIGGER is an event name, GUARD is a boolean expression, and ACTION is an action to be performed when the MTransition is taken.  All three parts are optional." },
        { "CrNoGuard_head" ,
                "Add MGuard to Transistion" },
        { "CrNoGuard_desc" ,
                "The highlighted Transisition is incomplete because it has no guard condition.  MGuard conditions must be true for the transition to be taken.  If only a guard is used, the transition is taken when the condition becomes true.\n\nThis problem must be resolved to complete the state machine.\n\nPara arreglar esto, select the MTransition and use the \"Properties\" tab, or select the MTransition and type some text of the form:\n[GUARD]\nWhere GUARD is a boolean expression." },
        { "CrInvalidFork_head" ,
                "Change Fork Transitions" },
        { "CrInvalidFork_desc" ,
                "This fork state has an invalid number of transitions. Normally fork states have one incoming and two or more outgoing transitions. \n\nDefining correct state transitions is needed to complete the  behavioral specification part of your design.  \n\nPara arreglar esto, pulsa el botón \"Next>\", or remove transitions  manually by clicking on transition in the diagram and pressing the Delete key. " },
        { "CrInvalidJoin_head" ,
                "Change Join Transitions" },
        { "CrInvalidJoin_desc" ,
                "This join state has an invalid number of transitions. Normally join states have two or more incoming and one outgoing transitions. \n\nDefining correct state transitions is needed to complete the  behavioral specification part of your design.  \n\nPara arreglar esto, pulsa el botón \"Next>\", or remove transitions  manually by clicking on transition in the diagram and pressing the Delete key. " },
        { "CrInvalidBranch_head" ,
                "Change Branch Transitions" },
        { "CrInvalidBranch_desc" ,
                "This branch state has an invalid number of transitions. Normally branch states have one incoming and two or more outgoing transitions. \n\nDefining correct state transitions is needed to complete the  behavioral specification part of your design.  \n\nPara arreglar esto, pulsa el botón \"Next>\", or remove transitions  manually by clicking on transition in the diagram and pressing the Delete key, or add transitions using the transition tool. " },
        { "CrEmptyPackage_head" ,
                "Añade elementos al paquete <ocl>self</ocl>" },
        { "CrEmptyPackage_desc" ,
                "Aun no has puesto nada en el paquete <ocl>self</ocl>. Normalmente los paquetes contienen grupos de clases relacionadas.\n\nDefinir y usar paquetes es clave para un diseño mantenible. \n\nPara arreglar esto, selecciona el paquete <ocl>self</ocl> en el panel de navegación y añade los diagramas o modelos como clases o casos de uso. " },
        { "CrNoOperations_head" ,
                "Añade operaciones a <ocl>self</ocl>" },
        { "CrNoOperations_desc" ,
                "Aun no has especificado operaciones para <ocl>self</ocl>. Normalmente las clases proporcionan operaciones que definen su comportamiento. \n\nNecesitas definir operaciones para completar la parte de especificación de la conducta del diseño. \n\nPara arreglar esto, pulsa el botón \"Next>\", or add operations manually by clicking on <ocl>self</ocl> in the navigator pane and using the Create menu to make a new operations. " },
        { "CrConstructorNeeded_head" ,
                "Add Constructor to <ocl>self</ocl>" },
        { "CrConstructorNeeded_desc" ,
                "You have not yet defined a constructor for class <ocl>self</ocl>. Constructors initialize new instances such that their attributes have valid values.  This class probably needs a constructor because not all of its attributes have initial values. \n\nDefining good constructors is key to establishing class invariants, and class invariants are a powerful aid in writing solid code. \n\nPara arreglar esto, pulsa el botón \"Next>\", or add a constructor manually by clicking on <ocl>self</ocl> in the navigator pane and using the Create menu to make a new constructor. " },
        { "CrNameConfusion_head" ,
                "Revisa los nombres para evitar confusiones" },
        { "CrNameConfusion_desc" ,
                "Names should be clearly distinct from each other. These two names are so close to each other that readers might be confused.\n\nLa asignación de nombres claros e inequívocos es clave para la generación de código y el entendimiento y mantenibilidad del diseño. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente the elements y usa la solapa Propiedades para cambiar sus nombres.  Avoid names that differ from other names only in capitalization, or use of underscore characters, or by only one character." },
        { "CrMergeClasses_head" ,
                "Considera combinar las clases" },
        { "CrMergeClasses_desc" ,
                "The highlighted class, <ocl>self</ocl>, only participates in one association and that association is one-to-one with another class.  Since instances of these two classes must always be created together and destroyed together, combining these classes might simplify your design without loss of any representation power.  However, you may find the combined class too large and complex, in which case separating them is usually better.\n\nOrganizing classes to manage complexity of the design is always important, especially when the design is already complex. \n\nPara arreglar esto, click on the \"Next>\" button, or manually add the attribues and operations of the highlighted class to the other class, then remove the highlighted class from the project. " },
        { "CrSubclassReference_head" ,
                "Remove Reference to Specific Subclass" },
        { "CrSubclassReference_desc" ,
                "Class <ocl>self</ocl> has a reference to one of it's subclasses. Normally all subclasses should be treated \"equally\" by the superclass.  This allows for addition of new subclasses without modification to the superclass. \n\nDefining the associations between objects is an important part of your design.  Some patterns of associations are easier to maintain than others, depending on the natre of future changes. \n\nPara arreglar esto, pulsa el botón \"Next>\", or remove the association  manually by clicking on it in the diagram and pressing Delete. " },
        { "CrComponentWithoutNode_head" ,
                "Components normally are inside nodes" },
        { "CrComponentWithoutNode_desc" ,
                "There are nodes in the diagram. So you have got a real\n deployment-diagram, and in deployment-diagrams components\n normally resides on nodes." },
        { "CrCompInstanceWithoutNode_head" ,
                "ComponentInstances normally are inside nodes" },
        { "CrCompInstanceWithoutNode_desc" ,
                "There are node-instances in the Diagram. So you have got a real\n deployment-diagram, and in deployment-diagrams Component-instances\n normally resides on node-instances." },
        { "CrClassWithoutComponent_head" ,
                "Classes normally are inside components" },
        { "CrClassWithoutComponent_desc" ,
                " In Deployment-diagrams classes are normally inside components" },
        { "CrInterfaceWithoutComponent_head" ,
                "Interfaces normally are inside components" },
        { "CrInterfaceWithoutComponent_desc" ,
                " In Deployment-diagrams interfaces are normally inside components" },
        { "CrObjectWithoutComponent_head" ,
                "Objects normally are inside components" },
        { "CrObjectWithoutComponent_desc" ,
                " In Deployment-diagrams objects are normally inside components or component-instances" },
        { "CrNodeInsideElement_head" ,
                "Nodes normally have no enclosers" },
        { "CrNodeInsideElement_desc" ,
                " Nodes normally are not inside other Elements. They represent\n run-time physical objects with a processing resource, generally having\n at least a memory and often processing capability as well." },
        { "CrNodeInstanceInsideElement_head" ,
                "NodeInstances normally have no enclosers" },
        { "CrNodeInstanceInsideElement_desc" ,
                " NodeInstances normally are not inside other Elements. They represent\n run-time physical objects with a processing resource, generally having\n at least a memory and often processing capability as well." },
        { "CrWrongLinkEnds_head" ,
                "LinkEnds have not the same locations" },
        { "CrWrongLinkEnds_desc" ,
                " In deployment-diagrams objects can reside either on components\n or on component-instances. So it is not possible to have two objects\n connected with a Link, while one object resides on an component and\n an the other obejct on a component-instance.\n\n\n To fix this remove one object of the two connected objects from its location to an element that has the\n same type as the location of the other object" },
        { "CrInstanceWithoutClassifier_head" ,
                "Set classifier" },
        { "CrInstanceWithoutClassifier_desc" ,
                " Instances have a classifier" },
        { "CrCallWithoutReturn_head" ,
                "Missing return-actions" },
        { "CrCallWithoutReturn_desc" ,
                "Every call- or send-action requires a return-action,\n but this Link has no return-action.\n" },
        { "CrReturnWithoutCall_head" ,
                "Missing call(send)-action" },
        { "CrReturnWithoutCall_desc" ,
                "Every return-action requires a call- or send-action,\n but this Link has no corresponding call- or send-action.\n" },
        { "CrLinkWithoutStimulus_head" ,
                "No Stimuli on these links" },
        { "CrLinkWithoutStimulus_desc" ,
                "In sequence-diagrams a sender-object sends stimuli\nto a receiving object over a link. The link is only the communication-\nconnection, so a stimulus is needed." },
        { "CrSeqInstanceWithoutClassifier_head" ,
                "Set classifier" },
        { "CrSeqInstanceWithoutClassifier_desc" ,
                " Instances have a classifier" },
        { "CrStimulusWithWrongPosition_head" ,
                "Wrong position of these stimuli" },
        { "CrStimulusWithWrongPosition_desc" ,
                "In sequence-diagrams the sender-side oh the communication-connections oh these\nstimuli are connected at the beginning of an activation. To be a sender an object must\nhave a focus-of-control first." },
        { "CrUnconventionalOperName_head" ,
                "Choose a Better MOperation Name" },
        { "CrUnconventionalOperName_desc" ,
                "Normally operation names begin with a lowercase letter. The name '<ocl>self</ocl>' is unconventional because it does not.\n\nFollowing good naming conventions help to improve the understandability and maintainability of the design. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente <ocl>self</ocl> y usa la solapa Propiedades para give it a new name." },
        { "CrUnconventionalAttrName_head" ,
                "Choose a Better MAttribute Name" },
        { "CrUnconventionalAttrName_desc" ,
                "Normally attributes begin with a lowercase letter. The name '<ocl>self</ocl>' is unconventional because it does not.\n\nFollowing good naming conventions help to improve the understandability and maintainability of the design. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente <ocl>self</ocl> y usa la solapa Propiedades para give it a name." },
        { "CrUnconventionalClassName_head" ,
                "Capitalize Class Name <ocl>self</ocl>" },
        { "CrUnconventionalClassName_desc" ,
                "Normally classes begin with a capital letter. The name '<ocl>self</ocl>' is unconventional because it does not begin with a capital.\n\nFollowing good naming conventions help to improve the understandability and maintainability of the design. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente <ocl>self</ocl> y usa la solapa Propiedades para asignarle un nombre diferente." },
        { "CrUnconventionalPackName_head" ,
                "Revisa el nombre del paquete <ocl>self</ocl>" },
        { "CrUnconventionalPackName_desc" ,
                "Normalmente los nombres de paquetes estan escritos en minúsculas con puntos para indicar paquetes \"anidados\".  El nombre '<ocl>self</ocl>' no es aconsejable porque no esta formado por minúsculas y puntos.\n\nSeguir las convenciones para asignar nombres ayuda a entender y mantener el diseño. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente <ocl>self</ocl> y usa la solapa Propiedades para asignarle un nombre diferente." },
        { "CrClassMustBeAbstract_head" ,
                "Class Must be Abstract" },
        { "CrClassMustBeAbstract_desc" ,
                "Classes that include or inherit abstract methods from base classes or interfaces must be marked Abstract.\n\nDeciding which classes are abstract or concrete is a key part of class hierarchy design.\n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente the class y usa la solapa Propiedades para add the Abstract keyword, or manually override each abstract operation that is inherited from a base class or interface." },
        { "CrReservedName_head" ,
                "Change <ocl>self</ocl> to a Non-Reserved Word" },
        { "CrReservedName_desc" ,
                "\"<ocl>self</ocl>\" is a reserver word or very close to one.  The names of model elements must not conflict with reserved words of programming languages or UML.\n\nUsing legal names is needed to generate compilable code. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente the highlighted element y usa la solapa Propiedades para give it un nombre diferente." },
        { "CrMultipleInheritance_head" ,
                "Change Multiple Inheritance to Interfaces" },
        { "CrMultipleInheritance_desc" ,
                "<ocl>self</ocl> has multiple base classes, but Java does not support multiple inheritance.  You must use interfaces instead. \n\nThis change is required before you can generate Java code.\n\nPara arreglar esto, use the \"Next>\" button, or manually (1) remove one of the base classes and then (2) optionally define a new interface with the same method declarations and (3) add it as an interface of <ocl>self</ocl>, and (4) move the method bodies from the old base class down into <ocl>self</ocl>." },
        { "CrIllegalName_head" ,
                "Choose a Legal Name" },
        { "CrIllegalName_desc" ,
                "The names of model elements must be sequences of letters, numbers, and underscores.  They cannot contain punctuation.\n\nCode generation requires legal names for the resulting code to compile correctly. \n\nPara arreglar esto, usa el botón \"Next>\", o selecciona manualmente the highlighted element y usa la solapa Propiedades para give it un nombre diferente." },
        { "CrConsiderSingleton_head" ,
                "Considera el uso del patrón Singelton" },
        { "CrConsiderSingleton_desc" ,
                "Esta clase no tiene atributos ni asociaciones que sean navegables fuera de la instancias de esta clase.  Esto significa que cada instancia de esta clase sera igual a cualquier otra debido a que no habrá variables de instancia para diferenciarlas. If this not your intent, you should define some attributes or associations that will represent differences bewteen instances. If there are no attributes or associations that differentiate instances, the you shoudld consider having exatly one instance of this class, as in the Singleton Pattern.\n\nDefining the multiplicity of instances is needed to complete the information representation part of your design.  Using the Singleton Pattern can save time and memory space.\n\nTo automatically apply the Singleton Pattern, pulsa el botón \"Next>\"; or manually (1) mark the class with the Singlton stereotype, (2) add a static variable that holds one instance of this class, (3) and make all constructors private.\n\nTo learn more about the Singleton Pattern, press the MoreInfo icon." },
        { "CrSingletonViolated_head" ,
                "Singleton MStereotype Violated" },
        { "CrSingletonViolated_desc" ,
                "This class is marked with the Singleton stereotype, but it does not satisfy the constraints imposed on singletons.  A singleton class can have at most one instance.  This means that the class must have (1) a static variable holding the instance, (2) only private constructors so that new instances cannot be made by other code, and (3) there must be at least one constructor to override the default constructor.\n\nWhenever you mark a class with a stereotype, the class should satisfy all constraints of the stereotype.  This is an important part of making a self-consistent and understangle design. Using the Singleton Pattern can save time and memory space.\n\nIf you no longer want this class to be a Singleton, remove the Singleton stereotype by clicking on the class and deleting Singleton from the Props tab. \nTo automatically apply the Singleton Pattern, pulsa el botón \"Next>\"; or manually (1) mark the class with the Singlton stereotype, (2) add a static variable that holds one instance of this class, (3) and make all constructors private.\n\nTo learn more about the Singleton Pattern, press the MoreInfo icon." },
        { "CrNodesOverlap_head" ,
                "Clean Up Diagram" },
        { "CrNodesOverlap_desc" ,
                "Some of the objects in this diagram overlap and obscure each other. This may hide important information and make it difficult for humans to understand. A neat appearance may also make your diagrams more influencial on other designers, implementors, and decision makers.\n\nConstructing an understandable set of class diagrams is an important part of your design. \n\nPara arreglar esto, move the highlighted nodes in the digragm." },
        { "CrZeroLengthEdge_head" ,
                "Make Edge More Visible" },
        { "CrZeroLengthEdge_desc" ,
                "This edge is too small to see easily. This may hide important information and make it difficult for humans to understand. A neat appearance may also make your diagrams more influencial on other designers, implementors, and decision makers.\n\nConstructing an understandable set of diagrams is an important part of your design. \n\nPara arreglar esto, move one or more nodes so that the highlighted edges will be longer, or click in the center of the edge and drag to make a new vertex." },
        //
        //   these phrases should be localized here
        //      not in the following check list section
        { "Naming", "Nombres" },
        { "Encoding", "Codificación" },
        { "Value", "Valor" },
        { "Location", "Posición" },
        { "Updates", "Actualizaciones" },
        { "General", "General" },
        { "Actions" , "Acciones" },
        { "Transitions", "Transiciones" },
        { "Structure", "Estructura" },
        { "Trigger", "Disparador" },
        { "MGuard", "MGuard" },
        //
        //   The following blocks define the UML related
        //      Checklists.  The key is the name of
        //      the non-deprecated implmenting class,
        //      the value is an array of categories which
        //      are each an array of Strings.  The first
        //      string in each category is the name of the
        //      category and should not be localized here
        //      but should be in the immediate preceeding
        //      section
        //
        { "ChClass",
            new String[][] {
                new String[] { "Naming",
                  "¿Describe claramente la clase el nombre '<ocl>self</ocl>'?",
                  "¿Es '<ocl>self</ocl>' un nombre o una sintagma nominal?",
                  "¿Podría malinterpretarse el significado de '<ocl>self</ocl>'?"
                },
                new String[] { "Encoding",
                  "¿Debería <ocl>self</ocl> estar en su propia clase o ser un atributo de otra?",
                  "¿Hace <ocl>self</ocl> exactamente una sola cosa y la hace bien?",
                  "¿Podría <ocl>self</ocl> ser dividido en dos o más clases?"
                },
                new String[] { "Value",
                  "¿Comienzan todos los atributos de <ocl>self</ocl> con valores significativos?",
                  "¿Podrías escribir un invariante para esta clase?",
                  "¿Establecen la invariante de la clase todos los constructores?",
                  "¿Mantienen la invariante de la clase todas las operaciones?"
                },
                new String[] { "Location",
                  "¿Podría <ocl>self</ocl> estar definida en una posición diferente de esta jerarquía de clases?",
                  "¿Planeas crear subclases de <ocl>self</ocl>?",
                  "¿Podrías eliminar del modelo a <ocl>self</ocl>?",
                  "¿Hay alguna otra clase en el modelo que deba ser revisada o eliminada porque sirve al mismo proposito que <ocl>self</ocl>?"
                },
                new String[] { "Updates",
                  "For what reasons will an instance of <ocl>self</ocl> be updated?",
                  "Is there some other object that must be updated whenever <ocl>self</ocl> is updated?"
                }
            }
        },
        { "ChAttribute",
            new String[][] {
                new String[] { "Naming",
                  "¿El nombre '<ocl>self</ocl>' describe claramente el atributo?",
                  "¿Es '<ocl>self</ocl>' un nombre o un sintagma nominal?",
                  "¿Podría malinterpretarse el significado de '<ocl>self</ocl>'?"
                },
                new String[] { "Encoding",
                  "¿Es el tipo <ocl>self.type</ocl> demasiado restrictivo para representar todos los posibles valores de <ocl>self</ocl>?",
                  "Does the type <ocl>self.type</ocl> allow values for <ocl>self</ocl> that could never be correct?",
                  "Could <ocl>self</ocl> be combined with some other attribute of <ocl>self.owner</ocl> (e.g., {owner.structuralFeature})?",
                  "¿Podría descomponerse <ocl>self</ocl> en dos o más partes (por ejemplo, un número de telefono puede descomponerse en un prefijo y un número)?",
                  "Could <ocl>self</ocl> be computed from other attributes instead of stored?"
                },
                new String[] { "Value",
                  "Should <ocl>self</ocl> have an initial (or default) value?",
                  "Is the initial value <ocl>self.initialValue</ocl> correct?",
                  "Could you write an expression to check if <ocl>self</ocl> is correct? Plausible?"
                },
                new String[] { "Location",
                  "Could <ocl>self</ocl> be defined in a different class that is associated with <ocl>self.owner</ocl>?",
                  "Could <ocl>self</ocl> be moved up the inheritance hierarchy to apply to owner.name and to other classes?",
                  "Does <ocl>self</ocl> apply to all instances of class <ocl>self.owner</ocl> including instances of subclasses?",
                  "¿Podrías eliminar del modelo a <ocl>self</ocl>?",
                  "Is there another attribute in the model that should be revised or eliminated because it serves the same purpose as <ocl>self</ocl>?"
                },
                new String[] { "Updates",
                  "For what reasons will <ocl>self</ocl> be updated?",
                  "Is there some other attribute that must be updated whenever <ocl>self</ocl> is updated?",
                  "Is there a method that should be called when <ocl>self</ocl> is updated?",
                  "Is there a method that should be called when <ocl>self</ocl> is given a certain kind of value?"
                }
            }
        },
        { "ChOperation",
            new String[][] {
                new String[] { "Naming",
                  "¿Describe claramente la operación el nombre '<ocl>self</ocl>'?",
                  "'<ocl>self</ocl>' ¿es un verbo o una frase?",
                  "¿Podría malinterpretarse el significado de '<ocl>self</ocl>'?",
                  "Does <ocl>self</ocl> do one thing and do it well?"
                },
                new String[] { "Encoding",
                  "Is the return type '<ocl>self.returnType</ocl>' too restrictive to represent all possible values returned by <ocl>self</ocl>?",
                  "Does '<ocl>self.returnType</ocl>' allow return values that could never be correct?",
                  "Could <ocl>self</ocl> be combined with some other operation of <ocl>self.owner</ocl> (e.g., <ocl sep=', '>self.owner.behavioralFeature</ocl>)?",
                  "¿Podría dividirse <ocl>self</ocl> en dos o más parts (e.g., pre-process, main processing, and post-processing)?",
                  "Could <ocl>self</ocl> be replaced by a series of client calls to simpler operations?",
                  "Could <ocl>self</ocl> be combined with other operations to reduce the number of calls clients must make?"
                },
                new String[] { "Value",
                  "Can <ocl>self</ocl> handle all possible inputs?",
                  "Are there special case inputs that must be handled separately?",
                  "Could you write an expression to check if the arguments to <ocl>self</ocl> are correct? Plausible?",
                  "Can you express the preconditions of <ocl>self</ocl>?",
                  "Can you express the postconditions of <ocl>self</ocl>?",
                  "How will <ocl>self</ocl> behave if preconditions are violated?",
                  "How will <ocl>self</ocl> behave if postconditions cannot be achieved?"
                },
                new String[] { "Location",
                  "Could <ocl>self</ocl> be defined in a different class that is associated with <ocl>self.owner</ocl>?",
                  "Could <ocl>self</ocl> be moved up the inheritance hierarchy to apply to <ocl>self.owner</ocl> and to other classes?",
                  "Does <ocl>self</ocl> apply to all instances of class <ocl>self.owner</ocl> including instances of subclasses?",
                  "¿Podrías eliminar del modelo a <ocl>self</ocl>?",
                  "Is there another operation in the model that should be revised or eliminated because it serves the same purpose as <ocl>self</ocl>?"
                }
            }
        },
        { "ChAssociation",
            new String[][] {
                new String[] { "Naming",
                  "¿El nombre '<ocl>self</ocl>' describe claramente la clase?",
                  "¿Es '<ocl>self</ocl>' un nombre o un sintagma nominal?",
                  "¿Podría malinterpretarse el significado de '<ocl>self</ocl>'?"
                },
                new String[] { "Encoding",
                  "¿Debería <ocl>self</ocl> estar en su propia clase o ser solo un atributo de una clase?",
                  "¿Hace <ocl>self</ocl> exactamente una sola cosa y la hace bien?",
                  "¿Podría dividirse <ocl>self</ocl> en dos o más classes?"
                },
                new String[] { "Value",
                  "Comienzan todos los atributos de <ocl>self</ocl> con valores significativos?",
                  "¿Podrías escribir un invariante para esta clase?",
                  "¿Establecen la invariante de la clase todos los constructores?",
                  "¿Mantienen la invariante de la clase todas las operaciones?"
                },
                new String[] { "Location",
                  "¿Podría <ocl>self</ocl> estar definida en una posición diferente de esta jerarquía de clases?",
                  "¿Planeas crear subclases de <ocl>self</ocl>?",
                  "¿Podrías eliminar del modelo a <ocl>self</ocl>?",
                  "Hay alguna otra clase en el modelo que seba ser revisada o eliminada porque sirva al mismo proposito que <ocl>self</ocl>?"
                },
                new String[] { "Updates",
                  "¿Porque motivos debería ser actualizada una instancia de <ocl>self</ocl>?",
                  "¿Hay algun otro objeto que deba ser actualizado cuando <ocl>self</ocl> es actualizado?"
                }
            }
        },
        { "ChInterface",
            new String[][] {
                new String[] { "Naming",
                  "¿El nombre '<ocl>self</ocl>' describe claramente la clase?",
                  "¿Es '<ocl>self</ocl>' un nombre o un sintagma nominal?",
                  "¿Podría malinterpretarse el significado de '<ocl>self</ocl>'?"
                },
                new String[] { "Encoding",
                  "¿Debería <ocl>self</ocl> estar en su propia clase o ser solo un atributo de una clase?",
                  "¿Hace <ocl>self</ocl> exactamente una sola cosa y la hace bien?",
                  "¿Podría dividirse <ocl>self</ocl> en dos o más classes?"
                },
                new String[] { "Value",
                  "¿Comienzan todos los atributos de <ocl>self</ocl> con valores significativos?",
                  "¿Podrías escribir un invariante para esta clase?",
                  "¿Establecen la invariante de la clase todos los constructores?",
                  "¿Mantienen la invariante de la clase todas las operaciones?"
                },
                new String[] { "Location",
                  "¿Podría <ocl>self</ocl> estar definida en una posición diferente de esta jerarquía de clases?",
                  "¿Has planeado crear subclases de <ocl>self</ocl>?",
                  "¿Podrías eliminar del modelo a <ocl>self</ocl>?",
                  "¿Hay otra clase en el modelo que debería ser revisada o eliminada porque sirve al mismo proposito que <ocl>self</ocl>?"
                },
                new String[] { "Updates",
                  "¿Porque motivos sera actualizada la instancia de <ocl>self</ocl>?",
                  "¿Hay algun otro objeto que deba ser actualizado cuando <ocl>self</ocl> es actualizado?"
                }
            }
        },
        { "ChInstance",
            new String[][] {
                new String[] { "General",
                  "¿Describe esta instancia de <ocl>self</ocl> la instancia?"
                },
                new String[] { "Naming",
                  "¿El nombre '<ocl>self</ocl>' describe claramente la instancia?",
                  "¿'<ocl>self</ocl>' denota un estado en vez de una actividad?",
                  "¿Podría malinterpretarse el significado de '<ocl>self</ocl>'?"
                },
                new String[] { "Structure",
                  "Should <ocl>self</ocl> be its own state or could it be merged with another state?",
                  "¿Hace <ocl>self</ocl> exactamente una sola cosa y la hace bien?",
                  "¿Podría dividirse <ocl>self</ocl> en dos o más states?",
                  "¿Podrías escribir una ecuación característica para <ocl>self</ocl>?",
                  "¿<ocl>self</ocl> pertenece a esta máquina de estados o a otra?",
                  "¿Debería <ocl>self</ocl> ser un estado inicial?",
                  "Is some state in another machine exclusive with <ocl>self</ocl>?"
                },
                new String[] { "Actions",
                  "What action should be preformed on entry into <ocl>self</ocl>?",
                  "Should some attribute be updated on entry into <ocl>self</ocl>?",
                  "What action should be preformed on exit from <ocl>self</ocl>?",
                  "Should some attribute be updated on exit from <ocl>self</ocl>?",
                  "What action should be preformed while in <ocl>self</ocl>?",
                  "Do state-actions maintain <ocl>self</ocl> as the current state?"
                },
                new String[] { "Transitions",
                  "Should there be another transition into <ocl>self</ocl>?",
                  "Can all the transitions into <ocl>self</ocl> be used?",
                  "Could some incoming transitions be combined?",
                  "Should there be another transition out of <ocl>self</ocl>?",
                  "Can all the transitions out of <ocl>self</ocl> be used?",
                  "Is each outgoing transition exclusive?",
                  "Could some outgoing transitions be combined?"
                }
            }
        },
        { "ChLink",
            new String[][] {
                new String[] { "Naming",
                  "¿El nombre '<ocl>self</ocl>' describe claramente la clase?",
                  "¿Es '<ocl>self</ocl>' un nombre o un sintagma nominal?",
                  "¿Podría malinterpretarse el significado de '<ocl>self</ocl>'?"
                },
                new String[] { "Encoding",
                  "¿Debería <ocl>self</ocl> estar en su propia clase o ser solo un atributo de una clase?",
                  "¿Hace <ocl>self</ocl> exactamente una sola cosa y la hace bien?",
                  "¿Podría dividirse <ocl>self</ocl> en dos o más classes?"
                },
                new String[] { "Value",
                  "Comienzan todos los atributos de <ocl>self</ocl> con valores significativos?",
                  "¿Podrías escribir un invariante para esta clase?",
                  "¿Establecen la invariante de la clase todos los constructores?",
                  "¿Mantienen la invariante de la clase todas las operaciones?"
                },
                new String[] { "Location",
                  "¿Podría <ocl>self</ocl> estar definida en una posición diferente de esta jerarquía de clases?",
                  "Have you planned to have subclasses of <ocl>self</ocl>?",
                  "¿Podrías eliminar del modelo a <ocl>self</ocl>?",
                  "Hay alguna otra clase en el modelo que seba ser revisada o eliminada porque sirva al mismo proposito que <ocl>self</ocl>?"
                },
                new String[] { "Updates",
                  "For what reasons will an instance of <ocl>self</ocl> be updated?",
                  "Is there some other object that must be updated whenever <ocl>self</ocl> is updated?"
                }
            }
        },
        { "ChState",
            new String[][] {
                new String[] { "Naming",
                  "Does the name '<ocl>self</ocl>' clearly describe the state?",
                  "Does '<ocl>self</ocl>' denote a state rather than an activity?",
                  "¿Podría malinterpretarse el significado de '<ocl>self</ocl>'?"
                },
                new String[] { "Structure",
                  "Should <ocl>self</ocl> be its own state or could it be merged with another state?",
                  "¿Hace <ocl>self</ocl> exactamente una sola cosa y la hace bien?",
                  "¿Podría dividirse <ocl>self</ocl> en dos o más states?",
                  "Could you write a characteristic equation for <ocl>self</ocl>?",
                  "Does <ocl>self</ocl> belong in this state machine or another?",
                  "Should <ocl>self</ocl> be be an initial state?",
                  "Is some state in another machine exclusive with <ocl>self</ocl>?"
                },
                new String[] { "Actions",
                  "What action should be preformed on entry into <ocl>self</ocl>?",
                  "Should some attribute be updated on entry into <ocl>self</ocl>?",
                  "What action should be preformed on exit from <ocl>self</ocl>?",
                  "Should some attribute be updated on exit from <ocl>self</ocl>?",
                  "What action should be preformed while in <ocl>self</ocl>?",
                  "Do state-actions maintain <ocl>self</ocl> as the current state?"
                },
                new String[] { "Transitions",
                  "Should there be another transition into <ocl>self</ocl>?",
                  "Can all the transitions into <ocl>self</ocl> be used?",
                  "Could some incoming transitions be combined?",
                  "Should there be another transition out of <ocl>self</ocl>?",
                  "Can all the transitions out of <ocl>self</ocl> be used?",
                  "Is each outgoing transition exclusive?",
                  "Could some outgoing transitions be combined?"
                }
            }
        },
        { "ChTransition",
            new String[][] {
                new String[] { "Structure",
                  "Should this transition start at a different source?",
                  "Should this transition end at a different destination?",
                  "Should there be another transition \"like\" this one?",
                  "Is another transition unneeded because of this one?"
                },
                new String[] { "Trigger",
                  "¿Necesita un disparador esta transición?",
                  "¿Ocurre muy a menudo este disparador?",
                  "¿Ocurre muy raramente este disparador?"
                },
                new String[] { "MGuard",
                  "Could this transition be taken too often?",
                  "Is this transition's condition too restrictive?",
                  "Could it be broken down into two or more transitions?"
                },
                new String[] { "Actions",
                  "¿Debería tener una acción esta transición?",
                  "¿Debería ser una acción exit la acción de esta transición?",
                  "¿Debería ser una acción entry la acción de esta transición?",
                  "¿Se alcanza siempre la precondición de esta acción?",
                  "¿Es consistente la postcondición de esta acción con el destino?"
                }
            }
        },
        { "ChUseCase",
            new String[][] {
                new String[] { "Naming",
                  "¿El nombre '<ocl>self</ocl>' describe claramente la clase?",
                  "¿Es '<ocl>self</ocl>' un nombre o una sintagma nominal?",
                  "¿Podría malinterpretarse el significado de '<ocl>self</ocl>'?"
                },
                new String[] { "Encoding",
                  "¿Debería <ocl>self</ocl> estar en su propia clase o ser solo un atributo de una clase?",
                  "¿Hace <ocl>self</ocl> exactamente una sola cosa y la hace bien?",
                  "¿Podría dividirse <ocl>self</ocl> en dos o más classes?"
                },
                new String[] { "Value",
                  "¿Comienzan con nombres significativos todos los atributos de <ocl>self</ocl>?",
                  "¿Podrías escribir un invariante para esta clase?",
                  "¿Establecen la invariante de la clase todos los constructores?",
                  "¿Mantienen la invariante de la clase todas las operaciones?"
                },
                new String[] { "Location",
                  "¿Podría <ocl>self</ocl> estar definida en una posición diferente de esta jerarquía de clases?",
                  "¿Planeas crear subclases de <ocl>self</ocl>?",
                  "¿Podrías eliminar del modelo a <ocl>self</ocl>?",
                  "¿Existe alguna otra clase en el modelo que deba ser revisada o eliminada porque sirve al mismo proposito que <ocl>self</ocl>?"
                },
                new String[] { "Updates",
                  "¿Porque razones sera actualizada una instancia de <ocl>self</ocl>?",
                  "Hay algun otro objeto que deba ser actualizado cuando <ocl>self</ocl> es actualizado?"
                }
            }
        },
        { "ChActor",
            new String[][] {
                new String[] { "Naming",
                  "¿Describe claramente la clase el nombre '<ocl>self</ocl>'?",
                  "¿'<ocl>self</ocl>' es un nombre o una sintagma nominal?",
                  "¿Podría ser malinterpretado el significado del nombre '<ocl>self</ocl>'?"
                },
                new String[] { "Encoding",
                  "Debería haber una clase propia para <ocl>self</ocl> o ser un atributo simple de otra clase?",
                  "¿Hace <ocl>self</ocl> una sola cosa y la hace bien?",
                  "Podría dividirse <ocl>self</ocl> en dos o más clases?"
                },
                new String[] { "Value",
                  "¿Comienzan todos los atributos de <ocl>self</ocl> con valores significativos?",
                  "¿Podrías escribir un invariante para esta clase?",
                  "¿Establecen la invariante de la clase todos los constructores?",
                  "¿Mantienen la invariante de la clase todas las operaciones?"
                },
                new String[] { "Location",
                  "¿Podría <ocl>self</ocl> estar definida en un lugar diferente de esta jerarquía de clases?",
                  "¿Tienes planeado subclasificar <ocl>self</ocl>?",
                  "¿Podrías eliminar <ocl>self</ocl> del modelo?",
                  "Hay alguna otra clase del modelo que debería ser revisada o eliminada porque sirve al mismo proposito que <ocl>self</ocl>?"
                },
                new String[] { "Updates",
                  "¿Porque motivos una instancia de <ocl>self</ocl> es actualizada?",
                  "Hay algun otro objeto que deba ser actualizado cuando <ocl>self</ocl> es actualizado?"
                }
            }
        }
    };

    public Object[][] getContents() {
        return _contents;
    }
}
