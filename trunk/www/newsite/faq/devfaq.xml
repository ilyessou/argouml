<?xml version="1.0"?>
<?xml-stylesheet href="../common.xsl" type="text/xsl"?>

<page lmod="2001-03-11" title="ArgoUML">
 <topnavbar lmod="2001-05-04" title="ArgoUML Developer FAQ">
  <navbaritem name="home">
    index.html
  </navbaritem>
  <navbaritem name="resources">
    resources/index.html
  </navbaritem>
 </topnavbar>

 <section title="Developer FAQ">

  <para>
  ArgoUML is an open source project, so it depends on
  people that volunteer to work on it. Especially in the
  area of development there is still so much to do!
  Everyone who wants to contribute needs to know the
  what, where and how to write good quality code, but
  getting into it is a big challenge since there are
  hundreds of Java files. This developer FAQ is dedicated
  to all interested programmers and should help to transfer
  the knowledge from the old experts to them. Please
  feel free to send more questions and/or answers to the
  <a href="mailto:dev@argouml.tigris.org">dev mailing list</a>!
  </para>

 <subsection title="Prerequisite stuff">

  <subsubsection title="Which tools do I need to build ArgoUML?">
   <ul>
     <li>CVS for obtaining the latest files via internet</li>
     <li>ANT, the Java make tool to manage compiling and packaging</li>
     <li>JDK, at least version 1.2.2 (includes the java compiler)</li>
     <li>libs: nsuml.jar, ocl-argo.jar, gef.jar, antlrall.jar</li>
   </ul>
   <para>
   The four libs can be found on this site. If ncot directly,
   then in the latest (unstable) distribution. In the future, they
   might be available through CVS, too, which would make your life
   much easier. For compiling/building, a simple 'build package'
   should be sufficient.
   </para>
  </subsubsection>
  <subsubsection title="Compiling failed. Any suggestions?">
   <para>
   Most compiling problems arise from wrong versions: maybe ANT
   or JDK, but most often one of the four libs. A look on the error
   messages can help. Get the appropriate version (or, e.g. in the
   case of gef.jar, get the sources through CVS and build it on
   your own). Another reason for problems is an unclean local
   source tree: if yours is in doubt, remove it completely and
   get it all again through CVS. If nothing helps, ask the
   <a href="mailto:dev@argouml.tigris.org">experts</a>!
   </para>
  </subsubsection>

 </subsection>

 <subsection title="Argo Initialization">

  <subsubsection title="Which sources are involved?">
  <para>
  Relative to the directory org/argouml, they are mainly:
  </para>
  <ul>
    <li>application/Main.java,</li>
    <li>kernel/Project.java + xml/argo/ArgoParser.java,</li>
    <li>ui/{ProjectBrowser.java,*Pane.java},</li>
    <li>cognitive/{Designer.java,ui/ToDoPane.java}.</li>
  </ul>
  </subsubsection>
  <subsubsection title="What is loaded/initialized?">
  <para>
  It all begins in org.argouml.application.Main: set up
  main application frame (org.argouml.ui.ProjectBrowser), the
  project (org.argouml.kernel.Project), numerous classes, and
  finally as a background thread: cognitive support
  (org.argouml.cognitive.Designer) and some more classes.
  </para>
  <para>
  The ProjectBrowser initializes the menu, toolbar, status bar
  and the four main areas:
  navigation pane (org.argouml.ui.NavigatorPane),
  editor pane (org.argouml.ui.MultiEditorPane),
  to do pane (org.argouml.cognitive.ui.ToDoPane), and
  details pane (org.argouml.ui.DetailsPane). Then, the actual
  project is set to either a read from file project
  (see ArgoParser.SINGLETON.readProject(URL) and
  ArgoParser.SINGLETON.getProject() in org.argouml.xml.argo.ArgoParser)
  or a newly generated project (see Project.makeEmptyProject()).
  </para>
  </subsubsection>

 </subsection>

 <subsection title="Runtime Issues">

  <subsubsection title="Which Objects live during a typical session?">
  <para>
  (Project, Designer, Globals, NavPane, ToDoPane, ...)
  </para>
  </subsubsection>
  <subsubsection title="What is their task?">
  <para>
  (visual component, model, controller, ...)
  </para>
  </subsubsection>
  <subsubsection title="How about memory organization, e.g. cleanup?">
  <para>
  </para>
  </subsubsection>

 </subsection>

 <subsection title="Working with Projects">

  <subsubsection title="How is a project represented/stored/loaded?">
  <para>
  </para>
  </subsubsection>
  <subsubsection title="Which sources are involved?">
  <para>
  </para>
  </subsubsection>
  <subsubsection title="What happens when something is added/removed/modified?">
  <para>
  (in the model and/or the diagram)
  </para>
  </subsubsection>

 </subsection>

 <subsection title="Cognitive Support">

  <subsubsection title="Which sources are involved?">
  <para>
  </para>
  </subsubsection>
  <subsubsection title="How do Critics/Checklists work?">
  <para>
  </para>
  </subsubsection>
  <subsubsection title="How are changes recognized?">
  <para>
  </para>
  </subsubsection>
  <subsubsection title="How is the connection to the model/diagrams?">
  <para>
  </para>
  </subsubsection>

 </subsection>

 <subsection title="Code Generation">

  <subsubsection title="Which sources are involved?">
  <para>
  </para>
  </subsubsection>
  <subsubsection title="How does it work?">
  <para>
  </para>
  </subsubsection>
  <subsubsection title="What in the model is (not) considered?">
  <para>
  </para>
  </subsubsection>
  <subsubsection title="How is Java/C++ specific stuff handled?">
  <para>
  </para>
  </subsubsection>

 </subsection>

 <subsection title="Reverse Engineering">

  <subsubsection title="Which sources are involved?">
  <para>
  The package org.argouml.uml.reveng is supposed to hold those classes
  that are common to all RE packages. At the moment this is the Import
  class which is mainly responsible to recognize directories, get their
  content and parse every known source file in them. These are only java
  files at them moment, but there might be other languages like C++ in
  the future. With this concept you could mix several languages within
  a project. The DiagramInterface is used to visualize generated NSUML
  metamodel objects then.
  </para>
  <para>
  The package org.argouml.uml.reveng.java holds the Java specific parts
  of the current RE code. C++ RE might go to org.argouml.uml.reveng.cc,
  or so...
  </para>
  </subsubsection>
  <subsubsection title="How is the grammar of the target language implemented?">
  <para>
  It's a Antlr (<a href="http://www.antlr.org" target="_blank">
  http://www.antlr.org</a>) grammar, based on the Antlr Java parser
  example. The main difference is the missing AST (Abstract Syntax Tree)
  generation and treeparser. So the original example generates a AST
  (a treelike data structure) and then traverses this tree, while the
  ArgoUML code parses the source file and generates NSUML objects
  directly from the sources. This was done to avoid the memory usage
  of an AST and the frequent GC while parsing many source files.
  </para>
  </subsubsection>
  <subsubsection title="Which model/diagramm elements are generated?">
  <para>
  The *context classes hold the current context for a package, class
  etc. When the required information for a object is available, the
  corresponding NSUML object is created and passed to the DiagramInterface
  to visualize it.
  </para>
  </subsubsection>
  <subsubsection title="Which layout algorithm is used?">
  <para>
  The classes in org.argouml.uml.diagram.static_structure.layout.* hold
  the Classdiagram layout code. No layout for other diagram types yet.
  It's based on a ranking scheme for classes and interfaces. The rank of
  a class/interface depends on the total number of (direct or indirect)
  superclasses. So if class B extends A (with rank(A)=0), then rank(B)=1.
  If C extends B, then rank(C)=2 since it has 2 superclasses A,B. An
  implemented interface is treated similar to a extended class. The
  objects are placed in rows then, that depend on their rank.
  rank(0)=1st row. rank(1) =2nd row (below the 1st one) etc. Example:
  </para>
  <ul>
  <img src="./images/example1.gif"></img>
  </ul>
  <para>
  In the next diagramm, a link goes to a object that is not in the row
  above:
  </para>
  <ul>
  <img src="./images/example2.gif"></img>
  </ul>
  <para>
  In this case, insert virtual objects which are linked to the actual
  target and link to them:
  </para>
  <ul>
  <img src="./images/example3.gif"></img>
  </ul>
  <para>
  The object are sorted within their row then to minimize crossing links
  then. Compute the average value of the vertical positions of all linked
  object in the row above. Example: we have 2 ranks 0 and 1 with 3
  classes each:
  </para>
  <ul>
  <p>A B C : rank 0</p>
  <p>D E F : rank 1</p>
  </ul>
  <para>
  We give the superclasses an index in their rank (assuming that they are
  already sorted):
  </para>
  <ul>
  A:0, B:1, C:2
  </ul>
  <para>
  D, E, F have the following links (A, B, C could be interfaces, so I allow
  links to multiple superclasses here):
  </para>
  <ul>
  <p>D -> C</p>
  <p>E -> A and C</p>
  <p>F -> A and B</p>
  </ul>
  <para>
  Compute the average value of the indexes:
  </para>
  <ul>
  <p>D = 2 (C has index 2 / 1 link)</p>
  <p>E = 0 + 2 / 2 = 1 (A=0, C=2 divide by 2 links)</p>
  <p>F = 0 + 1 / 2 = 0.5 (A=0, B=1, 2 links)</p>
  </ul>
  <para>
  Then sort the subclasses by that value:
  </para>
  <ul>
  F(is 0.5), E(is 1), D(is 2)
  </ul>
  <para>
  So the placement is:
  </para>
  <ul>
  <p>A B C</p>
  <p>(here are the links, but I can't hardly paint them as ASCIIs)</p>
  <p>F E D</p>
  </ul>
  </subsubsection>

 </subsection>

 <subsection title="Graphics Environment (GEF)">

  <subsubsection title="What are the basics of GEF (short intro)?">
  <para>
  The basic element in GEF is a figure. There are five different kinds
  of figures: lines, rectangles, edges, texts and nodes (with groups as
  a special case of nodes). Edges and nodes are used as base classes
  for UML specific elements like associations, states, classes etc.
  </para>
  <para>
  There is old documentation, where you can find a
  <a href="http://argouml.tigris.org/nonav/v07/docs/organization/gef.html">
  class diagram</a> about GEF.
  </para>
  </subsubsection>
  <subsubsection title="How and where is the GEF API used for UML?">
  At the moment there only exists old documentation: about
  <a href="http://argouml.tigris.org/nonav/v07/docs/cookbook/figure/">
  UML figures</a> and their associated
  <a href="http://argouml.tigris.org/nonav/v07/docs/cookbook/propertyPanel/">
  property panels</a>. Though package names changed a lot, you will
  find the mentioned classes in org.argouml.uml.diagram.*(.*)
  and org.argouml.uml.ui.foundation.core.* instead.
  <para>
  
  </para>
  </subsubsection>

 </subsection>

 <subsection title="UML Meta Model (NSUML)">

  <subsubsection title="What are the basics of the used meta model (short intro)?">
  <para>
  </para>
  </subsubsection>
  <subsubsection title="How and where is the Novosoft API used?">
  <para>
  </para>
  </subsubsection>
  <subsubsection title="How is the model and its representation (e.g. in diagrams) synchronized?">
  <para>
  All changes immediately modify the model that the prop panels, diagrams
  and other panels share. (Since one might change one thing in PropPanel,
  then tweak something else in the diagram and then possible remove
  something from the tree view, keeping the prop panel changes uncommitted
  until an apply button is pressed would be undesireable and complicated
  to implement.)
  </para>
  </subsubsection>

 </subsection>

 </section>

 <leftboxes>
   <leftbox lmod="2001-04-10" title="Content">
   <content/>
   </leftbox>
 </leftboxes>

</page>
