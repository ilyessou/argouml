<html><head><title>4.9. Modules and PlugIns</title><link href="look-and-feel.css" rel="stylesheet" type="text/css"><meta content="DocBook XSL Stylesheets V1.37" name="generator"><link href="index.html" rel="home" title="ArgoUML Programmers Cookbook"><link href="ch04.html" rel="up" title="Chapter 4. Inside the components"><link href="ch04s08.html" rel="previous" title="4.8. Internationalization"><link href="ch04s10.html" rel="next" title="4.10. Logging"></head><body alink="#0000FF" bgcolor="white" link="#0000FF" text="black" vlink="#840084"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">4.9. Modules and PlugIns</th></tr><tr><td align="left" width="20%"><a href="ch04s08.html">Prev</a>&nbsp;</td><th align="center" width="60%">Chapter 4. Inside the components</th><td align="right" width="20%">&nbsp;<a href="ch04s10.html">Next</a></td></tr></table><hr></div><div class="sect1"><a name="modules_and_plugins"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="modules_and_plugins"></a>4.9. Modules and PlugIns</h2></div></div><div class="sect2"><a name="modules_vs_plugins"></a><div class="titlepage"><div><h3 class="title"><a name="modules_vs_plugins"></a>4.9.1. Differences between modules and plugins</h3></div></div><p>
<div class="itemizedlist"><ul><li><p><a name="N16b7"></a>Modules</p><p>
The ARGO open source UML tool provides a basis
for UML design and potentially an executable architecture application.
This module system proposes an extension capability to the ARGO UML tool. 
This module extension will give developers the ability to add
additional functionality to the ARGO UML environment
without modifying the base open source ARGO tool.
This flexibility should encourage
additional open source and/or commercial involvement
with the open source UML tool.  
</p><p>
The module extensions will load when ARGO UML starts
and receive events from the ARGO system.
When the modules are loaded
they have the capability of attaching
to internal ARGO architectural elements.
They can attach themselves as listeners
on menu popup items for the model contexts.
This module interface is light with interface mechanisms
to notify the extensions of user actions.
The extensions then evaluate these actions and perform accordingly.  
</p></li><li><p><a name="N16c3"></a>Plugins</p><p>
A plug-in in ArgoUML is a specific type of <tt>ArgoModule</tt>
that implements the
<tt>org.argouml.application.api.Pluggable</tt> interface.
It is supposed to act as a passive dynamic component,
i.e. it provides methods so that the core ArgoUML
application can query its existence and use its
specific functionality.

</p></li></ul></div>
</p></div><div class="sect2"><a name="modules"></a><div class="titlepage"><div><h3 class="title"><a name="modules"></a>4.9.2. Modules</h3></div></div><div class="sect3"><a name="architecture_modules"></a><div class="titlepage"><div><h4 class="title"><a name="architecture_modules"></a>4.9.2.1. Module Architecture</h4></div></div><p>
The controlling class of the module/plugin extension
is <tt>org.argouml.application.modules.ModuleLoader</tt>.
<tt>ModuleLoader</tt> is a singleton
created in the ARGO UML main initialization routine.

</p><p>
<tt>ModuleLoader</tt> will:

<div class="itemizedlist"><ul><li><p><a name="N16f5"></a>read in the property file</p></li><li><p><a name="N16fb"></a>create the specified classes</p></li><li><p><a name="N1701"></a>call initialize on these classes</p></li><li><p><a name="N1707"></a>place the class objects into the
internal <tt>ModuleLoader</tt> list</p></li></ul></div>
</p><p>
Each class must derive from the <tt>ArgoModule</tt> interface.
This interface provides the following methods:
<div class="itemizedlist"><ul><li><a name="N1719"></a><div class="funcsynopsis" id="N171b"><p></p><a name="N171b"></a><p><code><code class="funcdef">
String <b class="fsfunc">getModuleName</b>
</code>(void);</code></p><p></p></div><p>provides a display name for the ARGO module.  
</p></li><li><a name="N172f"></a><div class="funcsynopsis" id="N1731"><p></p><a name="N1731"></a><p><code><code class="funcdef">
String <b class="fsfunc">getModuleDescription</b>
</code>(void);</code></p><p></p></div><p>provides a textual description for the ARGO module.  
</p></li><li><a name="N1745"></a><div class="funcsynopsis" id="N1747"><p></p><a name="N1747"></a><p><code><code class="funcdef">
String <b class="fsfunc">getModuleVersion</b>
</code>(void);</code></p><p></p></div><p>provides the version of the ARGO module.
</p></li><li><a name="N175b"></a><div class="funcsynopsis" id="N175d"><p></p><a name="N175d"></a><p><code><code class="funcdef">
String <b class="fsfunc">getModuleAuthor</b>
</code>(void);</code></p><p></p></div><p>provides the name of the module author(s).
</p></li><li><a name="N1771"></a><div class="funcsynopsis" id="N1773"><p></p><a name="N1773"></a><p><code><code class="funcdef">
boolean <b class="fsfunc">initializeModule</b>
</code>(void);</code></p><p></p></div><p><tt>initializeModule</tt> is called
when the class loader has created the module,
and before it is added into the modules list.
<tt>initializeModule</tt> should
initialize any required data
and/or attach itself as a listener to ARGO actions.
The <tt>ModuleLoader</tt> is invoked
after the rest of ARGO has been initialized and loaded.
Any menu modifications or system level resources
should already be available
when the module initialization process is called.  
</p><p>
<tt>initializeModule</tt>
should return true
if the initialization is successful
(or if no initialization is necessary).
</p></li><li><a name="N179e"></a><div class="funcsynopsis" id="N17a0"><p></p><a name="N17a0"></a><p><code><code class="funcdef">
void <b class="fsfunc">shutdownModule</b>
</code>(void);</code></p><p></p></div><p>The <tt>shutdownModule</tt> method is called
when the <tt>ModuleLoader</tt> is destroyed.
<tt>shutdownModule</tt> provides each module the capability
to clean up or save any required information
before being cleared from memory.  
</p></li><li><p><a name="N17c1"></a>getPopUpActions</p><p>The getPopUpActions method is called
when a user right clicks on a context item.
The parameters passed into the pop-up actions method
are the current list of menu items for the context
and the context object that has received the pop-up event.
All popup actions within ARGO UML
will call the <tt>ModuleLoader</tt> doPopupActions event.
When this event is called
with the list of current popup items and the context,
the <tt>ModuleLoader</tt> will iterate
through all loaded modules
and calle their corresponding popup action methods.
The module will test the class type of the context.
If the class type of the context equals a context
where the module will add menu items,
then the module will add its menu items to the pop-up actions vector.
Within UML ARGO all actions are implemented
through a UML actions abstract class.
A module will create its own derived class
for the UML actions and add this menuaction to the pop-up vector.
If that menu item is selected in the pop-up menu
then the actionPerformed method within the UML action will be called.
When the actionPerformed is called the module will do its work.
</p></li><li><a name="N17d0"></a><div class="funcsynopsis" id="N17d2"><p></p><a name="N17d2"></a><p><code><code class="funcdef">
void <b class="fsfunc">setModuleEnabled</b>
</code>(boolean <var class="pdparam">tf</var>);</code></p><p></p></div></li><li><a name="N17ea"></a><div class="funcsynopsis" id="N17ec"><p></p><a name="N17ec"></a><p><code><code class="funcdef">
boolean <b class="fsfunc">isModuleEnabled</b>
</code>(void);</code></p><p></p></div></li><li><a name="N17fd"></a><div class="funcsynopsis" id="N17ff"><p></p><a name="N17ff"></a><p><code><code class="funcdef">
Vector <b class="fsfunc">getModulePopUpActions</b>
</code>(void);</code></p><p></p></div><p>...
</p></li><li><a name="N1813"></a><div class="funcsynopsis" id="N1815"><p></p><a name="N1815"></a><p><code><code class="funcdef">
String <b class="fsfunc">getModuleKey</b>
</code>(void);</code></p><p></p></div><p>Returns a string that identifies the module.
</p></li></ul></div>
</p><p>
The basic functionality will provide extensions
the ability to listen for a menu activity by context
within the UML diagramming environment.
When these events are fired,
the extension models can respond accordingly.  
</p></div><div class="sect3"><a name="using_modules"></a><div class="titlepage"><div><h4 class="title"><a name="using_modules"></a>4.9.2.2. Using Modules</h4></div></div><p>...</p></div><div class="sect3"><a name="howdoi_modules"></a><div class="titlepage"><div><h4 class="title"><a name="howdoi_modules"></a>4.9.2.3. How do I ...?</h4></div></div><p>
<div class="itemizedlist"><ul><li><p><a name="N1845"></a>...create a module?</p><p>
</p></li><li><p><a name="N184d"></a>...tell when a module is loaded?</p><p>
</p></li></ul></div>
</p></div></div><div class="sect2"><a name="plugins"></a><div class="titlepage"><div><h3 class="title"><a name="plugins"></a>4.9.3. Plugins</h3></div></div><div class="sect3"><a name="architecture_plugins"></a><div class="titlepage"><div><h4 class="title"><a name="architecture_plugins"></a>4.9.3.1. Plugin Architecture</h4></div></div><p>
Each class must derive from the <tt>Pluggable</tt> interface.
In addition to the methods declared in <tt>ArgoModule</tt>,
which <tt>Pluggable</tt> extends,
the interface provides the following method:

<div class="itemizedlist"><ul><li><a name="N1874"></a><div class="funcsynopsis" id="N1876"><p></p><a name="N1876"></a><p><code><code class="funcdef">
boolean <b class="fsfunc">inContext</b>
</code>(Object[] <var class="pdparam">context</var>);</code></p><p></p></div><p>
<tt>inContext</tt> allows a plug-in to decide
if it is available under a specific context. 
</p><p>
One example of a plugin with multiple criteria is the PluggableMenu.
PluggableMenu requires the first context to be a JMenuItem
which wants the PluggableMenu attached to as the context,
so that it can determine that it would attach to a menu.  The
second context is an internal (non-localized) description 
of the menu such as "File" or "View"
so that the plugin can further decide.
</p></li></ul></div>
</p><p>
It is useful for those plugins which actually use context
to provide a helper method

<div class="funcsynopsis" id="N189f"><p></p><a name="N189f"></a><p><code><code class="funcdef">
Object[] <b class="fsfunc">buildContext</b>
</code>(classtype1 <var class="pdparam">parameter1</var>, classtype2 <var class="pdparam">parameter2</var>);</code></p><p></p></div>
which will serve two purposes.
</p><p>
First, it will provide a simple way of creating the Object[] paramter.
</p><p>
Second, it helps to document the context parameters within the class itself.
</p><p>
Again using <tt>PluggableMenu</tt> as an example,
it contains the function

<pre class="programlisting">

    public Object[] buildContext(JMenuItem parentMenuItem, String menuType);

</pre>

which can be used as follows:

<pre class="programlisting">
    if plugin.inContext(plugin.buildcontext(parent, "Help")) {
        ....
    }
</pre>
</p></div><div class="sect3"><a name="using_plugins"></a><div class="titlepage"><div><h4 class="title"><a name="using_plugins"></a>4.9.3.2. Using Plugins</h4></div></div><p>...</p></div><div class="sect3"><a name="howdoi_plugins"></a><div class="titlepage"><div><h4 class="title"><a name="howdoi_plugins"></a>4.9.3.3. How do I ...?</h4></div></div><p>

<div class="itemizedlist"><ul><li><p><a name="N18e9"></a>...create a plugin project?</p><p>...</p></li><li><p><a name="N18f1"></a>...create a pluggable settings tab?</p><p>...</p></li><li><p><a name="N18f9"></a>...create a pluggable menu?</p><p>...</p></li><li><p><a name="N1901"></a>...create a pluggable notation?</p><p>...</p></li><li><p><a name="N1909"></a>...create a pluggable diagram?</p><p>...</p></li><li><p><a name="N1911"></a>...create a pluggable resource bundle?</p><p>...</p></li><li><p><a name="N1919"></a>...create a new pluggable type?</p><p>
<div class="itemizedlist"><ul><li><p><a name="N1921"></a>
Create the plug-ins interface
</p><p>

In the package org.argouml.application.api, create an
interface that extends Pluggable (in the same package).
The class name must begin with 'Pluggable'.
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0"><tr><td align="center" rowspan="2" valign="top" width="25"><img src="images/note.png"></td><th><a name="N1928"></a>Note</th></tr><tr><td align="left" colspan="2" valign="top"><p>
This is done to ensure that all plugin APIs are defined within Argo itself.
One of the main purposes of a plugin is
to provide the capability to add an externally defined class
that will be used by Argo in the same way as a similar internal class.
</p></td></tr></table></div>
</p><p>
It now inherits from ArgoModule the methods
<pre class="programlisting">
    public boolean initializeModule();
    
    public boolean shutdownModule();

    public void setModuleEnabled(boolean tf);
    
    public boolean isModuleEnabled();

    public String getModuleName();

    public String getModuleDescription(); 
    
    public String getModuleVersion(); 
    
    public String getModuleAuthor(); 
    
    public Vector getModulePopUpActions(Vector popUpActions, Object context);

    public String getModuleKey();
</pre>

and from Pluggable the methods

<pre class="programlisting">

    public boolean inContext(Object[] context);

</pre>

and thus provides the mechanism to act like a plug-in.
It can be seen that a plug-in is a module.

</p><p>
The newly created plug-in of course should have more
extensions in order to be able to fulfill its purpose.
</p><p>
EXAMPLE:
</p><p>
Let's say we want to enable new diagram types as plug-ins.
We call the interface PluggableDiagram and add at least a
method that returns an JMenuItem object:

<pre class="programlisting">
    public JMenuItem getDiagramMenuItem();
</pre>

The returned menu item will be added to the diagrams menu
to allow to open a new diagram of this type.
</p></li><li><p><a name="N194d"></a>
Create implementation(s)
</p><p>
We do this by creating a helper class in the package
org.argouml.application.helpers that implements the created
plug-in interface PluggableDiagram, and call it DiagramHelper:

<pre class="programlisting">
public abstract class DiagramHelper extends ArgoDiagram
implements PluggableDiagram {

    /** Default localization key for diagrams
     */
    public final static String DIAGRAM_BUNDLE = "DiagramType";

    /** String naming the resource bundle to use for localization.
     */
    protected String _bundle = "";

    public DiagramHelper() {
        _bundle = getDiagramResourceBundleKey();
    }

    public void setModuleEnabled(boolean v) { }

    public boolean initializeModule() { return true; }

    public boolean inContext(Object[] o) { return true; }

    public boolean isModuleEnabled() { return true; }

    public Vector getModulePopUpActions(Vector v, Object o) { return null; }

    public boolean shutdownModule() { return true; }

    public JMenuItem getDiagramMenuItem()
    {
        return new JMenuItem(Argo.localize(_bundle,"diagram_type"));
    }

    public String getDiagramResourceBundleKey() {
        return DIAGRAM_BUNDLE;
    }
}

</pre>
The extension of ArgoDiagram is specific to this example;
the plug-in will provide a new ArgoUML diagram.

<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0"><tr><td align="center" rowspan="2" valign="top" width="25"><img src="images/important.png"></td><th><a name="N1959"></a>Important</th></tr><tr><td align="left" colspan="2" valign="top"><p>
Don't forget to do the localization stuff, because the
plug-in might be used in all languages ArgoUML offers!
</p></td></tr></table></div>

</p></li><li><p><a name="N1961"></a>
Localization (not plug-in specific, but important)
</p><p>
As you can see we defines a constant DIAGRAM_BUNDLE with
the value "DiagramType". This string is used for adding
the language resource.
This is most conveniently done inside of <tt>initializeModule</tt>.
So we change <tt>initializeModule</tt> as follows:


<pre class="programlisting">

    public boolean initializeModule() {
        Localizer.addResource("DiagramType",
                              "org.argouml.ui.DiagramResourceBundle");
        return true;
    }
</pre>

The resource bundle currently consists of the four classes

<pre class="programlisting">
    org.argouml.ui.DiagramResourceBundle
    org.argouml.ui.DiagramResourceBundle_de
    org.argouml.ui.DiagramResourceBundle_es
    org.argouml.ui.DiagramResourceBundle_fr
</pre>

which need to be created.
As additional translations are supported,
additional classes should be added.
</p></li></ul></div>

</p></li></ul></div>

</p></div></div></div><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a href="ch04s08.html">Prev</a>&nbsp;</td><td align="center" width="20%"><a href="index.html">Home</a></td><td align="right" width="40%">&nbsp;<a href="ch04s10.html">Next</a></td></tr><tr><td align="left" width="40%">4.8. Internationalization&nbsp;</td><td align="center" width="20%"><a href="ch04.html">Up</a></td><td align="right" width="40%">&nbsp;4.10. Logging</td></tr></table></div></body></html>