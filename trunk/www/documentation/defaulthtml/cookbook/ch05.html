<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;5.&nbsp;Inside the subsystems</title><link rel="stylesheet" href="look-and-feel.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.66.1"><link rel="start" href="index.html" title="Cookbook for Developers of ArgoUML"><link rel="up" href="index.html" title="Cookbook for Developers of ArgoUML"><link rel="prev" href="ch04s06.html" title="4.6.&nbsp;Loadable subsystems"><link rel="next" href="ch05s02.html" title="5.2.&nbsp;Critics and other cognitive tools"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;5.&nbsp;Inside the subsystems</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s06.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch05s02.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="inside_subsystems"></a>Chapter&nbsp;5.&nbsp;Inside the subsystems</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="ch05.html#model">5.1. Model</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05.html#model_factories">5.1.1. Factories</a></span></dt><dt><span class="sect2"><a href="ch05.html#model_helpers">5.1.2. Helpers</a></span></dt><dt><span class="sect2"><a href="ch05.html#d0e3679">5.1.3. The model event pump</a></span></dt><dt><span class="sect2"><a href="ch05.html#d0e3854">5.1.4. NSUML specifics</a></span></dt><dt><span class="sect2"><a href="ch05.html#working-with-the-model">5.1.5. How to work against the model</a></span></dt><dt><span class="sect2"><a href="ch05.html#howdoi_model">5.1.6. How do I...?</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05s02.html">5.2. Critics and other cognitive tools</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05s02.html#d0e4093">5.2.1. Main classes</a></span></dt><dt><span class="sect2"><a href="ch05s02.html#howdoi_critics">5.2.2. How do I ...?</a></span></dt><dt><span class="sect2"><a href="ch05s02.html#d0e4389">5.2.3. org.argouml.cognitive.critics.* class diagram</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05s03.html">5.3. Diagrams</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05s03.html#d0e4426">5.3.1. Multi editor pane</a></span></dt><dt><span class="sect2"><a href="ch05s03.html#howdoi_diagrams">5.3.2. How do I add a new element to a diagram?</a></span></dt><dt><span class="sect2"><a href="ch05s03.html#d0e4524">5.3.3. How to add a new Fig</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05s04.html">5.4. Property panels</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05s04.html#addingapropertypanel">5.4.1. Adding the property panel</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05s05.html">5.5. Persistence</a></span></dt><dt><span class="sect1"><a href="ch05s06.html">5.6. Notation</a></span></dt><dt><span class="sect1"><a href="ch05s07.html">5.7. Reverse Engineering Subsystem</a></span></dt><dt><span class="sect1"><a href="ch05s08.html">5.8. Code Generation Subsystem</a></span></dt><dt><span class="sect1"><a href="ch05s09.html">5.9. Java - Code generations and Reverse Engineering</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05s09.html#howdoi_reverse">5.9.1. How do I ...?</a></span></dt><dt><span class="sect2"><a href="ch05s09.html#d0e6582">5.9.2. Which sources are involved?</a></span></dt><dt><span class="sect2"><a href="ch05s09.html#d0e6589">5.9.3. How is the grammar of the target language implemented?</a></span></dt><dt><span class="sect2"><a href="ch05s09.html#d0e6597">5.9.4. Which model/diagram elements are generated?</a></span></dt><dt><span class="sect2"><a href="ch05s09.html#d0e6602">5.9.5. Which layout algorithm is used?</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05s10.html">5.10. Other languages</a></span></dt><dt><span class="sect1"><a href="ch05s11.html">5.11. The GUI</a></span></dt><dt><span class="sect1"><a href="ch05s12.html">5.12. Application</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05s12.html#d0e6748">5.12.1. What is loaded/initialized?</a></span></dt><dt><span class="sect2"><a href="ch05s12.html#d0e6755">5.12.2. Details pane</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05s13.html">5.13. Help System</a></span></dt><dt><span class="sect1"><a href="ch05s14.html">5.14. Internationalization</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05s14.html#d0e6914">5.14.1. Organizing translators</a></span></dt><dt><span class="sect2"><a href="ch05s14.html#d0e6981">5.14.2. Ambitions for localization</a></span></dt><dt><span class="sect2"><a href="ch05s14.html#howdoi_internationalization">5.14.3. How do I ...?</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05s15.html">5.15. Logging</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05s15.html#d0e7215">5.15.1. What to Log in ArgoUML</a></span></dt><dt><span class="sect2"><a href="ch05s15.html#d0e7244">5.15.2. How to Create Log Entries...</a></span></dt><dt><span class="sect2"><a href="ch05s15.html#d0e7327">5.15.3. How to Enable Logging...</a></span></dt><dt><span class="sect2"><a href="ch05s15.html#d0e7446">5.15.4. How to Customize Logging...</a></span></dt><dt><span class="sect2"><a href="ch05s15.html#d0e7457">5.15.5. References</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05s16.html">5.16. JRE with utils</a></span></dt><dt><span class="sect1"><a href="ch05s17.html">5.17. To do items</a></span></dt><dt><span class="sect1"><a href="ch05s18.html">5.18. Explorer</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05s18.html#d0e7527">5.18.1. Requirements</a></span></dt><dt><span class="sect2"><a href="ch05s18.html#d0e7579">5.18.2. Public APIs and SPIs</a></span></dt><dt><span class="sect2"><a href="ch05s18.html#explorer-implementation-details">5.18.3. Details of the Explorer Implementation</a></span></dt><dt><span class="sect2"><a href="ch05s18.html#d0e7655">5.18.4. How do I ...?</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05s19.html">5.19. Module loader</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05s19.html#d0e7762">5.19.1. What the ModuleLoader does</a></span></dt><dt><span class="sect2"><a href="ch05s19.html#design-module-loader">5.19.2. Design of the new Module Loader</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05s20.html">5.20. OCL</a></span></dt></dl></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td colspan="2" align="left" valign="top"><p> This chapter is currently under rework with new subsystem organization.
    </p><p> Things that are not actually in place are: TargetManager </p></td></tr></table></div><p>...</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="model"></a>5.1.&nbsp;Model</h2></div></div></div><a class="indexterm" name="d0e3590"></a><p><a name="comp-model-purpose"></a>
Purpose - To remove knowledge from the rest of ArgoUML of what model repository
is in use (e.g. MDR, EMF, NSUML) and to give a consistent interface for
manipulating data within those repositories.
</p><p>
The Model is located in <tt class="classname">org.argouml.model</tt>.
</p><p>
The Model is a Model subsystem. See <a href="ch04s04.html" title="4.4.&nbsp;Model subsystems">Section&nbsp;4.4, &#8220;Model subsystems&#8221;</a>.
</p><p>
Currently there is a full implementation using NSUML to store
the OMG UML Model.
</p><p>
Development is in progress for an MDR implmentation storing both the OMG UML
Model and Diagram Interchange Model.
</p><p>
The decision of which implementation to use is controlled by the Model class
which contols the implementations as alternative strategies (as in the Strategy
Pattern - GOF p315)
</p><p>
The Model class provides the rest of ArgoUML with various interfaces through
which ArgoUML can manipulate the repository.
</p><p>
Currenty there are factory and helper interfaces for controlling the lifetime
and properties of elements in the repository.
</p><p>
An interface is also made available to the Diagram Interchange Model should the
repository implementation contain such.
</p><p>
A ModelEventPump interface is provided through which ArgoUML can listen for
changes in the repository in a consistent way. Implementations of this pump
convert from the repoiroys specific events to ???
</p><p>
There are discussion underway to provide a facade (GOF p185) to this model.
Once the facade is complete this is likely to take over as a replacement model
interface. This will allow the complexities of the existing interfaces to be
rationalized without affcting the facade user.
</p><p>
The factories contain all methods that deal with
creating and building model elements.
The helpers contain all utility methods needed to manipulate
the model elements.
Per section of chapter 2 of the UML 1.3 specification there is one factory
and one helper. 
</p><p>
Both helpers and factories (and the Facade and ModelEventPump)
are interfaces that are fetched through static methods in the Model object.
</p><p>
Because the same interface is used internally
each implementation must provide objects for each of these interfaces.
</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="model_factories"></a>5.1.1.&nbsp;Factories</h3></div></div></div><p>
The factories contain in most cases a create method for each model element.
Example: <tt class="methodname">createClass</tt>
resides in <tt class="classname">CoreFactory</tt>-interface.
</p><p>
Besides that, there are several build methods to build classes.
The build methods have a signature like
<code class="methodsynopsis"><span class="modifier">public&nbsp;</span><span class="type">Object&nbsp;</span><span class="methodname">buildMODELELEMENTNAME</span>(<span class="methodparam"><span class="parameter">params</span></span>);</code>.
</p><p>
Each build method verifies the wellformedness rules
as defined in the UML spec 1.3.
The reason for this is that NS-UML does not enforce
the wellformedness rules even though non-well-formed UML can lead to
non-well-formed XMI which leads to saving/loading issues and
all kinds of illegal states of ArgoUML.
</p><p>
If you want to create an element you shall use the build or create methods
in the factories.
You are strongly advised to use a build method or, if there is
none that suits your needs, to write a new one reusing the already
existing build methods and utility methods in the helpers.
The reason for this is that the event listeners for
the newly created model element are setup correctly.
</p><p>
Question: Am I allowed to call the factories from any thread?
Answer: The current checks are not written to allow for multiple threads
so don't!
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="model_helpers"></a>5.1.2.&nbsp;Helpers</h3></div></div></div><p>
The helpers contain all utility methods for manipulating model elements.
For example, they contain methods to get all model elements
of a certain class out of the model
(see <tt class="methodname">getAllModelelementsOfKind</tt> in 
<tt class="classname">ModelManagementHelper</tt>).
</p><p>
To find a utility method you need to know where it is.
As a rule of thumb, a utility method for some model element 
is defined in the helper that corresponds with the section
in the UML specification.
For example, all utility methods for manipulating classes 
are defined in <tt class="classname">CoreHelper</tt>.
</p><p>
There are a few exceptions to this rule, mainly if 
the utility method deals with two model elements 
that correspond to different sections in the UML
specification.
Then you have to look in both corresponding helpers and you
will probably find what you are searching for.
</p><p>
Question: Am I allowed to call the helpers from any thread?
Answer: The current checks are not written to allow for multiple threads
so don't!
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3679"></a>5.1.3.&nbsp;The model event pump</h3></div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3682"></a>5.1.3.1.&nbsp;Introduction</h4></div></div></div><p>
Late 2002, the ArgoUML community decided for the introduction of a clean
interface between the NSUML model and the rest of ArgoUML.
This interface consists of three parts:
</p><div class="orderedlist"><ol type="1"><li><p>
The model factories, responsible for creation and deletion of model elements
</p></li><li><p>
The model helpers, responsible for utility functions to manipulate the
model elements and
</p></li><li><p>
The model event pump, responsible for sending model events to the rest
of ArgoUML.
</p></li></ol></div><p>
</p><p>
The model factories and the model helpers are described in 
<a href="ch05.html#model_factories" title="5.1.1.&nbsp;Factories">Section&nbsp;5.1.1, &#8220;Factories&#8221;</a> and
<a href="ch05.html#model_helpers" title="5.1.2.&nbsp;Helpers">Section&nbsp;5.1.2, &#8220;Helpers&#8221;</a> respectively.
</p><p>
In the beginning of 2003, in the work to replace NSUML, the need for this
interface not to use any NSUML classes was seen.
The <tt class="classname">ModelFacade</tt> was introduced to wrap
model factories,
model helpers, and
direct calls to NSUML
but not the model event pump.
In April 2004 a <tt class="classname">ModelEventPump</tt>-interface
was introduced to wrap
the <tt class="classname">UmlModelEventPump</tt>
using <tt class="classname">PropertyChangeEvent</tt>s.
</p><p>
The model event pump is the gateway between the model elements and the
rest of ArgoUML.
Events fired by the model elements are caught by the pump and then
'pumped' to those listeners interested in them.
The main advantage of this model is that the registration of listeners
is concentrated in one place (see picture *).
This makes it easier to change the interface between the model and the
rest of ArgoUML.
</p><p>
Besides this, there are some improvements to the performance of the
pump made in comparison to the situation without the pump.
The main improvement is that you can register for just one type of
event and not for all events fired by some model element.
In this respect the pump works as a filter.
</p><p>
</p><div class="mediaobject"><img src="images/cookbook/eventsbeforepump.gif"></div><p>
</p><p>
</p><div class="mediaobject"><img src="images/cookbook/eventsafterpump.gif"></div><p>
</p><p>
The model event pump will replace all other event mechanisms for model
events in the future.
These mechanisms (like UMLChangeDispatch and ThirdPartyEventlisteners
for those who are interested) are DEPRECATED.
Do not use them therefore and do not use classes that use them.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3736"></a>5.1.3.2.&nbsp;Public API</h4></div></div></div><p>
You might wonder: how does this all work?
Well, very simple in fact.
</p><p>
A model event (from now on a Event) has a name that uniquely
identifies the type of the event.

In most cases the name of the Event is equal to the name of the
property that was changed in the model.

In fact, there is even a 1-1 relationship between the type of Event
and the property changed in the model.

Therefore most listeners that need Events are only interested in one
type of Event since they are only interested in the status of 1
property.
</p><p>
TODO: What thread will I receive my event in? 
What locks will be held by the Model while I receive my event i.e.
is there something I cannot do from the event thread?
</p><p>
In the case described above (the most common one) you only have to
subscribe with the pump for that type of event.
This is explained in section <a href="ch05.html#pump-register-listener-for-type" title="5.1.3.2.1.&nbsp;&#xA;How do I register a listener for a certain type event&#xA;">Section&nbsp;5.1.3.2.1, &#8220;
How do I register a listener for a certain type event
&#8221;</a>
and <a href="ch05.html#pump-remove-listener-for-event" title="5.1.3.2.2.&nbsp;How do I remove a listener for a certain event">Section&nbsp;5.1.3.2.2, &#8220;How do I remove a listener for a certain event&#8221;</a>
</p><p>
Besides the case that you are interested in only one type of event (or
a set of types), there are occasions that you are interested in all
events fired by a certain model element or even for all events fired by
a certain type of model element.

For these cases, the pump has functionality too.

This is described in section 
<a href="ch05.html#pump-methods-for-adding-and-removing" title="5.1.3.2.3.&nbsp;&#xA;Hey, I saw some other methods for adding and removing?&#xA;">Section&nbsp;5.1.3.2.3, &#8220;
Hey, I saw some other methods for adding and removing?
&#8221;</a>.
</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="pump-register-listener-for-type"></a>5.1.3.2.1.&nbsp;
How do I register a listener for a certain type event
</h5></div></div></div><p>
This is really very simple. Use the model
</p><pre class="programlisting">
addModelEventListener(PropertyChangeListener listener, Object modelelement, String eventName)
</pre><p>
like this:
</p><pre class="programlisting">
Model.getPump().addModelEventListener(this, modelelementIAmInterestedIn, "IamInterestedInThisEventnameType");
</pre><p>
Now your object this gets only the <tt class="classname">Events</tt>
fired by modelElementIAmInterestedIn that have the name
"IamInterestedInThisEventnameType".
</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="pump-remove-listener-for-event"></a>5.1.3.2.2.&nbsp;How do I remove a listener for a certain event</h5></div></div></div><p>
This is the opposite of registering a listener. It all works with the
method
</p><pre class="programlisting">
removeModelEventListener(PropertyChangeListener listener, Object modelElement, String eventName)
</pre><p>
on the <tt class="classname">ModelEventPump</tt> like this:
</p><pre class="programlisting">
Model.getPump().removeModelEventListener(this, modelelementIAmInterestedIn, "IamInterestedInThisEventnameType");
</pre><p>
Now your object is not registered any more for this event type. 
</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="pump-methods-for-adding-and-removing"></a>5.1.3.2.3.&nbsp;
Hey, I saw some other methods for adding and removing?
</h5></div></div></div><p>
Yes there are some other method for adding and removing. 

You can add a listener that is interested in ALL events fired by a
certain model elements.

This works with the method:
</p><pre class="programlisting">
addModelEventListener(PropertyChangeListener listener, Object modelelement)
</pre><p>
As you can see no names of events you can register for here.
</p><p>
Furthermore, you can add a listener that is interested in several
types of events but coming from 1 model element.

This is a convenience method for not having to call the methods
explained in section
<a href="ch05.html#pump-register-listener-for-type" title="5.1.3.2.1.&nbsp;&#xA;How do I register a listener for a certain type event&#xA;">Section&nbsp;5.1.3.2.1, &#8220;
How do I register a listener for a certain type event
&#8221;</a>
more than once.

It works via:
</p><pre class="programlisting">
addModelEventListener(PropertyChangeListener listener, Object modelelement, String[] eventNames)
</pre><p>
</p><p>
You can pass the method an array of strings with event names in which
your listener is interested.
</p><p>
Thirdly there is a very powerful method to register your listener to
ALL events fired by a ALL model elements of a certain class.

You can understand that using this method can have severe performance
impacts.
Therefore use it with care. 

The method is:
</p><pre class="programlisting">
addClassModelEventListener(PropertyChangeListener listener, Object modelClass)
</pre><p>
There are also methods that allow you to register only for one type of
event fired by all model elements of a certain class and to register
for a set of types of events fired by all mod elements of a certain
class.
</p><p>
Of course you can remove your listeners from the event pump. 
This works with methods starting with remove instead of add.
</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3807"></a>5.1.3.3.&nbsp;Tips</h4></div></div></div><div class="orderedlist"><ol type="1"><li><p>
Don't forget to remove your listener from the event pump if it's not
interested in some event any more.
</p><p>
If you do not remove it, that's gonna cost performance and it will
give you a hard time to debug all the logical bugs you see in your
listener.
</p></li><li><p>
When you implement your listener, it is wise to NOT DO the following:
</p><pre class="programlisting">
propertyChanged(MElementEvent event) {
      // do my thing for event type 1
      // do my thing for event type 2
      // etc.
}
</pre><p>
</p><p>
This will cause the things that need to be done for event type 1 to be
fired when event type 2 do arrive.
</p><p>
This still happens at a lot of places in the code of ArgoUML, most
notably in the modelChanged method of the children of
FigEdgeModelElement.
</p></li></ol></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3826"></a>5.1.3.4.&nbsp;Possible investigation points and improvements</h4></div></div></div><p>
Should we use our own event types?
</p><p>
Should we replace
the <tt class="classname">MElementListener</tt>
with <tt class="classname">PropertyChangeListener</tt> and
<tt class="classname">MElementEvent</tt>
with <tt class="classname">PropertyChangeEvent</tt>?

One reason we havn't done so yet is that it involves a lot of work and
testing.
</p><p>
Change the implementation of the Event pump
itself?

Not the API but the implementation!
</p><p>
At the moment the event pump does not use the AWT Event Thread for
dispatching events.

This can make ArgoUML slow (in the perception of the user). 
</p><p>
Use the standard
data structure that Swing uses for event registration
(i.e. <tt class="classname">javax.swing.EventListenerList</tt>).

Would this be an improvement?
</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3854"></a>5.1.4.&nbsp;NSUML specifics</h3></div></div></div><p>
This is currently implemented using NSUML internally to implement 
the UML model.
The plan is to replace NSUML with some JMI compliant model instead
(probably MDR),
and for that reason
all APIs to the Model subsystem using NSUML objects are
to be replaced by interfaces without NSUML object and
eventually removed.
</p><p>
The NSUML model itself does not define enough 'business' logic
to be directly used and the factories and helper classes provide a
set of interfaces that wraps all functions of NSUML.
</p><p>
In the NSUML implementation factories contain delete methods
but they are only used internally within the Model subsystem.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="working-with-the-model"></a>5.1.5.&nbsp;How to work against the model</h3></div></div></div><p>
NS-UML is used within the Model subsystem to keep all data structures
in place.
Eventually we will change that to JMI/MDR that is newer and better and 
will take us into UML 1.4, UML 1.5 and UML 2.0.
Working directly against NS-UML or JMI/MDR will make changes in the
NS-UML or JMI/MDR affect large portions of the code.
For this reason we have in the Model subsystem,
a set of classes that lay between the NS-UML and JMI/MDR that
hides the APIs of NS-UML or JMI/MDR between something that will not
change while moving between them.
This is the API classes of the Model subsystem i.e.
Factories, Helpers, Event Pump (where to register for changes).
</p><p>
Here follows a list of how different things are done for the purpose
of making the transition easy.
Everything within ArgoUML should access the Model subsystem through the
interfaces in the <tt class="classname">org.argouml.model</tt> package.
The NS-UML or JMI/MDR and whatever other implementation we could eventually
come up with would provide the implementation of those interfaces.
</p><div class="table"><a name="d0e3873"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;How to work against the model</b></p><table summary="How to work against the model" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>What</th><th>NS-UML (use only within Model subsystem)</th><th>JMI/MDR (use only within Model subsystem)</th><th>Model subsystem</th></tr></thead><tbody><tr><td>Test that an Object o has a certain type</td><td>
o instanceof M<i class="replaceable"><tt>modelelementtype</tt></i> &#8594; boolean
</td><td>
???CLASSNAME???&#8203;.isInstanceOf(&#8203;RefObject toTest, String className) &#8594; boolean
</td><td>
Model.getFacade()&#8203;.isA<i class="replaceable"><tt>modelelementtype</tt></i>(o) &#8594; boolean
</td></tr><tr><td>Get a single valued model element from an Object o</td><td>
((M<i class="replaceable"><tt>modelelementtype</tt></i>)o)&#8203;.get<i class="replaceable"><tt>property</tt></i>()
&#8594; model element
</td><td>
((RefFeatured)obj)&#8203;.refGetValue(&#8203;String propName) &#8594; ???Type???
</td><td>
Model.getFacade()&#8203;.get<i class="replaceable"><tt>property</tt></i>(o) &#8594; Object
</td></tr><tr><td>Get a multi valued property from an Object o</td><td>
((M<i class="replaceable"><tt>modelelementtype</tt></i>)o)&#8203;.get<i class="replaceable"><tt>property</tt></i>()
&#8594; Collection
</td><td>
((RefFeatured)obj)&#8203;.refGetValue(String propName) &#8594; Collection
</td><td>
Model.getFacade()&#8203;.get<i class="replaceable"><tt>property</tt></i>(o)
&#8594; Iterator or Collection (total confusion!)
</td></tr><tr><td>Create a new model element of type Type:</td><td>
MFactory&#8203;.getDefaultFactory()&#8203;.create<i class="replaceable"><tt>Type</tt></i>()
</td><td>
???CLASSNAME???&#8203;.creatInstance(&#8203;String "<i class="replaceable"><tt>Type</tt></i>", 
                              List argument)
&#8594; RefObject 
</td><td>
Model&#8203;.get<i class="replaceable"><tt>ModelElementDomain?</tt></i>Factory&#8203;.build<i class="replaceable"><tt>modelelementtype</tt></i>(args)
or
Model&#8203;.get<i class="replaceable"><tt>ModelElementDomain?</tt></i>Factory&#8203;.create<i class="replaceable"><tt>modelelementtype</tt></i>()
to create them completely empty.
</td></tr><tr><td>Delete a model element</td><td>
        &nbsp;
  		</td><td>
        &nbsp;
  		</td><td>
Model&#8203;.getUmlFactory()&#8203;.delete(&#8203;<i class="replaceable"><tt>object</tt></i>) 
      </td></tr><tr><td>
Register for notification that a model element Object o has changed:
</td><td>
((MBase) o)&#8203;.addMElementListener(&#8203;MElementListener el)
</td><td>
((MDRChangeSource) obj)&#8203;.addChangeListener(???)
</td><td>
Model.getPump()&#8203;.addModelEventListener(&#8203;(PropertyChangeListener)li,
                                      Object o, String[] eventnames)
</td></tr><tr><td>
Register for notification on all model elements of a certain type Type:
</td><td>
Not possible!
</td><td>
((MDRChangeSource)obj&#8203;.refClass())&#8203;.addChangeListener(???)
</td><td>
Model.getPump()&#8203;.addModelEventListener(&#8203;(PropertyChangeListener)li,
                                      (Object)Model&#8203;.getMetaTypes()&#8203;.getMODELELEMENTTYPE(),
                                      String[] eventnames)
</td></tr><tr><td>How do I get the model as XMI on the stream Stream:</td><td>
(new XMIWriter(MModel m, Writer Stream)).gen()
</td><td>
new XMIWriter(???)
</td><td>
Handled by the Persistence subsystem.
</td></tr></tbody></table><p></p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="howdoi_model"></a>5.1.6.&nbsp;How do I...?</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>...add a new model element?</p><p>
Make a parameterless build method for your NSUML model element in one of
the UML Factories (for instance <tt class="classname">CoreFactory</tt>).
Stick to the UML 1.3 spec to choose the correct Factory.
The package structure under <tt class="classname">org.argouml.model.uml</tt>
follows the chapters in the UML spec so get it and read it!
In the build method, create a new model element using the appropriate
create method in the factory.
The build method e.g. is a wrapper around the create method.
For all elements there are already create methods (thanks Thierry).
For some elements there are already build methods.
If you need one of these elements, use the build method before you
barge into building new ones.
Initialize all things you need in the build method as far as they
don't need other model elements.
In the UML spec you can read which elements you need to initialize.
See for example <tt class="methodname">buildAttribute()</tt> for an example.
</p><p>
If you need to attach other already existing model elements to your
model element make a 
<tt class="methodname">build<i class="replaceable"><tt>XXXX</tt></i>(MModelelement 
            toattach1, ...)
</tt> 
method in the factory where you made the build method. 
Don't ever call the create methods directly. 
If we use the build methods we will always have initialized
model elements which will make a difference concerning save/load issues
for example.
</p><p>
Now you probably also need to create 
a Property Panel
and
a Fig object (See <a href="ch05s03.html#howto_createnewfig_2" title="5.3.3.5.&nbsp;Creating a new Fig (explanation 2)">Section&nbsp;5.3.3.5, &#8220;Creating a new Fig (explanation 2)&#8221;</a>).
</p></li><li><p>...create a new create method?</p><p>
Create it in the correct factory.
</p></li><li><p>...create a new utility method?</p><p>
Create it in the correct helper.
</p></li></ul></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s06.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch05s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4.6.&nbsp;Loadable subsystems&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;5.2.&nbsp;Critics and other cognitive tools</td></tr></table></div></body></html>