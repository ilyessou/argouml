<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>5.4.&nbsp;Property panels</title><link rel="stylesheet" href="look-and-feel.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.66.1"><link rel="start" href="index.html" title="Cookbook for Developers of ArgoUML"><link rel="up" href="ch05.html" title="Chapter&nbsp;5.&nbsp;Inside the subsystems"><link rel="prev" href="ch05s03.html" title="5.3.&nbsp;Diagrams"><link rel="next" href="ch05s05.html" title="5.5.&nbsp;Persistence"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5.4.&nbsp;Property panels</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s03.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;5.&nbsp;Inside the subsystems</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch05s05.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="propertypanels"></a>5.4.&nbsp;Property panels</h2></div></div></div><a class="indexterm" name="d0e4827"></a><p>
Purpose - to provide a form view of the diagrams and objects in the model.
The contents of the model is modifiable.
</p><p>
The Property panels will be located in
<tt class="classname">org.argouml.uml.?</tt>.
</p><p>
The Property panels is a View subsystem. See <a href="ch04s05.html" title="4.5.&nbsp;View and Control subsystems">Section&nbsp;4.5, &#8220;View and Control subsystems&#8221;</a>.
</p><p>
The PropPanels for the diagrams are in
<tt class="classname">org.argouml.uml.diagram.ui</tt>
and the property panels for UML objects are in
<tt class="classname">org.argouml.uml.ui.<i class="replaceable"><tt>UML path</tt></i></tt>.
</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="addingapropertypanel"></a>5.4.1.&nbsp;Adding the property panel</h3></div></div></div><p>
Property Panels for UML model elements are found as class 
<tt class="filename">PropPanel<i class="replaceable"><tt>XXX</tt></i>.java</tt>, 
where <i class="replaceable"><tt>XXX</tt></i> is the
UML meta-class. They are in sub-packages of org.argouml.uml.ui
corresponding to the <i class="replaceable"><tt>XXX</tt></i> NSUML packages, 
which in turn correspond to
their section in the chapter 2 of the UML 1.3 spec. 
</p><p>
So for our example we create a new class
<tt class="literal">PropPanelExtend</tt> in package
<tt class="literal">org.argouml.uml.ui.behavior.use_cases</tt>.
</p><p>
Any associated classes that do not fall into the UML classification
are provided in org.argouml.uml.ui.
</p><p> Typically the constructor for the new proppanel class invokes the 
      parent constructor, and then builds the fields required on the property 
      tab. The parent constructor may need an icon. If you need a new icon, it 
      should be placed in <tt class="literal">org/argouml/Images</tt> and a call to 
      <tt class="literal">lookupIcon()</tt> made (note that this is a utility method 
      of the parent PropPanel class). For our example we had to add 
      <tt class="literal">Extend.gif</tt>. </p><p><a name="iconformat"></a>
      From the ArgoUML V0.7 cookbook (updated to mention the current path):
      &#8220;<span class="quote">
        You will need to make an icon, in .gif format, 18 X 19 pixels, 
        with the transparent background color set to white. 
        Place this file in the org.argouml.Images directory 
        (it must be named like Name.gif). 
        This icon will automatically be used in the toolbar 
        and in the Navigation pane.
      </span>&#8221;
    </p><p> Finally the property panel must be added to the list of property 
      panels in the <tt class="literal">run()</tt> method of the 
      <tt class="literal">TabProps</tt> class, with a new call of 
      <tt class="literal">panels.put()</tt>. If you don't do this, navigation 
      listeners won't know about it! 
      </p><p> The content of the property panel is created as a grid with columns 
      (1 column if there are only a few fields, 2 or 3 if there are more). Each 
      row of each column contains a caption (i.e. label) and its corresponding 
      field. </p><p> A caption and its field may be added with one of a small number of 
      utility methods which shield you from the layout stuff: addField() and 
      addSeperator(). </p><p> A button may be added to the toolbar with the utility method 
      addButton(). </p><p> Every field is built from Java Swing components. However these are 
      extended by ArgoUML to help in the provision of action methods for fields 
      in the property tab. Several fields involve lists, and these require in 
      addition list models to compute the members of the list. </p><p> The fields that you might add to a property panel include: </p><div class="itemizedlist"><ul type="disc"><li><p> Simple editable text. For example the Name field. Supported 
          through the <tt class="literal">UMLTextField2</tt> class. </p></li><li><p> A drop down box (aka combobox) of options that can be selected. 
          Supported by the <tt class="literal">UMLComboBox2</tt> class. Used 
          e.g. for the type of a parameter.</p></li><li><p> A check box. This one does not use a seperate model class, 
          thanks to the simplicity of the represented boolean value. Supported 
          by the <tt class="literal">UMLCheckBox2</tt> class. Used e.g. for the 
          concurrency checkbox on a composite state.</p></li><li><p> A radio button. These always come in a group. Supported by the 
          <tt class="literal">UMLRadioButtonPanel</tt> class. Used e.g. for selecting 
          the visibility on the properties panel of a class.</p></li><li><p> A list. Used e.g. for the Generalizations field on 
          the proppanel of a class. The non-editable list is supported by the 
          <tt class="literal">UMLList2</tt> class and its child 
          <tt class="literal">UMLLinkedList</tt>. The latter also exists in the form 
          of <tt class="literal">UMLMutableLinkedList</tt>, which allows adding, 
          creation and deleting elements by popup menu. Used e.g. for the 
          subvertex list for a composite state.</p><p>The list model is usually provided by a sub-class of 
          <tt class="literal">UMLModelElementListModel2</tt>. There is a variant 
          <tt class="literal">UMLModelElementOrderedListModel2</tt> intended for 
          ordered links, which adds a few items to the pop-up menu, allowing 
          sorting. This latter model is used e.g. for attributes of a class. 
          </p></li><li><p> A drop down box of options that can be selected. This one exists 
          in several versions, each having different possibilities. The most 
          simple version is the <tt class="literal">UMLComboBox2</tt>. </p><p>The <tt class="literal">UMLEditableComboBox</tt> allows editing the 
          selected item.  </p><p>The <tt class="literal">UMLSearchableComboBox</tt> allows editing the 
          selected item. See e.g. the Operation combobox on the callevent 
          properties panel. </p><p> Then there is a variant with a seperate button for navigation to 
          the property panel for the currently selected item. This is supported 
          by the<tt class="literal">UMLComboBoxNavigator</tt> class. Used e.g. for 
          the stereotype field.</p></li><li><p> An editable multiline text area. Supported by the 
          <tt class="literal">UMLTextArea2</tt> class. Used e.g. for the text field 
          of a UML Comment.</p></li></ul></div><p>Examples of these fields in more detail follow below.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4991"></a>5.4.1.1.&nbsp;Adding a simple list field</h4></div></div></div><p> For example we need to add a field to the use case property panel 
        for the extends relationships that derive from this use case. </p><p> This field consists of a label and a scrollable pane 
        (<tt class="literal">JScrollPane</tt>) containing the list 
        (<tt class="literal">JList</tt>), which may be empty, or contain extend 
        relationships from this use case. </p><p> Rather than a straight <tt class="literal">JList</tt>, we use its child, 
        <tt class="literal">UMLLinkedList</tt>, which adds several features to the 
        standard JList specifically for ArgoUML's properties panels. </p><p> The constructor for <tt class="literal">UMLLinkedList</tt> requires two 
        arguments, a list model and a flag to indicate whether to show an icon. 
        </p><p> The list model should be a subclass of 
        <tt class="literal">UMLModelElementListModel2</tt>, a subclass of the Swing 
        <tt class="literal">DefaultListModel</tt> which implements 
        <tt class="literal">AbstractListModel</tt>. The 
        <tt class="literal">UMLModelElementListModel2</tt> implements two 
        interfaces: one that listens to target changes, and one that listens to 
        UML model changes.</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e5031"></a>5.4.1.1.1.&nbsp;The list model</h5></div></div></div><p> In our example we create 
          <tt class="literal">UMLUseCaseExtendListModel</tt>. Its constructor takes 
          no arguments. However, we need to provide the parent class with a 
          NSUML event name by invokeing the constructor of the parent class, 
          with the event name as parameter.</p><p> A string naming an NSUML event that should force a refresh of 
          the list model. A null value will cause all events to trigger a 
          refresh. The best way to identify the event you want to use is to 
          look at the NSUML source for the container object 
          (<tt class="literal">MUseCaseImpl</tt> in our example) for calls to 
          <tt class="literal">fire<i class="replaceable"><tt>XXX</tt></i>()</tt>. The first 
          argument is the name of the event (in our case 
          <tt class="literal">extend</tt>). There is no definitive list, but from the 
          NSUML source, these are all the names of events that are used: </p><div class="itemizedlist"><ul type="disc"><li><p>action</p></li><li><p>actionSequence</p></li><li><p>activator</p></li><li><p>activityGraph</p></li><li><p>actualArgument</p></li><li><p>addition</p></li><li><p>aggregation</p></li><li><p>alias</p></li><li><p>annotatedElement</p></li><li><p>argument</p></li><li><p>association</p></li><li><p>associationEnd</p></li><li><p>associationEndRole</p></li><li><p>associationRole</p></li><li><p>attribute</p></li><li><p>attributeLink</p></li><li><p>availableContents</p></li><li><p>availableFeature</p></li><li><p>availableQualifier</p></li><li><p>base</p></li><li><p>baseClass</p></li><li><p>baseElement</p></li><li><p>behavior</p></li><li><p>behavioralFeature</p></li><li><p>binding</p></li><li><p>body</p></li><li><p>bound</p></li><li><p>callAction</p></li><li><p>changeability</p></li><li><p>changeExpression</p></li><li><p>child</p></li><li><p>classifier</p></li><li><p>classifierInState</p></li><li><p>classifierRole</p></li><li><p>classifierRole1</p></li><li><p>client</p></li><li><p>clientDependency</p></li><li><p>collaboration</p></li><li><p>collaboration1</p></li><li><p>comment</p></li><li><p>communicationConnection</p></li><li><p>communicationLink</p></li><li><p>componentInstance</p></li><li><p>concurrency</p></li><li><p>condition</p></li><li><p>connection</p></li><li><p>constrainedElement</p></li><li><p>constrainedElement2</p></li><li><p>constrainingElement</p></li><li><p>constraint</p></li><li><p>container</p></li><li><p>contents</p></li><li><p>context</p></li><li><p>createAction</p></li><li><p>defaultElement</p></li><li><p>defaultValue</p></li><li><p>deferrableEvent</p></li><li><p>deploymentLocation</p></li><li><p>discriminator</p></li><li><p>dispatchAction</p></li><li><p>doActivity</p></li><li><p>dynamicArguments</p></li><li><p>dynamicMultiplicity</p></li><li><p>effect</p></li><li><p>elementImport</p></li><li><p>elementImport2</p></li><li><p>elementResidence</p></li><li><p>entry</p></li><li><p>event</p></li><li><p>exit</p></li><li><p>expression</p></li><li><p>extend</p></li><li><p>extend2</p></li><li><p>extendedElement</p></li><li><p>extender</p></li><li><p>extenderID</p></li><li><p>extension</p></li><li><p>extensionPoint</p></li><li><p>feature</p></li><li><p>generalization</p></li><li><p>guard</p></li><li><p>icon</p></li><li><p>implementationLocation</p></li><li><p>include</p></li><li><p>include2</p></li><li><p>incoming</p></li><li><p>initialValue</p></li><li><p>instance</p></li><li><p>instantiation</p></li><li><p>inState</p></li><li><p>interaction</p></li><li><p>internalTransition</p></li><li><p>isAbstarct</p></li><li><p>isAbstract</p></li><li><p>isActive</p></li><li><p>isAsynchronous</p></li><li><p>isConcurent</p></li><li><p>isDynamic</p></li><li><p>isInstantiable</p></li><li><p>isLeaf</p></li><li><p>isNavigable</p></li><li><p>isQuery</p></li><li><p>isRoot</p></li><li><p>isSpecification</p></li><li><p>isSynch</p></li><li><p>kind</p></li><li><p>link</p></li><li><p>linkEnd</p></li><li><p>location</p></li><li><p>mapping</p></li><li><p>message</p></li><li><p>message1</p></li><li><p>message2</p></li><li><p>message3</p></li><li><p>message4</p></li><li><p>method</p></li><li><p>modelElement</p></li><li><p>modelElement2</p></li><li><p>multiplicity</p></li><li><p>name</p></li><li><p>namespace</p></li><li><p>nodeInstance</p></li><li><p>objectFlowState</p></li><li><p>occurrence</p></li><li><p>operation</p></li><li><p>ordering</p></li><li><p>outgoing</p></li><li><p>ownedElement</p></li><li><p>owner</p></li><li><p>ownerScope</p></li><li><p>package</p></li><li><p>parameter</p></li><li><p>parent</p></li><li><p>participant</p></li><li><p>partition</p></li><li><p>partition1</p></li><li><p>powertype</p></li><li><p>powertypeRange</p></li><li><p>predecessor</p></li><li><p>presentation</p></li><li><p>qualifiedValue</p></li><li><p>qualifier</p></li><li><p>raisedSignal</p></li><li><p>receiver</p></li><li><p>reception</p></li><li><p>recurrence</p></li><li><p>referenceState</p></li><li><p>representedClassifier</p></li><li><p>representedOperation</p></li><li><p>requiredTag</p></li><li><p>resident</p></li><li><p>residentElement</p></li><li><p>script</p></li><li><p>sendAction</p></li><li><p>sender</p></li><li><p>signal</p></li><li><p>slot</p></li><li><p>source</p></li><li><p>sourceFlow</p></li><li><p>specialization</p></li><li><p>specification</p></li><li><p>state</p></li><li><p>state1</p></li><li><p>state2</p></li><li><p>state3</p></li><li><p>stateMachine</p></li><li><p>stereotype</p></li><li><p>stereotypeConstraint</p></li><li><p>stimulus</p></li><li><p>stimulus1</p></li><li><p>stimulus2</p></li><li><p>stimulus3</p></li><li><p>structuralFeature</p></li><li><p>subject</p></li><li><p>submachine</p></li><li><p>submachineState</p></li><li><p>subvertex</p></li><li><p>supplier</p></li><li><p>supplierDependency</p></li><li><p>tag</p></li><li><p>taggedValue</p></li><li><p>target</p></li><li><p>targetFlow</p></li><li><p>targetScope</p></li><li><p>templateParameter</p></li><li><p>templateParameter2</p></li><li><p>templateParameter3</p></li><li><p>top</p></li><li><p>transition</p></li><li><p>trigger</p></li><li><p>type</p></li><li><p>useCase</p></li><li><p>value</p></li><li><p>visibility</p></li><li><p>when</p></li></ul></div><p> This list model should then be provided with a number of 
          methods. The following are mandatory, since they are declared 
          abstract in the parent. </p><div class="variablelist"><dl><dt><span class="term">
              <tt class="literal">protected void buildModelList()</tt>
            </span></dt><dd><p> (Re)Builds the list of elements. Called from targetChanged 
                every time the target of the proppanel is changed. </p></dd><dt><span class="term">
              <tt class="literal">protected boolean isValidElement(Object/*MBase*/ 
                o)</tt>
            </span></dt><dd><p> Returns true if the given element is valid, i.e. it may be 
                added to the list of elements. This function is called for many 
                UML elements, to determine if it fits in the list. Remark: The 
                indication /*MBase*/ is a remainder from the time that ArgoUML 
                included direct references to the NSUML model all over the 
                code. Now it is a practical reminder of what we are dealing 
                with.</p></dd></dl></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td colspan="2" align="left" valign="top"><p> The following description is old and the property panels have 
            undergone some fundamental changes since it was written. It would 
            be good if someone that knows how it works now could write a 
            description on how it works now. </p></td></tr></table></div><p> The following are sometimes provided as an override of the 
          parent, although for many uses the default is fine. </p><div class="variablelist"><dl><dt><span class="term">
              <tt class="literal">public void open(int index)</tt>
            </span></dt><dd><p> Perform the action associated with the &#8220;<span class="quote">open</span>&#8221; 
                pop-up menu on the element at the given index. The default 
                provided in the parent just navigates to that element. </p></dd><dt><span class="term">
              <tt class="literal">public boolean buildPopup(JPopupMenu popup, int 
                index)</tt>
            </span></dt><dd><p> Build a pop-up menu for the list and return whether it 
                should be displayed. Any actions will be associated with the 
                item at the given index in the list. This is built using 
                <tt class="literal">UMLListMenuItem</tt>, which can record the index, 
                rather than plain <tt class="literal">JListItem</tt>. The default 
                provides open, add, delete, move up and move down, with add 
                disabled if there are already as many elements as the upper 
                bound (if any) for the list, open and delete disabled if there 
                are no elements and move up and move down disabled if they 
                cannot be invoked on the given element. The default 
                implementation always returns true. </p></dd></dl></div><p> The following should be declared as needed to support particular 
          pop-up functions. </p><div class="variablelist"><dl><dt><span class="term">
              <tt class="literal">public void add(int index)</tt>
            </span></dt><dd><p> Perform the actions associated with the &#8220;<span class="quote">add</span>&#8221; 
                pop-up menu on the element at the given index. There is no 
                default provided, so this must be given if the 
                &#8220;<span class="quote">add</span>&#8221; operation is supported. The 
                <tt class="literal">addAtUtil()</tt> method (see below) may prove 
                helpful. </p><p> In this routine you may create a new NSUML entity. There 
                seem to be three ways to do this, in order of preference 1) use 
                a utility from the <tt class="literal">MMUtil</tt> class, 2) use the 
                NSUML Factory class to create what you want 3) use new on a 
                <tt class="literal">M<i class="replaceable"><tt>XXX</tt></i>Impl</tt> class. 
                Whilst 1) is best, most of the <tt class="literal">MMUtil</tt> 
                routines are not yet general enough. </p><p> Be sure to set it up (don't forget e.g namespace etc). 
                Remember also to change anything that references the newly 
                created entity. </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td colspan="2" align="left" valign="top"><p> The NSUML routines generally set up the 
                  &#8220;<span class="quote">other</span>&#8221; end of a relationship automatically if 
                  you set up one end. If you try to do both (on a NxM 
                  relationship) you will probably end up doing it twice. If you 
                  do encounter this, the rule of thumb is to explicitly set the 
                  ordered end (if you do it the other way round, NSUML will 
                  assume you mean the "other" end to be at the end of its 
                  ordered list). </p></td></tr></table></div></dd><dt><span class="term">
              <tt class="literal">public void delete(int index)</tt>
            </span></dt><dd><p> Perform the actions associated with the 
                &#8220;<span class="quote">delete</span>&#8221; pop-up menu on the element at the given 
                index. There is no default provided, so this must be given if 
                the &#8220;<span class="quote">delete</span>&#8221; operation is supported. </p></dd><dt><span class="term">
              <tt class="literal">public void moveUp(int index)</tt>
            </span></dt><dd><p> Perform the actions associated with the &#8220;<span class="quote">move 
                up</span>&#8221; pop-up menu on the element at the given index. There 
                is no default provided, so this must be given if the 
                &#8220;<span class="quote">move up</span>&#8221; operation is supported. </p></dd><dt><span class="term">
              <tt class="literal">public void moveDown(int index)</tt>
            </span></dt><dd><p> Perform the actions associated with the &#8220;<span class="quote">move 
                down</span>&#8221; pop-up menu on the element at the given index. 
                There is no default provided, so this must be given if the 
                &#8220;<span class="quote">move down</span>&#8221; operation is supported. </p></dd></dl></div><p> The following normally use the default method, but may be 
          declared to override methods in the parent </p><div class="variablelist"><dl><dt><span class="term">
              <tt class="literal">public void resetSize()</tt>
            </span></dt><dd><p> Called when an external event may have changed the size of 
                the list. The default just sets a flag, which will ensure 
                recalcModelElementSize (see above) is invoked as needed. </p></dd><dt><span class="term">
              <tt class="literal">public Object formatElement(MModelElement 
                element)</tt>
            </span></dt><dd><p> Return an object (invariably a String) that represents an 
                element. The default provided in the parent defers this to the 
                container, which in turn defers it to the current profile. This 
                is usually perfectly satisfactory. </p></dd><dt><span class="term">
              <tt class="literal">public void targetChanged()</tt>
            </span></dt><dd><p> Called when the number of elements in the displayed list 
                (including &#8220;<span class="quote">none</span>&#8221;) may have changed. Default 
                invokes the necessary Swing operations to advise of a change in 
                list size. </p></dd><dt><span class="term">
              <tt class="literal">public void targetReasserted()</tt>
            </span></dt><dd><p> Called when the navigation history has been changed (and 
                navigation buttons may need changing). Not clear why anything 
                is needed, but default recomputes the list size, and invokes 
                the necessary Swing operations. </p></dd><dt><span class="term">
              <tt class="literal">public void roleAdded(final MElementEvent 
                event)</tt>
            </span></dt><dd><p> part of the NSUML EventListener interface. Called when an 
                add event happens, i.e. some NSUML object has been added. The 
                default provided looks to see if the event is the role name we 
                declared, or we are listening to all events, and if so looks to 
                see if it relates to an element in our list. If so Swing is 
                notified that the element has been added. </p></dd><dt><span class="term">
              <tt class="literal">public void roleRemoved(final MElementEvent 
                event)</tt>
            </span></dt><dd><p> part of the NSUML EventListener interface. Called when a 
                remove event happens, i.e. some NSUML object has been removed. 
                The default provided looks to see if the event is the role name 
                we declared, or we are listening to all events, and if so looks 
                to see if it relates to an element in our list. If so Swing is 
                notified that the element has been removed. </p></dd><dt><span class="term">
              <tt class="literal">public void recovered(final MElementEvent p1)</tt>
            , </span><span class="term">
              <tt class="literal">public void listRoleItemSet(final MElementEvent 
                p1)</tt>
            , </span><span class="term">
              <tt class="literal">public void removed(final MElementEvent p1)</tt>
            , </span><span class="term">
              <tt class="literal">public void propertySet(final MElementEvent p1)</tt>
            </span></dt><dd><p> these are all required as part of the NSUML EventListener 
                interface, which is not well documented. In each case the 
                default implementation recomputes the size, and advises Swing 
                that the entire list has changed. Needs more investigation. 
                </p></dd><dt><span class="term">
              <tt class="literal">public void navigateTo(MModelElement 
                modelElement)</tt>
            </span></dt><dd><p> a request to navigate to the specified object as part of 
                the NavigationListener interface. The default in the parent 
                just invokes navigateTo() on the container (ultimately 
                PropPanel). </p></dd></dl></div><p> The following utility routines are also provided in the parent. 
          They are not normally overridden. </p><div class="variablelist"><dl><dt><span class="term">
              <tt class="literal">public int getUpperBound()</tt>
            </span></dt><dd><p> get any upper bound (-1 is used if there is none). </p></dd><dt><span class="term">
              <tt class="literal">public void setUpperBound(int newBound)</tt>
            </span></dt><dd><p> set the upper bound (-1 is used if there is none). </p></dd><dt><span class="term">
              <tt class="literal">public final String getProperty()</tt>
            </span></dt><dd><p> returns the NSUML event name being monitored (null if all 
                are being monitored). </p></dd><dt><span class="term">
              <tt class="literal">protected final int getModelElementSize()</tt>
            </span></dt><dd><p> returns the number of elements in the list. Invokes 
                <tt class="literal">recalcModelElementSize()</tt> (see above) if 
                necessary. </p></dd><dt><span class="term">
              <tt class="literal">final Object getTarget()</tt>
            </span></dt><dd><p> returns the NSUML object associated with the container 
                (some child of <tt class="literal">PropPanel</tt> usually) that holds 
                this list model. </p></dd><dt><span class="term">
              <tt class="literal">final UMLUserInterfaceContainer getContainer()</tt>
            </span></dt><dd><p> returns the the container (some child of 
                <tt class="literal">PropPanel</tt> usually) that holds this list 
                model. </p></dd><dt><span class="term">
              <tt class="literal">public int getSize()</tt>
            </span></dt><dd><p> returns the size of the list. Including if there are no 
                elements in the model, but the list has a default text when 
                empty. </p></dd><dt><span class="term">
              <tt class="literal">public Object getElementAt(int index)</tt>
            </span></dt><dd><p> returns the element at the given index in the list. </p></dd><dt><span class="term">
              <tt class="literal">static protected Collection addAtUtil(Collection 
                oldCollection, MModelElement newItem, int index)</tt>
            </span></dt><dd><p> helps in writing the &#8220;<span class="quote">add</span>&#8221; function. newItem 
                is added at the specified index in the given oldCollection. 
                </p></dd><dt><span class="term">
              <tt class="literal">static protected java.util.List moveUpUtil(Collection 
                oldCollection, int index)</tt>
            </span></dt><dd><p> helps in writing the &#8220;<span class="quote">move up</span>&#8221; function. 
                Swaps the elements at offsets index and index-1. Not clear why 
                it doesn't return a Collection. </p></dd><dt><span class="term">
              <tt class="literal">static protected java.util.List moveDownUtil(Collection 
                oldCollection, int index)</tt>
            </span></dt><dd><p> helps in writing the &#8220;<span class="quote">move down</span>&#8221; function. 
                Swaps the elements at offsets index and index-1. Not clear why 
                it doesn't return a Collection. </p></dd><dt><span class="term">
              <tt class="literal">static protected MModelElement elementAtUtil(Collection 
                collection, int index, Class requiredClass)</tt>
            </span></dt><dd><p> helps in writing the <tt class="literal">getElementAt()</tt>. 
                Finds the element at a specific index. The last argument is 
                ignored! </p></dd></dl></div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6006"></a>5.4.1.2.&nbsp;Building the field</h4></div></div></div><p>
By convention the background of the list is set to the same as the
background of the PropPanel and the foreground to Color.blue.
</p><p>
The list is then added to a <tt class="literal">JScrollPane</tt>.  
Although ArgoUML has historically not used scrollbars
(<tt class="literal">JScrollPane.VERTICAL_SCROLLBAR_NEVER</tt> and
<tt class="literal">JScrollPane.HORIZONTAL_SCROLLBAR_NEVER</tt>), it is more
helpful to permit at least a vertical scrollbar where needed
(<tt class="literal">JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED</tt> and
<tt class="literal">JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED</tt>).
</p><p>
Finally the inherited method <tt class="literal">addCaption()</tt> is used
to add the label for the field and <tt class="literal">addField()</tt> to
add the associated scroll pane.
</p><p>
The second argument of each of these identifies the index of the
caption/field pair in the vertical column of the grid for this
property panel. The third argument identifies the column index. The
final argument is a vertical weighting to expand the field if there is
room in the property tab. This is usually set to the same non-zero
value for all fields and corresponding captions that can have multiple
entries, so they expand equally. If none of the fields should expand,
the caption only of the last field in each column should be given a
non-zero value.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6038"></a>5.4.1.3.&nbsp;Adding Property Tab Tool-bar Buttons</h4></div></div></div><p>
These are added by creating new instances of
<tt class="literal">PropPanelButton</tt> (you don't need to assign them to
anything - just creating will do).
This has six arguments.
</p><div class="itemizedlist"><ul type="disc"><li><p>
The container, i.e this property panel (usually just use
<tt class="literal">this</tt>).
</p></li><li><p>
The panel for the buttons.
Use <tt class="literal">buttonPanel</tt> which is inherited from
<tt class="literal">PropPanel</tt>.
</p></li><li><p>
The icon.
Lots of these are already defined in <tt class="literal">PropPanel</tt>.
</p></li><li><p>
The advisory text for the button.
Use <tt class="literal">localize(string)</tt> to ensure international
portability.
</p></li><li><p>
The name of the method to invoke when this button is used. 
Some of the standard ones (e.g for navigation) are provided, but you
will need to write any specials.
</p></li><li><p>
The name of the method (if any) to invoke to see if this button should
be enabled.
Use <tt class="literal">null</tt> if the button should always be
enabled.
</p></li></ul></div><p>
In our example, the extend property panel has a &#8220;<span class="quote">add extension
point</span>&#8221; button, with a method
<tt class="literal">newExtensionPoint</tt> that we provide to create a new
use case.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6091"></a>5.4.1.4.&nbsp;Support for stereotypes</h4></div></div></div><p>
The PropPanel should override the following (note the spelling of the
method name).
</p><p>
<tt class="literal">protected boolean 
isAcceptibleBaseMetaClass(String baseClass)</tt>. 
Returns <tt class="literal">true</tt> if the given base class is a class of
the target in the <tt class="literal">PropPanel</tt>.
</p><p>
This is used to determine what stereotypes may be shown for this
property panel.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6109"></a>5.4.1.5.&nbsp;Other sorts of fields</h4></div></div></div><p>
Another sort of field that may be useful is the ComboBox.
This is useful to allow users to select from a pre-defined list of
alongside a navigation arrow to go to the selected entry.
</p><p>
For example this is used to provide drop-down lists for the base and
extension use cases of an Extend relationship in
PropPanelExtend.
</p><p>
The model behind the drop down is created by using
<tt class="literal">UMLComboBoxModel</tt>:
<tt class="literal">UMLComboBoxModel(container, predicate, event, getter, setter,
allowVoid, baseClass, useModel)</tt>.
</p><p>
The container is the <tt class="literal">PropPanel</tt> where we are setting
up this ComboBox, the predicate is the name of a public method in that
PropPanel that, given a model element, determines if it should be in
the drop down, the event is the NSUML <tt class="literal">MElementEvent</tt>
name we are looking for (see earlier for the list),
<tt class="literal">getter</tt> is the name of a public method in the
PropPanel that yields the current entry in the combo Box (of type
<tt class="literal">baseClass</tt>), <tt class="literal">setter</tt> (with a
single argument of type <tt class="literal">baseClass</tt>) sets that entry,
<tt class="literal">allowVoid</tt> if <tt class="literal">true</tt> will allow an
empty entry for the box, <tt class="literal">baseClass</tt> is the NSUML
meta-class from which all entries must descend,
<tt class="literal">useModel</tt> is <tt class="literal">true</tt> to consider all
the elements in the standard profile model for inclusion (so the Java
types, standard stereotypes etc.).
</p><p>
For our <tt class="literal">PropPanelExtend</tt>, we provide a predicate
routine the call for the &#8220;<span class="quote">base</span>&#8221; field is:
</p><p>
<tt class="literal">UMLComboBoxModel(this, "isAcceptableUseCase", "base",
"getBase", "setBase", true, MUseCase.class, true);</tt>
</p><p>
and we define the methods <tt class="literal">isAcceptableUseCase</tt>,
<tt class="literal">getBase</tt> and <tt class="literal">setBase</tt> in
<tt class="literal">PropPanelExtend</tt>.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6186"></a>5.4.1.6.&nbsp;How UMLTextField works</h4></div></div></div><p>
This information is provided by Jaap Branderhorst (September 2002).
</p><p>
<tt class="classname">UMLTextField</tt> implements several kinds of 
event listeners:
</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="interfacename">MMelementListener</tt></p></li><li><p><tt class="interfacename">DocumentListener</tt></p></li><li><p><tt class="interfacename">FocusListener</tt></p></li></ul></div><p>
Furthermore it is a <tt class="classname">UMLUserInterfaceComponent</tt>.
</p><p>
Since it is an <tt class="classname">UMLUserInterfaceComponent</tt>
it must implement <tt class="methodname">targetChanged</tt> and
<tt class="methodname">targetReasserted</tt>.
<tt class="methodname">TargetChanged</tt> is called every time the 
<tt class="classname">UMLTextField</tt> is selected. 
<tt class="methodname">targetReasserted</tt> is of no interest for 
<tt class="classname">UMLTextField</tt>.
It plays a role in keeping history but since history 
is not really implemented at the moment in ArgoUML 
it is of no interest.
<tt class="methodname">targetChanged</tt> does two things:
</p><div class="itemizedlist"><ul type="disc"><li><p>
It calls the <tt class="methodname">targetChanged</tt> method 
of the <tt class="classname">UMLTextProperty</tt> this 
<tt class="classname">UMLTextfield</tt> is showing.
</p></li><li><p>
It calls the <tt class="methodname">update</tt> method.
The <tt class="methodname">update</tt> method is described further on.
</p></li></ul></div><p>
</p><p>
Besides <tt class="classname">UMLUserInterfaceComponent</tt>
there are several other interfaces of interest. 
One of them is <tt class="interfacename">MMElementListener</tt>.
</p><p>
Every time a <tt class="interfacename">MModelElement</tt> is
changed this will fire an <tt class="classname">MEvent</tt>
to <tt class="classname">UMLChangeDispatch</tt>.
<tt class="classname">UMLChangeDispatch</tt> will dispatch 
these events to all containers implementing
<tt class="interfacename">UMLUserInterfaceComponents</tt>
interested in this event, including <tt class="classname">UMLTextField</tt>.
It will also dispatch the event to all children of an interested container
implementing
<tt class="interfacename">UMLUserInterfaceComponent</tt>.
By this it is only necessary to register a 
<tt class="classname">PropPanel</tt> which holds an 
<tt class="classname">UMLTextField</tt> at 
<tt class="classname">UMLChangeDispatch</tt> to
dispatch the event to the <tt class="classname">UMLTextField</tt> too.
<tt class="interfacename">MMelementListener</tt>
knows several methods of which only one is of interest to
<tt class="classname">UMLTextField</tt>s:
</p><div class="itemizedlist"><ul type="disc"><li><p>propertySet</p><p>
Called every time a property in a 
<tt class="classname">MModelElement</tt> is set. 
This method calls 
<tt class="methodname">update</tt> too if the 
<tt class="classname">UMLTextProperty</tt> really is affected.
</p></li></ul></div><p>
</p><p>
Furthermore <tt class="classname">UMLTextField</tt> implements
<tt class="interfacename">DocumentListener</tt>. 
This is very typical for <tt class="classname">UMLTextField</tt>.
At the moment it is not possible to change the style of
the text in the <tt class="classname">UMLTextField</tt>.
Therefore the method <tt class="methodname">changedUpdate</tt> does not
have a body.
This method is only called when a <tt class="classname">DocumentEvent</tt>
occurs that changes the style/layout of the text.
The methods <tt class="methodname">insertUpdate</tt>
and <tt class="methodname">removeUpdate</tt> are respectively called when a
character is added to the document 
<tt class="classname">UMLTextField</tt> contains or removed. 
Since both methods are called when there is true user input 
and when the contents of the document are changed programmatically,
the methods distinguish between them.
<tt class="methodname">InsertUpdate</tt> and 
<tt class="methodname">removeUpdate</tt>
are both handled via the protected method 
<tt class="methodname">handleEvent</tt>.
<tt class="methodname">HandleEvent</tt> updates the property in 
<tt class="classname">UMLTextProperty</tt> if it is really changed.
If the update comes via user input, it is checked if it is valid input. 
If it is not, a <tt class="classname">JOptionPane</tt> is shown with '
a warning and the change is not committed into the model.
If it is not via user input, the input is not checked and the
property is set. If the property is set, the update method is called.
</p><p>
The implementation of <tt class="interfacename">FocusListener</tt>
makes sure that the checking of user input only happens when focus is lost.
Otherwise, it would not be possible to enter 'intermediate' values 
that are not legal. 
For instance, say the value class is not legal. 
Without the implementation of <tt class="interfacename">FocusListener</tt>,
it would not be possible to enter class diagram since
handleEvent would pop-up a warning message box.
</p><p>
The method <tt class="methodname">update</tt> updates both the actual
<tt class="classname">JTextfield</tt> as the diagram as soon
as some property is set. 
The updating of the diagram is done by calling the
<tt class="methodname">damage</tt> method of the figs that
represent the property on the diagram.
</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s03.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch05.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch05s05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.3.&nbsp;Diagrams&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;5.5.&nbsp;Persistence</td></tr></table></div></body></html>