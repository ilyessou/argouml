<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>5.4.&nbsp;Property panels</title><link rel="stylesheet" href="look-and-feel.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><link rel="home" href="index.html" title="Cookbook for Developers of ArgoUML"><link rel="up" href="ch05.html" title="Chapter&nbsp;5.&nbsp;Inside the components"><link rel="previous" href="ch05s03.html" title="5.3.&nbsp;Diagrams"><link rel="next" href="ch05s05.html" title="5.5.&nbsp;Reverse Engineering Component"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5.4.&nbsp;Property panels</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s03.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;5.&nbsp;Inside the components</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch05s05.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="propertypanels"></a>5.4.&nbsp;Property panels</h2></div></div><div></div></div><p>
Purpose - to provide a form view of the diagrams and objects in the model.
The contents of the model is modifyable.
</p><p>
The Property panels will be located in
<tt class="classname">org.argouml.?</tt>.
</p><p>
The Property panels is a Layer 2 component. See <a href="ch04s06.html" title="4.6.&nbsp;Layer 2 - Description of components">Section&nbsp;4.6, &#8220;Layer 2 - Description of components&#8221;</a>.
</p><p>
Currently the PropPanels for the diagrams are in
<tt class="classname">org.argouml.uml.diagram.ui</tt>
and the property panels for the other object are in
<tt class="classname">org.argouml.uml.ui.<i class="replaceable"><tt>NS-UML path</tt></i></tt>.
</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="addingapropertypanel"></a>5.4.1.&nbsp;Adding the property panel</h3></div></div><div></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td colspan="2" align="left" valign="top"><p>
This description is old and the property panels has undergone some
fundamental changes since it was written.
It would be good if someone that knows how it works now could write
a description on how it works now.
</p></td></tr></table></div><p>
Property Panels are found as class PropPanelXXX.java, where XXX is the
UML metaclass. They are in sub-packages of org.argouml.uml.ui
corresponding to the XXX NSUML packages, which in turn correspond to
their section in the chapter 2 of the UML 1.3 spec. This packaging is
essential for their lookup through Java reflection.
</p><p>
So for our example we create a new class
<tt class="literal">PropPanelExtend</tt> in package
<tt class="literal">org.argouml.uml.ui.behavior.use_cases</tt>.
</p><p>
Any associated classes that do not fall into the NSUML classification
are provided in org.argouml.uml.ui.
</p><p>
Typically the constructor for the new class invokes the parent
constructor, and then builds the fields required on the property
tab. The parent constructor may need an icon. If you need a new icon,
it should be placed in <tt class="literal">org/argouml/Images</tt> and a
call to <tt class="literal">ResourceLoader.lookupIconResource()</tt> made
(note this is a method of a GEF class). This is usually added to
<tt class="literal">PropPanelModelElement</tt>. For our example we have had
to add <tt class="literal">Extend.gif</tt>.
</p><p>
Finally the property panel must be added to the list of property
panels in the <tt class="literal">run()</tt> method of the
<tt class="literal">TabProps</tt> class, with a new call of
<tt class="literal">_panels.put()</tt>. If you don't do this, navigation
listeners won't know about it!
</p><p>
The property panel is created as a grid with a predefined number of
columns (2 if there are only a few fields, 3 if there are a lot). Into
each row of each column is placed a caption and a corresponding
field.
</p><p>
Adding a caption or field is through one of a small number of utility
methods which require you to specify which column and which row and
also a <tt class="literal">weighty</tt> parameter to specify the amount of
padding to be added when fields are stretched to fit a
column. Vertical padding is distributed in proportion to
<tt class="literal">weighty</tt> amongst all fields in the column that have
non-zero <tt class="literal">weighty</tt> values.
</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>
You should always ensure at least one field or caption in each column
has a non-zero value for <tt class="literal">weighty</tt>. If you wish
everything fixed size and floated to the top, make the value for the
final caption in the column non-zero.
</p></td></tr></table></div><p>
Every field is built from Java Swing components. However these are
extended by ArgoUML to help in the provision of action methods for
fields in the property tab. Several fields involve lists, and these
require in addition list models to compute the members of the
list.
</p><p>
The fields that you might add to a property panel include.
</p><div class="itemizedlist"><ul type="disc"><li><p>
Simple editable text. For example the Name
field. Supported through the <tt class="literal">UMLTextField</tt>
class.
</p></li><li><p>
A drop down box of options that can be selected, with an icon to the
right allowing navigation to the property panel for the currently
selected item. For example the Stereotype field. Supported in general
by the <tt class="literal">UMLComboBox</tt> class and more speficically by
its subclass for stereotypes,
<tt class="literal">UMLStereotypeComboBox</tt>.
</p></li><li><p>
A non-editable text box, with a pop-up menu that allows opening,
addition, deletion, moving up and moving down of entries. For example
the Generalizations field. Supported by the <tt class="literal">UMLList</tt>
class. The list model is usually provided by a sub-class of
<tt class="literal">UMLModelElementListModel</tt>. There is a varient
<tt class="literal">UMLModelElementListLinkModel</tt> which adds a link
option to the pop-up menu, allowing connection to existing model
elements (used for the Extension Points field for
example).
</p></li><li><p>
A set of check boxes for modifiers. Supported by the
<tt class="literal">PropPanelModifiers</tt> class.
</p></li></ul></div><p>Examples of these in more detail now follow.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3606"></a>5.4.1.1.&nbsp;Adding a simple list field</h4></div></div><div></div></div><p>
For example we need to add a field to the use case property panel for
the extends relationships that derive from this use case.
</p><p>
This field consists of a label and a scrollable pane
(<tt class="literal">JScrollPane</tt>) containing the list
(<tt class="literal">JList</tt>), possibly empty, or extends relationships
from this use case.
</p><p>
Rather than a straight <tt class="literal">JList</tt>, we use its child,
<tt class="literal">UMLList</tt>, which implements the
<tt class="literal">MouseListener</tt> and NSUML
<tt class="literal">ElementListener</tt> interfaces.
</p><p>
The constructor for <tt class="literal">UMLList</tt> requires two arguments,
a list model and a flag to indicate whether the list is navigable,
i.e. responds to the mouse.
</p><p>
The list model should be a subclass of
<tt class="literal">UMLModelElementListModel</tt>, a subclass of the Swing
<tt class="literal">AbstractListModel</tt> that implements the NSUML
<tt class="literal">ElementListener</tt> interface.
</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3649"></a>5.4.1.1.1.&nbsp;The list model</h5></div></div><div></div></div><p>
In our example we create UMLExtendListModel. Its constructor should
take three arguments:
</p><div class="orderedlist"><ol type="1"><li><p>
The container, where this list is being built. I.e. the
<tt class="literal">PropPanelUseCase</tt> (from which we can then derive the
NSUML <tt class="literal">MUseCase</tt>, which is the &#8220;<span class="quote">target</span>&#8221;
of the extends relationship).
</p></li><li><p>
A string naming an NSUML event that should force a refresh of the list
model. A null value will cause all events to trigger a refresh. The
best way to identify the event you want to use is to look at the NSUML
source for the container object (<tt class="literal">MUseCaseImpl</tt> in
our example) for calls to <tt class="literal">fireXXX()</tt>. The first
argument is the name of the event (in our case
<tt class="literal">extend</tt>). There is no definitive list, but from the
NSUML source, these are all the names of events that are used:
</p><div class="itemizedlist"><ul type="disc"><li><p>action</p></li><li><p>actionSequence</p></li><li><p>activator</p></li><li><p>activityGraph</p></li><li><p>actualArgument</p></li><li><p>addition</p></li><li><p>aggregation</p></li><li><p>alias</p></li><li><p>annotatedElement</p></li><li><p>argument</p></li><li><p>association</p></li><li><p>associationEnd</p></li><li><p>associationEndRole</p></li><li><p>associationRole</p></li><li><p>attribute</p></li><li><p>attributeLink</p></li><li><p>availableContents</p></li><li><p>availableFeature</p></li><li><p>availableQualifier</p></li><li><p>base</p></li><li><p>baseClass</p></li><li><p>baseElement</p></li><li><p>behavior</p></li><li><p>behavioralFeature</p></li><li><p>binding</p></li><li><p>body</p></li><li><p>bound</p></li><li><p>callAction</p></li><li><p>changeability</p></li><li><p>changeExpression</p></li><li><p>child</p></li><li><p>classifier</p></li><li><p>classifierInState</p></li><li><p>classifierRole</p></li><li><p>classifierRole1</p></li><li><p>client</p></li><li><p>clientDependency</p></li><li><p>collaboration</p></li><li><p>collaboration1</p></li><li><p>comment</p></li><li><p>communicationConnection</p></li><li><p>communicationLink</p></li><li><p>componentInstance</p></li><li><p>concurrency</p></li><li><p>condition</p></li><li><p>connection</p></li><li><p>constrainedElement</p></li><li><p>constrainedElement2</p></li><li><p>constrainingElement</p></li><li><p>constraint</p></li><li><p>container</p></li><li><p>contents</p></li><li><p>context</p></li><li><p>createAction</p></li><li><p>defaultElement</p></li><li><p>defaultValue</p></li><li><p>deferrableEvent</p></li><li><p>deploymentLocation</p></li><li><p>discriminator</p></li><li><p>dispatchAction</p></li><li><p>doActivity</p></li><li><p>dynamicArguments</p></li><li><p>dynamicMultiplicity</p></li><li><p>effect</p></li><li><p>elementImport</p></li><li><p>elementImport2</p></li><li><p>elementResidence</p></li><li><p>entry</p></li><li><p>event</p></li><li><p>exit</p></li><li><p>expression</p></li><li><p>extend</p></li><li><p>extend2</p></li><li><p>extendedElement</p></li><li><p>extender</p></li><li><p>extenderID</p></li><li><p>extension</p></li><li><p>extensionPoint</p></li><li><p>feature</p></li><li><p>generalization</p></li><li><p>guard</p></li><li><p>icon</p></li><li><p>implementationLocation</p></li><li><p>include</p></li><li><p>include2</p></li><li><p>incoming</p></li><li><p>initialValue</p></li><li><p>instance</p></li><li><p>instantiation</p></li><li><p>inState</p></li><li><p>interaction</p></li><li><p>internalTransition</p></li><li><p>isAbstarct</p></li><li><p>isAbstract</p></li><li><p>isActive</p></li><li><p>isAsynchronous</p></li><li><p>isConcurent</p></li><li><p>isDynamic</p></li><li><p>isInstantiable</p></li><li><p>isLeaf</p></li><li><p>isNavigable</p></li><li><p>isQuery</p></li><li><p>isRoot</p></li><li><p>isSpecification</p></li><li><p>isSynch</p></li><li><p>kind</p></li><li><p>link</p></li><li><p>linkEnd</p></li><li><p>location</p></li><li><p>mapping</p></li><li><p>message</p></li><li><p>message1</p></li><li><p>message2</p></li><li><p>message3</p></li><li><p>message4</p></li><li><p>method</p></li><li><p>modelElement</p></li><li><p>modelElement2</p></li><li><p>multiplicity</p></li><li><p>name</p></li><li><p>namespace</p></li><li><p>nodeInstance</p></li><li><p>objectFlowState</p></li><li><p>occurrence</p></li><li><p>operation</p></li><li><p>ordering</p></li><li><p>outgoing</p></li><li><p>ownedElement</p></li><li><p>owner</p></li><li><p>ownerScope</p></li><li><p>package</p></li><li><p>parameter</p></li><li><p>parent</p></li><li><p>participant</p></li><li><p>partition</p></li><li><p>partition1</p></li><li><p>powertype</p></li><li><p>powertypeRange</p></li><li><p>predecessor</p></li><li><p>presentation</p></li><li><p>qualifiedValue</p></li><li><p>qualifier</p></li><li><p>raisedSignal</p></li><li><p>receiver</p></li><li><p>reception</p></li><li><p>recurrence</p></li><li><p>referenceState</p></li><li><p>representedClassifier</p></li><li><p>representedOperation</p></li><li><p>requiredTag</p></li><li><p>resident</p></li><li><p>residentElement</p></li><li><p>script</p></li><li><p>sendAction</p></li><li><p>sender</p></li><li><p>signal</p></li><li><p>slot</p></li><li><p>source</p></li><li><p>sourceFlow</p></li><li><p>specialization</p></li><li><p>specification</p></li><li><p>state</p></li><li><p>state1</p></li><li><p>state2</p></li><li><p>state3</p></li><li><p>stateMachine</p></li><li><p>stereotype</p></li><li><p>stereotypeConstraint</p></li><li><p>stimulus</p></li><li><p>stimulus1</p></li><li><p>stimulus2</p></li><li><p>stimulus3</p></li><li><p>structuralFeature</p></li><li><p>subject</p></li><li><p>submachine</p></li><li><p>submachineState</p></li><li><p>subvertex</p></li><li><p>supplier</p></li><li><p>supplierDependency</p></li><li><p>tag</p></li><li><p>taggedValue</p></li><li><p>target</p></li><li><p>targetFlow</p></li><li><p>targetScope</p></li><li><p>templateParameter</p></li><li><p>templateParameter2</p></li><li><p>templateParameter3</p></li><li><p>top</p></li><li><p>transition</p></li><li><p>trigger</p></li><li><p>type</p></li><li><p>useCase</p></li><li><p>value</p></li><li><p>visibility</p></li><li><p>when</p></li></ul></div></li><li><p>
A flag to indicate that a label &#8220;<span class="quote">none</span>&#8221;
should be used when the list is empty.
</p></li></ol></div><p>
Quite usually it is sufficient to just invoke the constructor of
the parent class.
</p><p>
This list model should then be provided with a number of methods. The
following are mandatory, since they are declared abstract in the
parent.
</p><div class="variablelist"><dl><dt><span class="term">
<tt class="literal">protected int recalcModelElementSize()</tt>
</span></dt><dd><p>
Recomputes the number of elements in the list (zero if empty).
</p></dd><dt><span class="term">
<tt class="literal">protected MModelElement getModelElementAt(int index)</tt>
</span></dt><dd><p>
Returns the element at the given index in the list, 
or null if there isn't one.
</p></dd></dl></div><p>
The following are sometimes provided as an override of the
parent, although for many uses the default is fine.
</p><div class="variablelist"><dl><dt><span class="term">
<tt class="literal">public void open(int index)</tt>
</span></dt><dd><p>
Perform the action associated with the &#8220;<span class="quote">open</span>&#8221; pop-up menu
on the element at the given index. The default provided in the parent
just navigates to that element.
</p></dd><dt><span class="term">
<tt class="literal">public boolean buildPopup(JPopupMenu popup, int index)</tt>
</span></dt><dd><p>
Build a pop-up menu for the list and return whether it should be
displayed. Any actions will be associated with the item at the given
index in the list.
This is built using <tt class="literal">UMLListMenuItem</tt>, which can
record the index, rather than plain <tt class="literal">JListItem</tt>. 
The default provides open, add, delete, move up and move down, with
add disabled if there are already as many elements as the upper bound
(if any) for the list, open and delete disabled if there are no
elements and move up and move down disabled if they cannot be invoked
on the given element.
The default implementation always returns true.
</p></dd></dl></div><p>
The following should be declared as needed to support particular
pop-up functions.
</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">public void add(int index)</tt></span></dt><dd><p>
Perform the actions associated with the &#8220;<span class="quote">add</span>&#8221; pop-up menu
on the element at the given index.
There is no default provided, so this must be given if the
&#8220;<span class="quote">add</span>&#8221; operation is supported.
The <tt class="literal">addAtUtil()</tt> method (see below) may prove
helpful.
</p><p>
In this routine you may create a new NSUML entity.
There seem to be three ways to do this, in order of preference 1) use
a utility from the <tt class="literal">MMUtil</tt> class, 2) use the NSUML
Factory class to create what you want 3) use new on a
<tt class="literal">MXXXImpl</tt> class.
Whilst 1) is best, most of the <tt class="literal">MMUtil</tt> routines are
not yet general enough.
</p><p>
Be sure to set it up (don't forget e.g namespace etc).
Remember also to change anything that references the newly created
entity.
</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td><th align="left">Warning</th></tr><tr><td colspan="2" align="left" valign="top"><p>
The NSUML routines generally set up the &#8220;<span class="quote">other</span>&#8221; end of a
relationship automatically if you set up one end.
If you try to do both (on a NxM relationship) you will probably end up
doing it twice.
If you do encounter this, the rule of thumb is to explicitly set the
ordered end (if you do it the other way round, NSUML will assume you
mean the "other" end to be at the end of its ordered
list).
</p></td></tr></table></div></dd><dt><span class="term"><tt class="literal">public void delete(int index)</tt></span></dt><dd><p>
Perform the actions associated with the &#8220;<span class="quote">delete</span>&#8221; pop-up
menu on the element at the given index.
There is no default provided, so this must be given if the
&#8220;<span class="quote">delete</span>&#8221; operation is supported.
</p></dd><dt><span class="term"><tt class="literal">public void moveUp(int index)</tt></span></dt><dd><p>
Perform the actions associated with the &#8220;<span class="quote">move up</span>&#8221; pop-up
menu on the element at the given index. 
There is no default provided, so this must be given if the &#8220;<span class="quote">move
up</span>&#8221; operation is supported.
</p></dd><dt><span class="term">
<tt class="literal">public void moveDown(int index)</tt>
</span></dt><dd><p>
Perform the actions associated with the &#8220;<span class="quote">move down</span>&#8221;
pop-up menu on the element at the given index.
There is no default provided, so this must be given if the &#8220;<span class="quote">move
down</span>&#8221; operation is supported.
</p></dd></dl></div><p>
The following normally use the default method, but may be
declared to override methods in the parent
</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">public void resetSize()</tt></span></dt><dd><p>
Called when an external event may have changed the size of the
list.
The default just sets a flag, which will ensure recalcModelElementSize
(see above) is invoked as needed.
</p></dd><dt><span class="term">
<tt class="literal">public Object formatElement(MModelElement element)</tt></span></dt><dd><p>
Return an object (invariably a String) that represents an element. 
The default provided in the parent defers this to the container, which
in turn defers it to the current profile. 
This is usually perfectly satisfactory.
</p></dd><dt><span class="term"><tt class="literal">public void targetChanged()</tt></span></dt><dd><p>
Called when the number of elements in the displayed list (including
&#8220;<span class="quote">none</span>&#8221;) may have changed.
Default invokes the necessary Swing operations to advise of a change
in list size.
</p></dd><dt><span class="term">
<tt class="literal">public void targetReasserted()</tt>
</span></dt><dd><p>
Called when the navigation history has been changed (and navigation
buttons may need changing).
Not clear why anything is needed, but default recomputes the list
size, and invokes the necessary Swing operations.
</p></dd><dt><span class="term">
<tt class="literal">public void roleAdded(final MElementEvent event)</tt>
</span></dt><dd><p>
part of the NSUML EventListener interface.
Called when an add event happens, i.e. some NSUML object has been
added.
The default provided looks to see if the event is the role name we
declared, or we are listening to all events, and if so looks to see if
it relates to an element in our list. 
If so Swing is notified that the element has been
added.
</p></dd><dt><span class="term">
<tt class="literal">public void roleRemoved(final MElementEvent event)</tt>
</span></dt><dd><p>
part of the NSUML EventListener interface.
Called when a remove event happens, i.e. some NSUML object has been
removed.
The default provided looks to see if the event is the role name we
declared, or we are listening to all events, and if so looks to see if
it relates to an element in our list. 
If so Swing is notified that the element has been removed.
</p></dd><dt><span class="term">
<tt class="literal">public void recovered(final MElementEvent p1)</tt>
, </span><span class="term">
<tt class="literal">public void listRoleItemSet(final MElementEvent p1)</tt>
, </span><span class="term">
<tt class="literal">public void removed(final MElementEvent p1)</tt>
, </span><span class="term">
<tt class="literal">public void propertySet(final MElementEvent p1)</tt>
</span></dt><dd><p>
these are all required as part of the NSUML EventListener interface,
which is not well documented.
In each case the default implementation recomputes the size, and
advises Swing that the entire list has changed. 
Needs more investigation.
</p></dd><dt><span class="term">
<tt class="literal">public void navigateTo(MModelElement modelElement)</tt>
</span></dt><dd><p>
a request to navigate to the specified object as part of the
NavigationListener interface.

The default in the parent just invokes navigateTo() on the container
(ultimately PropPanel).
</p></dd></dl></div><p>
The following utility routines are also provided in the parent.
They are not normally overridden.
</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">public int getUpperBound()</tt></span></dt><dd><p>
get any upper bound (-1 is used if there is none).
</p></dd><dt><span class="term">
<tt class="literal">public void setUpperBound(int newBound)</tt>
</span></dt><dd><p>
set the upper bound (-1 is used if there is none).
</p></dd><dt><span class="term">
<tt class="literal">public final String getProperty()</tt>
</span></dt><dd><p>
returns the NSUML event name being monitored (null if all are being
monitored).
</p></dd><dt><span class="term">
<tt class="literal">protected final int getModelElementSize()</tt>
</span></dt><dd><p>
returns the number of elements in the list.
Invokes <tt class="literal">recalcModelElementSize()</tt> (see above) if
necessary.
</p></dd><dt><span class="term"><tt class="literal">final Object getTarget()</tt></span></dt><dd><p>
returns the NSUML object associated with the container (some child of
<tt class="literal">PropPanel</tt> usually) that holds this list
model.
</p></dd><dt><span class="term">
<tt class="literal">final UMLUserInterfaceContainer getContainer()</tt>
</span></dt><dd><p>
returns the the container (some child of <tt class="literal">PropPanel</tt>
usually) that holds this list model.
</p></dd><dt><span class="term"><tt class="literal">public int getSize()</tt></span></dt><dd><p>
returns the size of the list.
Including if there are no elements in the model, but the list has a
default text when empty.
</p></dd><dt><span class="term">
<tt class="literal">public Object getElementAt(int index)</tt>
</span></dt><dd><p>
returns the element at the given index in the list.
</p></dd><dt><span class="term">
<tt class="literal">static protected Collection 
addAtUtil(Collection oldCollection, MModelElement newItem, int index)</tt>
</span></dt><dd><p>
helps in writing the &#8220;<span class="quote">add</span>&#8221; function. newItem is added at
the specified index in the given oldCollection.
</p></dd><dt><span class="term">
<tt class="literal">static protected java.util.List 
moveUpUtil(Collection oldCollection, int index)</tt>
</span></dt><dd><p>
helps in writing the &#8220;<span class="quote">move up</span>&#8221; function.
Swaps the elements at offsets index and index-1.
Not clear why it doesn't return a Collection.
</p></dd><dt><span class="term">
<tt class="literal">static protected java.util.List
moveDownUtil(Collection oldCollection, int index)</tt>
</span></dt><dd><p>
helps in writing the &#8220;<span class="quote">move down</span>&#8221; function.
Swaps the elements at offsets index and index-1.
Not clear why it doesn't return a Collection.
</p></dd><dt><span class="term">
<tt class="literal">static protected MModelElement
elementAtUtil(Collection collection, int index, Class requiredClass)</tt>
</span></dt><dd><p>
helps in writing the <tt class="literal">getElementAt()</tt>.
Finds the element at a specific index.
The last argument is ignored!
</p></dd></dl></div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4617"></a>5.4.1.2.&nbsp;Building the field</h4></div></div><div></div></div><p>
By convention the background of the list is set to the same as the
background of the PropPanel and the foreground to Color.blue.
</p><p>
The list is then added to a <tt class="literal">JScrollPane</tt>.  
Although ArgoUML has historically not used scrollbars
(<tt class="literal">JScrollPane.VERTICAL_SCROLLBAR_NEVER</tt> and
<tt class="literal">JScrollPane.HORIZONTAL_SCROLLBAR_NEVER</tt>), it is more
helpful to permit at least a vertical scrollbar where needed
(<tt class="literal">JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED</tt> and
<tt class="literal">JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED</tt>).
</p><p>
Finally the inherited method <tt class="literal">addCaption()</tt> is used
to add the label for the field and <tt class="literal">addField()</tt> to
add the associated scrollpane.
</p><p>
The second argument of each of these identifies the index of the
caption/field pair in the vertical column of the grid for this
property panel. The third argument identifies the column index. The
final argument is a vertical weighting to expand the field if there is
room in the property tab. This is usually set to the same non-zero
value for all fields and corresponding captions that can have multiple
entries, so they expand equally. If none of the fields should expand,
the caption only of the last field in each column should be given a
non-zero value.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4649"></a>5.4.1.3.&nbsp;Adding Property Tab Toolbar Buttons</h4></div></div><div></div></div><p>
These are added by creating new instances of
<tt class="literal">PropPanelButton</tt> (you don't need to assign them to
anything&#8212;just creating will do).
This has six arguments.
</p><div class="itemizedlist"><ul type="disc"><li><p>
The container, i.e this property panel (usually just use
<tt class="literal">this</tt>).
</p></li><li><p>
The panel for the buttons.
Use <tt class="literal">buttonPanel</tt> which is inherited from
<tt class="literal">PropPanel</tt>.
</p></li><li><p>
The icon.
Lots of these are already defined in <tt class="literal">PropPanel</tt>.
</p></li><li><p>
The advisory text for the button.
Use <tt class="literal">localize(string)</tt> to ensure international
portability.
</p></li><li><p>
The name of the method to invoke when this button is used. 
Some of the standard ones (e.g for navigation) are provided, but you
will need to write any specials.
</p></li><li><p>
The name of the method (if any) to invoke to see if this button should
be enabled.
Use <tt class="literal">null</tt> if the button should always be
enabled.
</p></li></ul></div><p>
In our example, the extend property panel has a &#8220;<span class="quote">add extension
point</span>&#8221; button, with a method
<tt class="literal">newExtensionPoint</tt> that we provide to create a new
use case.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4702"></a>5.4.1.4.&nbsp;Support for stereotypes</h4></div></div><div></div></div><p>
The PropPanel should override the following (note the spelling of the
method name).
</p><p>
<tt class="literal">protected boolean 
isAcceptibleBaseMetaClass(String baseClass)</tt>. 
Returns <tt class="literal">true</tt> if the given base class is a class of
the target in the <tt class="literal">PropPanel</tt>.
</p><p>
This is used to determine what stereotypes may be shown for this
property panel.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4720"></a>5.4.1.5.&nbsp;Other sorts of fields</h4></div></div><div></div></div><p>
Another sort of field that may be useful is the ComboBox.
This is useful to allow users to select from a pre-defined list of
alongside a navigation arrow to go to the selected entry.
</p><p>
For example this is used to provide drop-down lists for the base and
extension use cases of an Extend relationship in
PropPanelExtend.
</p><p>
The model behind the drop down is created by using
<tt class="literal">UMLCombBoxModel</tt>:
<tt class="literal">UMLCombBoxModel(container, predicate, event, getter, setter,
allowVoid, baseClass, useModel)</tt>.
</p><p>
The container is the <tt class="literal">PropPanel</tt> where we are setting
up this ComboBox, the predicate is the name of a public method in that
PropPanel that, given a model element, determines if it should be in
the drop down, the event is the NSUML <tt class="literal">MElementEvent</tt>
name we are looking for (see earlier for the list),
<tt class="literal">getter</tt> is the name of a public method in the
PropPanel that yields the current entry in the comboBox (of type
<tt class="literal">baseClass</tt>), <tt class="literal">setter</tt> (with a
single argument of type <tt class="literal">baseClass</tt>) sets that entry,
<tt class="literal">allowVoid</tt> if <tt class="literal">true</tt> will allow an
empty entry for the box, <tt class="literal">baseClass</tt> is the NSUML
metaclass from which all entries must descend,
<tt class="literal">useModel</tt> is <tt class="literal">true</tt> to consider all
the elements in the standard profile model for inclusion (so the Java
types, standard stereotypes etc.).
</p><p>
For our <tt class="literal">PropPanelExtend</tt>, we provide a predicate
routine the call for the &#8220;<span class="quote">base</span>&#8221; field is:
</p><p>
<tt class="literal">UMLComboBoxModel(this, "isAcceptableUseCase", "base",
"getBase", "setBase", true, MUseCase.class, true);</tt>
</p><p>
and we define the methods <tt class="literal">isAcceptableUseCase</tt>,
<tt class="literal">getBase</tt> and <tt class="literal">setBase</tt> in
<tt class="literal">PropPanelExtend</tt>.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4797"></a>5.4.1.6.&nbsp;How UMLTextField works</h4></div></div><div></div></div><p>
This information is provided by Jaap Branderhorst (September 2002).
</p><p>
<tt class="classname">UMLTextField</tt> implements several kinds of 
event listeners:
</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="interfacename">MMelementListener</tt></p></li><li><p><tt class="interfacename">DocumentListener</tt></p></li><li><p><tt class="interfacename">FocusListener</tt></p></li></ul></div><p>
Furthermore it is a <tt class="classname">UMLUserInterfaceComponent</tt>.
</p><p>
Since it is an <tt class="classname">UMLUserInterfaceComponent</tt>
it must implement <tt class="methodname">targetChanged</tt> and
<tt class="methodname">targetReasserted</tt>.
<tt class="methodname">TargetChanged</tt> is called everytime the 
<tt class="classname">UMLTextField</tt> is selected. 
<tt class="methodname">targetReasserted</tt> is of no interest for 
<tt class="classname">UMLTextField</tt>.
It plays a role in keeping history but since history 
is not really implemented at the moment in ArgoUML 
it is of no interest.
<tt class="methodname">targetChanged</tt> does two things:
</p><div class="itemizedlist"><ul type="disc"><li><p>
It calls the <tt class="methodname">targetChanged</tt> method 
of the <tt class="classname">UMLTextProperty</tt> this 
<tt class="classname">UMLTextfield</tt> is showing.
</p></li><li><p>
It calls the <tt class="methodname">update</tt> method.
The <tt class="methodname">update</tt> method is described further on.
</p></li></ul></div><p>
</p><p>
Besides <tt class="classname">UMLUserInterfaceComponent</tt>
there are several other interfaces of interest. 
One of them is <tt class="interfacename">MMElementListener</tt>.
</p><p>
Every time a <tt class="interfacename">MModelElement</tt> is
changed this will fire an <tt class="classname">MEvent</tt>
to <tt class="classname">UMLChangeDispatch</tt>.
<tt class="classname">UMLChangeDispatch</tt> will dispatch 
these events to all containers implementing
<tt class="interfacename">UMLUserInterfaceComponents</tt>
interested in this event, including <tt class="classname">UMLTextField</tt>.
It will also dispatch the event to all childs of an interested container
implementing
<tt class="interfacename">UMLUserInterfaceComponent</tt>.
By this it is only necessary to register a 
<tt class="classname">PropPanel</tt> which holds an 
<tt class="classname">UMLTextField</tt> at 
<tt class="classname">UMLChangeDispatch</tt> to
dispatch the event to the <tt class="classname">UMLTextField</tt> too.
<tt class="interfacename">MMelementListener</tt>
knows several methods of which only one is of interest to
<tt class="classname">UMLTextField</tt>s:
</p><div class="itemizedlist"><ul type="disc"><li><p>propertySet</p><p>
Called everytime a property in a 
<tt class="classname">MModelElement</tt> is set. 
This method calls 
<tt class="methodname">update</tt> too if the 
<tt class="classname">UMLTextProperty</tt> really is affected.
</p></li></ul></div><p>
</p><p>
Furthermore <tt class="classname">UMLTextField</tt> implements
<tt class="interfacename">DocumentListener</tt>. 
This is very typical for <tt class="classname">UMLTextField</tt>.
At the moment it is not possible to change the style of
the text in the <tt class="classname">UMLTextField</tt>.
Therefore the method <tt class="methodname">changedUpdate</tt> does not
have a body.
This method is only called when a <tt class="classname">DocumentEvent</tt>
occurs that changes the style/layout of the text.
The methods <tt class="methodname">insertUpdate</tt>
and <tt class="methodname">removeUpdate</tt> are respectively called when a
character is added to the document 
<tt class="classname">UMLTextField</tt> contains or removed. 
Since both methods are called when there is true userinput 
and when the contents of the document are changed programmatically,
the methods distinguish between them.
<tt class="methodname">InsertUpdate</tt> and 
<tt class="methodname">removeUpdate</tt>
are both handled via the protected method 
<tt class="methodname">handleEvent</tt>.
<tt class="methodname">HandleEvent</tt> updates the property in 
<tt class="classname">UMLTextProperty</tt> if it is really changed.
If the update comes via userinput, it is checked if it is valid input. 
If it is not, a <tt class="classname">JOptionPane</tt> is shown with '
a warning and the change is not commited into the model.
If it is not via userinput, the input is not checked and the
property is set. If the property is set, the update method is called.
</p><p>
The implementation of <tt class="interfacename">FocusListener</tt>
makes sure that the checking of userinput only happens when focus is lost.
Otherwise, it would not be possible to enter 'intermediate' values 
that are not legal. 
For instance, say the value class is not legal. 
Without the implementation of <tt class="interfacename">FocusListener</tt>,
it would not be possible to enter classdiagram since
handleEvent would popup a warning messagebox.
</p><p>
The method <tt class="methodname">update</tt> updates both the actual
<tt class="classname">JTextfield</tt> as the diagram as soon
as some property is set. 
The updating of the diagram is done by calling the
<tt class="methodname">damage</tt> method of the figs that
represent the property on the diagram.
</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s03.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch05.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch05s05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.3.&nbsp;Diagrams&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;5.5.&nbsp;Reverse Engineering Component</td></tr></table></div></body></html>