<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>5.17.&nbsp;Module loader</title><link rel="stylesheet" href="look-and-feel.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><link rel="home" href="index.html" title="Cookbook for Developers of ArgoUML"><link rel="up" href="ch05.html" title="Chapter&nbsp;5.&nbsp;Inside the subsystems"><link rel="previous" href="ch05s16.html" title="5.16.&nbsp;Explorer"><link rel="next" href="ch05s18.html" title="5.18.&nbsp;OCL"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5.17.&nbsp;Module loader</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s16.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;5.&nbsp;Inside the subsystems</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch05s18.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="moduleloader"></a>5.17.&nbsp;Module loader</h2></div></div><div></div></div><p>
Purpose - to provide the mechanisms to load (and unload) the Layer 3
and auxiliary modules.
</p><p>
The Module loader will be located in
<tt class="classname">org.argouml.?</tt>.
</p><p>
The Module loader is a Layer 2 subsystem. See <a href="ch04s06.html" title="4.6.&nbsp;Layer 2 - Description of subsystems">Section&nbsp;4.6, &#8220;Layer 2 - Description of subsystems&#8221;</a>.
</p><p>
Currently the module loader is located in
<tt class="classname">org.argouml.application.modules.ModuleLoader</tt>
with interfaces in
<tt class="classname">org.argouml.application.api</tt>.
</p><p>
This handles the enabling and disabling of every module.
</p><p>
An idea on how it could work:
It is then the modules responsibility to connect and register to
the subsystem or subsystems it is going to work with using that
subsystems Facade or Plug-in interface.
</p><p>
For details on how to build a module
see <a href="ch06s02.html" title="6.2.&nbsp;Modules and PlugIns">Section&nbsp;6.2, &#8220;Modules and PlugIns&#8221;</a>.
</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6776"></a>5.17.1.&nbsp;What the ModuleLoader does</h3></div></div><div></div></div><p>
The ModuleLoader is looking for module jars.
It actually scans through all jars available in the ext dir directory.
See Edit Settings Environment tab.
If you turn on logging on the debug level while running ArgoUML
you should be able to see what jar files it finds and what it does with them.
</p><p>
A module jar contains the classes, resources and a manifest file.
The manifest file points out the classes to be loaded.
Also notice that the Specification-Title and Vendor must be specified
correctly for this to work.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6783"></a>5.17.2.&nbsp;Design of a new Module Loader</h3></div></div><div></div></div><p>
In an attempt to improve the Module Loader to make it more flexible a
new design is suggested.
This section describes the plan and will become the design documentation
once some code is developed.
</p><p>
The plan is to implement this new Module Loader, then have them both
working side by side for several releases (two stable releases),
and if all are happy with it, then remove the old module loader.
</p><p>
Design:
          </p><div class="itemizedlist"><ul type="disc"><li><p>
We use a Loadable Proxy Pattern(?) for the modules.
Each module is required to have one (1) class that implements 
the module loader interface.
That class (and all other classes that constitute the module)
needs to be made available for some classloader, either by including
it in the classpath or by letting the module loader hunt for it in the
same manner as the old class loader does.
</p></li><li><p>
The modules are allowed to use all the APIs available from all
the subsystems within ArgoUML and from other modules.
</p><p>
This is the big improvement in that:
                </p><div class="itemizedlist"><ul type="circle"><li><p>
We can use the same APIs for the modules that we use within ArgoUML.
We don't need to have a special Pluggable class for every possible
point where ArgoUML can be augmented.
</p></li><li><p>
We can have the module have different classes to register at different
parts of ArgoUML.
</p></li><li><p>
We can have dynamic registrations that the module add and remove over time
depending on some criteria that the module decides.
</p></li><li><p>
We don't need to search through all modules at every possible point
where ArgoUML can be augmented.
</p></li></ul></div><p>
But it means that whenever a module needs to do something to ArgoUML,
there needs to be implemented an API,
possibly with registration/deregistration and callbacks.
</p></li><li><p>
The new Module loader will be in located in
<tt class="classname">org.argouml.moduleloader</tt>.
</p></li><li><p>
All modules that can be found are examined at startup.
They can be enabled and disabled individually from a special 
available modules window but have a default state that applies if 
the user hasn't taken action.
</p></li><li><p>
Dependency between modules!
</p><p>
If a module cannot be enabled
because some other module needs to be enabled first or
because some part of ArgoUML needs to be initialized first
this is a problem since the plan is not to have any register of dependencies.
</p><p>
The suggested solution is that the module loader persists 
in it's attempts to enable a module so that the order is not important.
For this to work the modules needs to signal when they fail. 
This is done by returning false or throwing a Exception from 
the module enabling method.
</p><p>
The module loader also provides an API that the well-behaving modules can
use to test if the modules they depend on are enabled.
The less well-behaving module can just throw an exception when they fail
to enable themselves properly.
</p><p>
If a module cannot be disabled, because some other module depends on it
then this is signaled by returning false from the disabling method.
</p></li></ul></div><p>
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s16.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch05.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch05s18.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.16.&nbsp;Explorer&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;5.18.&nbsp;OCL</td></tr></table></div></body></html>