<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>6.2.&nbsp;Modules and PlugIns</title><link rel="stylesheet" href="look-and-feel.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.66.1"><link rel="start" href="index.html" title="Cookbook for Developers of ArgoUML"><link rel="up" href="ch06.html" title="Chapter&nbsp;6.&nbsp;Extending ArgoUML"><link rel="prev" href="ch06.html" title="Chapter&nbsp;6.&nbsp;Extending ArgoUML"><link rel="next" href="ch06s03.html" title="6.3.&nbsp;How are modules organized in the java code"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">6.2.&nbsp;Modules and PlugIns</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch06.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;6.&nbsp;Extending ArgoUML</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch06s03.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="modules_and_plugins"></a>6.2.&nbsp;Modules and PlugIns</h2></div></div></div><p>
The ArgoUML tool provides a basis
for UML design and potentially an executable architecture 
environment for more specialized applications.
This is solved by a clear interfaces between the ArgoUML core
and the extensions.
Extensions are called modules.
</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="modules_vs_plugins"></a>6.2.1.&nbsp;Differences between modules and plugins</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
This description is only relevant for the old moduleloader
since the plugins concept is not used in the new one.
</p></td></tr></table></div><p>
In the old moduleloader implementation the classes within the modules
that attach to ArgoUML core are called plugins.
In the new moduleloader implementation they don't have any special name.
</p><p>
</p><div class="itemizedlist"><ul type="disc"><li><p>Modules</p><p>
A module is a collection of classes and resource files that can
be enabled and disabled in ArgoUML.
Currently this is decided by the modules' availability when ArgoUML starts 
but in the future it could be made possible to enable modules from within 
a running ArgoUML.
</p><p>
This module system is the extension capability to the ArgoUML tool. 
It will give developers of ArgoUML and 
developers of applications running within the ArgoUML architecture
the ability to add
additional functionality to the ArgoUML environment
without modifying the basic ArgoUML tool.
This flexibility should encourage
additional open source and/or commercial involvement
with the open source UML tool.  
</p><p>
The module extensions will load when ArgoUML starts.
When the modules are loaded
they have the capability of attaching
to internal ArgoUML architectural elements.
Once the plugins are attached,
the plugins will receive calls at the right moment and
can perform the correct action at that point.
</p><p>
Modules can be internal and external.
The only difference is that the internal modules are part of
the <tt class="filename">argouml.jar</tt> and the external are
delivered as separate jar-files.
</p></li><li><p>Plugins</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
This description is for the old moduleloader.
</p></td></tr></table></div><p>
A plug-in in ArgoUML is a module
that implements the
<tt class="classname">org.argouml.application.api.Pluggable</tt> interface.
</p><p>
The <tt class="classname">Pluggable</tt> interface
acts as a passive dynamic component,
i.e. it provides methods to simplify the attaching
of calls at the correct places.
There are several <tt class="classname">Pluggable</tt> interfaces
that each simplify the addition of one kind of object.
Examples <tt class="classname">PluggableMenu</tt>, 
<tt class="classname">PluggableNotation</tt>.
</p><p>
One Module can implement several <tt class="classname">Pluggable</tt> interfaces.
</p></li></ul></div><p>
</p><p>
This is essentially and implementation of the Dynamic Linkage pattern 
as described in
Patterns in Java Volume 1 by Mark Grand ISBN 0-471-25839-3.
The whole of ArgoUML Core is the Environment,
the classes inheriting <tt class="classname">Pluggable</tt> are the
AbstractLoadableClass.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="modules"></a>6.2.2.&nbsp;Modules</h3></div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="architecture_modules"></a>6.2.2.1.&nbsp;Module Architecture for the old implementation</h4></div></div></div><p>
The controlling class of the module/plugin extension
is <tt class="classname">org.argouml.application.modules.ModuleLoader</tt>.
<tt class="classname">ModuleLoader</tt> is a singleton
created in the ArgoUML main initialization routine.

</p><p>
<tt class="classname">ModuleLoader</tt> will:

</p><div class="itemizedlist"><ul type="disc"><li><p>read in the property file</p></li><li><p>for each of the classes found</p><div class="orderedlist"><ol type="1"><li><p>create the specified classes</p></li><li><p>call <tt class="methodname">initializeModule</tt> on this class</p></li><li><p>place the class object into the
internal list of modules</p></li></ol></div></li></ul></div><p>
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="argomodule_interface"></a>6.2.2.2.&nbsp;The ArgoModule interface - used in the old implementation</h4></div></div></div><p>
Each class must derive from the <tt class="classname">ArgoModule</tt> interface.
This interface provides the following methods:
</p><div class="itemizedlist"><ul type="disc"><li><div class="funcsynopsis"><p></p><p><code class="funcdef">
String <b class="fsfunc">getModuleName</b>
(</code><code>void)</code>;</p><p></p></div><div class="funcsynopsis"><p></p><p><code class="funcdef">
String <b class="fsfunc">getModuleDescription</b>
(</code><code>void)</code>;</p><p></p></div><div class="funcsynopsis"><p></p><p><code class="funcdef">
String <b class="fsfunc">getModuleVersion</b>
(</code><code>void)</code>;</p><p></p></div><div class="funcsynopsis"><p></p><p><code class="funcdef">
String <b class="fsfunc">getModuleAuthor</b>
(</code><code>void)</code>;</p><p></p></div><p>provides information about the ArgoUML module.  
</p></li><li><div class="funcsynopsis"><p></p><p><code class="funcdef">
boolean <b class="fsfunc">initializeModule</b>
(</code><code>void)</code>;</p><p></p></div><p><tt class="function">initializeModule</tt> is called
when the class loader has created the module,
and before it is added into the modules list.
<tt class="function">initializeModule</tt> should
initialize any required data
and/or attach itself as a listener to ArgoUML actions.
<tt class="classname">initializeModule</tt> for all modules is invoked
after the rest of ArgoUML has been initialized and loaded.
Any menu modifications or system level resources
should already be available
when the module initialization process is called.  
</p><p>
<tt class="function">initializeModule</tt>
should return <span class="returnvalue">true</span>
if the initialization is successful
(or if no initialization is necessary).
</p><p>
The only available mechanism for handling dependencies between
modules is the order in which they are read from the file.
</p></li><li><div class="funcsynopsis"><p></p><p><code class="funcdef">
void <b class="fsfunc">shutdownModule</b>
(</code><code>void)</code>;</p><p></p></div><p>
The <tt class="function">shutdownModule</tt> method is called
when the module is removed.
It provides each module the capability
to clean up or save any required information
before being cleared from memory.  
</p></li><li><div class="funcsynopsis"><p></p><p><code class="funcdef">
void <b class="fsfunc">setModuleEnabled</b>
(</code>boolean <var class="pdparam">tf</var><code>)</code>;</p><p></p></div><div class="funcsynopsis"><p></p><p><code class="funcdef">
boolean <b class="fsfunc">isModuleEnabled</b>
(</code><code>void)</code>;</p><p></p></div><p>
	Reserved for future implementation.
</p></li><li><div class="funcsynopsis"><p></p><p><code class="funcdef">
Vector <b class="fsfunc">getModulePopUpActions</b>
(</code><code>void)</code>;</p><p></p></div><p>
	Reserved for future implementation.
</p><p>
The plan is to have this called for each module when
the module should add its entries in PopUpActions.
</p></li><li><div class="funcsynopsis"><p></p><p><code class="funcdef">
String <b class="fsfunc">getModuleKey</b>
(</code><code>void)</code>;</p><p></p></div><p>Returns a string that identifies the module.
</p></li></ul></div><p>
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7441"></a>6.2.2.3.&nbsp;Module Architecture for the new implementation</h4></div></div></div><p>
The controlling class for the new implementation is
<tt class="classname">org.argouml.moduleloader.ModuleLoader2</tt>.
It is a singleton created when first used.
It is first used in the main initialization routine.
</p><p>
When created it searches through all available modules and creates
a list of their main objects
(implementing <tt class="classname">ModuleInterface</tt>).
Currently (September 2004) this also means that the found modules are
by default selected i.e. they are marked to be enabled.
</p><p>
At the end of the main initialization routine
the selected modules are enabled.
(The original idea was to do this several times during the main routine
to allow for modules to
add command line arguments,
add languages, and
make functions available for batch command,
but the example used for testing loaded the ProjectBrowser "too early"

and the result wasn't so good.
I (Linus) hopes this can be eventually fixed.)
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7458"></a>6.2.2.4.&nbsp;The ModuleInterface interface - in the new implementation</h4></div></div></div><p>
Each class used by the <tt class="classname">ModuleLoader2</tt>
must implement the <tt class="classname">ModuleInterface</tt> interface.
</p><p>
This interface has methods for
enabling,
disabling and
identifying
the module.
</p><p>
When a module is enabled it is expected to register some class
wherever it affects ArgoUML using the interfaces provided there.
Since the same interfaces and registration mechanism is used internally
within ArgoUML there is a small likelyhood that there already is
an interface and a possibility to register.
If there isn't, ArgoUML cannot currently be extended
at that point.
If you still need ArgoUML to be extended at that point you will have to
work in getting this interface or registration mechanism implemented within
ArgoUML.
(This could also be another module that has to be amended.)
</p><p>
Classes administered by the module that registers to whatever
place of ArgoUML they are interested in, does not need to have any
connection to the module loader.
They are written exactly as if they would have been if they were
part of the core ArgoUML.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="using_modules"></a>6.2.2.5.&nbsp;Using Modules</h4></div></div></div><p>
When modules are used they can't be distinguished from the
rest of the ArgoUML environment.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="howdoi_modules"></a>6.2.2.6.&nbsp;How do I ...?</h4></div></div></div><p>
</p><div class="itemizedlist"><ul type="disc"><li><p>...tell when a module is enabled?</p><p>
The method <tt class="methodname">isEnabled</tt>
in <tt class="classname">ModuleLoader2</tt>
returns true if the module with that name is enabled and false otherwise.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
This only works for modules enabled in the new module loader.
For modules loaded using the old module loader, it is not possible
to determine if they are enabled.
</p></td></tr></table></div></li></ul></div><p>
</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="plugins"></a>6.2.3.&nbsp;Plugins</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
This description is for the old moduleloader.
</p></td></tr></table></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="architecture_plugins"></a>6.2.3.1.&nbsp;Plugin Architecture</h4></div></div></div><p>
Each class must derive from the <tt class="classname">Pluggable</tt> interface.
In addition to the methods declared in <tt class="classname">ArgoModule</tt>,
which <tt class="classname">Pluggable</tt> extends
(see <a href="ch06s02.html#argomodule_interface" title="6.2.2.2.&nbsp;The ArgoModule interface - used in the old implementation">Section&nbsp;6.2.2.2, &#8220;The ArgoModule interface - used in the old implementation&#8221;</a>),
the interface provides the following method:

</p><div class="itemizedlist"><ul type="disc"><li><div class="funcsynopsis"><p></p><p><code class="funcdef">
boolean <b class="fsfunc">inContext</b>
(</code>Object[] <var class="pdparam">context</var><code>)</code>;</p><p></p></div><p>
<tt class="function">inContext</tt> allows a plug-in to decide
if it is available under a specific context. 
</p></li></ul></div><p>
</p><p>
One example of a plugin with multiple criteria is the PluggableMenu.
PluggableMenu requires the first context to be a JMenuItem
which wants the PluggableMenu attached to as the context,
so that it can determine that it would attach to a menu.  The
second context is an internal (non-localized) description 
of the menu such as "File" or "View"
so that the plugin can further decide.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="howdoi_plugins"></a>6.2.3.2.&nbsp;How do I ...?</h4></div></div></div><p>

</p><div class="itemizedlist"><ul type="disc"><li><p>...create a pluggable settings tab?</p><p>...</p></li><li><p>...create a pluggable menu item?</p><p>
Look at the modules junit and menutest for examples of how to add to
menus using the PluggableMenu interface.
</p><p>
The implementation of inContext() that you provide should be similar to: 
</p><pre class="programlisting">
    public boolean inContext(Object[] o) { 
        if (o.length &lt; 2) return false; 
        if ((o[0] instanceof JMenuItem) &amp;&amp; 
                ("Create Diagrams".equals(o[1]))) { 
            return true; 
        } 
        return false; 
    }
</pre><p>
</p><p>
The string "Create Diagrams" is a non-localized key string passed in
ProjectLoader at about line 440 in the statement
</p><pre class="programlisting">
    appendPluggableMenus(_createDiagrams, "Create Diagrams"); 
</pre><p>

There is no restriction on a single class implementing multiple
plugins - quite the contrary, that is one of the reasons for providing
the generic Pluggable interface that PluggableThings extend.
</p></li><li><p>...create a pluggable notation?</p><p>...</p></li><li><p>...create a pluggable diagram?</p><p>
Let's say we want to enable a new diagram type as a plug-in.
We use the interface PluggableDiagram that uses a
method that returns an JMenuItem object:

</p><pre class="programlisting">
    public JMenuItem getDiagramMenuItem();
</pre><p>

The returned menu item will be added to the diagrams menu
to allow to open a new diagram of this type.
</p><p>
In this example we do this by creating a helper class in the package
org.argouml.application.helpers that implements the created
plug-in interface PluggableDiagram, and call it DiagramHelper:

</p><pre class="programlisting">
public abstract class DiagramHelper extends ArgoDiagram
implements PluggableDiagram {

    /** Default localization key for diagrams
     */
    public final static String DIAGRAM_BUNDLE = "DiagramType";

    /** String naming the resource bundle to use for localization.
     */
    protected String _bundle = "";

    public DiagramHelper() {
        _bundle = getDiagramResourceBundleKey();
    }

    public void setModuleEnabled(boolean v) { }

    public boolean initializeModule() { return true; }

    public boolean inContext(Object[] o) { return true; }

    public boolean isModuleEnabled() { return true; }

    public Vector getModulePopUpActions(Vector v, Object o) { return null; }

    public boolean shutdownModule() { return true; }

    public JMenuItem getDiagramMenuItem()
    {
        return new JMenuItem(Argo.localize(_bundle,"diagram_type"));
    }

    public String getDiagramResourceBundleKey() {
        return DIAGRAM_BUNDLE;
    }
}

</pre><p>
The extension of ArgoDiagram is specific to this example;
the plug-in will provide a new ArgoUML diagram.

</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td colspan="2" align="left" valign="top"><p>
Don't forget to do the localization stuff, because the
plug-in might be used in all languages ArgoUML offers!
</p></td></tr></table></div><p>

</p></li><li><p>
...do the localization stuff (not plug-in specific, but important)?
</p><p>...</p></li><li><p>...create a pluggable resource bundle?</p><p>...</p></li><li><p>...create a new pluggable type?</p><p>
</p><div class="orderedlist"><ol type="1"><li><p>
Create the plug-ins interface
</p><p>

In the package org.argouml.application.api, create an
interface that extends <tt class="classname">Pluggable</tt> (in the same package).
The class name must begin with 'Pluggable'.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
One of the main purposes of a plugin is
to provide the capability to add an externally defined class
that will be used by ArgoUML in the same way as a similar internal class.
This means that modifications are needed all over ArgoUML
in order to call the pluggable interface.
Therefore this must be done in ArgoUML itself and 
cannot be done in any module.
</p></td></tr></table></div><p>
</p><p>
It now inherits from <tt class="classname">ArgoModule</tt> the methods
</p><pre class="programlisting">
    public boolean initializeModule();
    
    public boolean shutdownModule();

    public void setModuleEnabled(boolean tf);
    
    public boolean isModuleEnabled();

    public String getModuleName();

    public String getModuleDescription(); 
    
    public String getModuleVersion(); 
    
    public String getModuleAuthor(); 
    
    public Vector getModulePopUpActions(Vector popUpActions, Object context);

    public String getModuleKey();
</pre><p>

and from <tt class="classname">Pluggable</tt> the methods

</p><pre class="programlisting">

    public boolean inContext(Object[] context);

</pre><p>

and thus provides the basic mechanism that plug-ins need.
</p></li><li><p>
Decide in what context this is to be enabled and add calls there
</p><p>
It is useful for those plugins which actually use context
to provide a helper method

</p><div class="funcsynopsis"><p></p><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">
Object[] <b class="fsfunc">buildContext</b>
(</code></td><td>classtype1 &nbsp;</td><td><var class="pdparam">parameter1</var>, </td></tr><tr><td>&nbsp;</td><td>classtype2 &nbsp;</td><td><var class="pdparam">parameter2</var><code>)</code>;</td></tr></table><p></p></div><p>
which will serve two purposes.
</p><p>
First, it will provide a simple way of creating the Object[] parameter.
</p><p>
Second, it helps to document the context parameters within the class itself.
</p><p>
Again using <tt class="classname">PluggableMenu</tt> as an example,
it contains the function

</p><pre class="programlisting">

    public Object[] buildContext(JMenuItem parentMenuItem, String menuType);

</pre><p>

which is used as follows:

</p><pre class="programlisting">
    if (module.inContext(module.buildContext(_help, "Help"))) {
        _help.add(module.getMenuItem(_help, "Help"));
    }
</pre><p>
</p></li></ol></div><p>

</p></li></ul></div><p>

</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7674"></a>6.2.4.&nbsp;Tip for creating new modules (from Florent de Lamotte)</h3></div></div></div><a class="indexterm" name="d0e7677"></a><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
This description is for the old moduleloader.
</p></td></tr></table></div><p>Florent wrote a small tutorial for creating modules. It can be found on the <a href="http://argopno.tigris.org/documentation/argouml.html" target="_top">ArgoPNO website</a>.
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch06.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch06.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch06s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;6.&nbsp;Extending ArgoUML&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;6.3.&nbsp;How are modules organized in the java code</td></tr></table></div></body></html>