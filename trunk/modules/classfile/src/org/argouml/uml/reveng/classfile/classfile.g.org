header {
package org.argouml.uml.reveng.classfile;

import antlr.*;
import antlr.collections.*;
}   
/*
 * Java Classfile parser.
 *
 * Contributing authors:
 *     Andreas Rueckert <a_rueckert@gmx.net>
 */

/********************************
 * A parser for a Java classfile.
 ********************************/
class ClassfileParser extends Parser;

options { 
	exportVocab=Classfile;
	defaultErrorHandler = false;       // Don't generate parser error handlers
        buildAST = true;     
}

tokens {
	ACCESS_MODIFIERS;
	ATTRIBUTE_NAME;
	CLASS_NAME;
	CONSTANT_CLASSINFO;  
	CONSTANT_FIELDINFO; 
	CONSTANT_METHODINFO;
	CONSTANT_NAME_TYPE_INFO;
	CONSTANT_UTF8STRING;
	MAGIC; 
	SOURCEFILE;
	VERSION; 
}

{
	// Constants as defined in the JVM classfile specs.
	public static final byte CONSTANT_Class 		=  7; 
 	public static final byte CONSTANT_Fieldref 		=  9; 
 	public static final byte CONSTANT_Methodref 		= 10;
 	public static final byte CONSTANT_InterfaceMethodref 	= 11;
 	public static final byte CONSTANT_String 		=  8;
 	public static final byte CONSTANT_Integer 		=  3; 
 	public static final byte CONSTANT_Float 		=  4; 
 	public static final byte CONSTANT_Long 	 		=  5; 
 	public static final byte CONSTANT_Double 		=  6;
 	public static final byte CONSTANT_NameAndType 		= 12;
 	public static final byte CONSTANT_Utf8 			=  1;

	// Access flags as defined in the JVM specs.
 	public static final short ACC_PUBLIC    = 0x0001;
        public static final short ACC_FINAL     = 0x0010;
        public static final short ACC_SUPER     = 0x0020;
        public static final short ACC_INTERFACE = 0x0200;
        public static final short ACC_ABSTRACT  = 0x0400;

	// A array buffer for the constant pool.
	private AST [] _constant = null;

	// The number of constants in the buffer (0 is reserved for the JVM).
	private int _constantCount = 1;

	/**
	 * Init the buffer for a given number of AST nodes.
	 *
	 * @param size The number of AST nodes.
	 */
	private void initPoolBuffer(int size) {
	    _constant = new AST[size];
	}	

	/**
	 * Add a AST holding a constant to the buffer.
	 *
	 * @param node The AST node with the constant info.
	 */
	private void copyConstant(AST node) {
	    _constant[_constantCount++] = astFactory.dupTree(node);
	}

	/**
	 * Get a constant from the buffer.
	 *
	 * @param index The index of the node in the buffer.
	 *
	 * @return The AST at the given position.
	 */
	private AST getConstant(int index) {
	    return _constant[index];
	}
}

// The entire classfile
classfile
	: magic_number
	  version_number
	  constant_pool
	  access_modifiers
	  class_info
	  superclass_info
	  interface_block
	  field_block
	  method_block
	  attribute_block
        ;

// The magic number 0xCAFEBABE, every classfile starts with
magic_number!
{ int magic=0; } 
	: magic=u4 {magic==0xcafebabe}? { #magic_number = #[MAGIC,Integer.toHexString(magic)]; }
	;

// The version number.
version_number!
{ short minor=0,major=0; String verStr=null; }
	: minor=u2 major=u2 { verStr = ""+major+"."+minor; #version_number = #[VERSION,verStr]; }
	;

// The constant pool.
constant_pool!
{ short poolSize=0; int index=1; }
	: poolSize=u2 { initPoolBuffer(poolSize); System.out.println("Entries in CP: "+(poolSize-1)); }  // Parse the size of the constant pool + 1
	  ( {--poolSize > 0}? cp:cp_info { copyConstant(#cp); } )* {poolSize==0}?  	// Parse <poolSize-1> cp_info structures.
	;

// Info on a entry in the constant pool
cp_info!
{ byte tag=0; }
	: tag=u1  // This tag does actually belong to the *info structures according to the 
                  // classfile specs. Put putting it into the *info rules might cause quite
	          // a bit of guessing and backtracking, which might cause performance issues.
                  // So I check it, before the actual *info structures are parsed.
	  (      
	    {tag == CONSTANT_Class}?                cl:constant_class_info               {#cp_info=#cl;}
	    | {tag == CONSTANT_Fieldref}?           cf:constant_fieldref_info            {#cp_info=#cf;}
	    | {tag == CONSTANT_Methodref}?          cm:constant_methodref_info           {#cp_info=#cm;}
 	    | {tag == CONSTANT_InterfaceMethodref}? ci:constant_interface_methodref_info {#cp_info=#ci;}
 	    | {tag == CONSTANT_String}?             cs:constant_string_info              {#cp_info=#cs;}          
 	    | {tag == CONSTANT_Integer}?            ct:constant_integer_info             {#cp_info=#ct;}
 	    | {tag == CONSTANT_Float}?              ca:constant_float_info               {#cp_info=#ca;}
 	    | {tag == CONSTANT_Long}?               co:constant_long_info                {#cp_info=#co;}
 	    | {tag == CONSTANT_Double}?             cd:constant_double_info              {#cp_info=#cd;}
 	    | {tag == CONSTANT_NameAndType}?        cn:constant_name_and_type_info       {#cp_info=#cn;}
 	    | {tag == CONSTANT_Utf8}?               cu:constant_utf8_info                {#cp_info=#cu;}
	  )
	;

// Info on a class in the constant pool.
constant_class_info!
{ short name_index=0; }
	: name_index=u2  // Missing tag (according to the classfile specs)! See the cp_info rule!
	  { 
	    // System.out.println("Found class info at index: " + Integer.toString((int)name_index & 0xffff));
	    // String indexStr = Integer.toString((int)name_index & 0xffff);  // A string representation of the index.
            // #constant_class_info = #[CONSTANT_CLASSINFO, indexStr];
	    #constant_class_info = new ShortAST( CONSTANT_CLASSINFO, name_index);
          }
	;

// Info on a field in the constant pool.
constant_fieldref_info!
{
  short class_index=0;
  short name_and_type_index=0;
}
	: class_index=u2  // Missing tag (according to the classfile specs)! See the cp_info rule!
	  name_and_type_index=u2  
	  { 
	    // System.out.println("Found fieldref with class at: " + class_index + " and type " + name_and_type_index); 
	    String classStr = Integer.toString((int)class_index & 0xffff);
	    String nameTypeStr = Integer.toString((int)name_and_type_index & 0xffff);
	    #constant_fieldref_info = #([CONSTANT_FIELDINFO,classStr], [CONSTANT_NAME_TYPE_INFO, nameTypeStr]);
          }
	;

// Info on a class method in the constant pool.
constant_methodref_info!
{
  short class_index=0;
  short name_and_type_index=0;
}
	: class_index=u2  // Missing tag (according to the classfile specs)! See the cp_info rule!
	  name_and_type_index=u2 
	  { 
	    // System.out.println("Found method ref with class at: " + class_index + " and type " + name_and_type_index); 
	    String classStr = Integer.toString((int)class_index & 0xffff);
	    String nameTypeStr = Integer.toString((int)name_and_type_index & 0xffff);
	    #constant_methodref_info = #([CONSTANT_METHODINFO,classStr], [CONSTANT_NAME_TYPE_INFO, nameTypeStr]);
	  }
	;

// Info on a interface method in the constant pool.
constant_interface_methodref_info!
{
  short class_index=0;
  short name_and_type_index=0;
}
	: class_index=u2  // Missing tag (according to the classfile specs)! See the cp_info rule!
	  name_and_type_index=u2 // { System.out.println("Found interface ref with class at: " + class_index + " and type " + name_and_type_index); }
	;

// Info on a string in the constant pool.
constant_string_info!
{ int string_index=0; }
	: string_index=u2  // Missing tag (according to the classfile specs)! See the cp_info rule!
	  // { System.out.println("Found string info at index: " + string_index); }
	;

// Info on a string in the constant pool.
constant_integer_info!
{ int val=0; }
	: val=u4  // Missing tag (according to the classfile specs)! See the cp_info rule!
	  // { System.out.println("Found integer info: " + val); }
	;

// Info on a float in the constant pool.
constant_float_info!
{ int bytes=0; float val=0; }
	: bytes=u4  // Missing tag (according to the classfile specs)! See the cp_info rule!
	  { val = Float.intBitsToFloat(bytes); }
	;

// Info on a long in the constant pool.
constant_long_info!
{ int high_bytes=0, low_bytes=0; long val = 0L; }
	: high_bytes=u4 low_bytes=u4  // Missing tag (according to the classfile specs)! See the cp_info rule!
	  { val = (long)high_bytes | ((long)low_bytes & 0xFFFFL); }
	;

// Info on a double in the constant pool.
constant_double_info!
{ int high_bytes=0, low_bytes=0; double val = 0; }
	: high_bytes=u4 low_bytes=u4  // Missing tag (according to the classfile specs)! See the cp_info rule!
	  { val = Double.longBitsToDouble( (long)high_bytes | ((long)low_bytes & 0xFFFFL)); }
	;

// Info on name and type.
constant_name_and_type_info!
{ short name_index=0, descriptor_index=0; }
	: name_index=u2
	  descriptor_index=u2  // Missing tag (according to the classfile specs)! See the cp_info rule!
	  // { System.out.println("Found constant info at: " + name_index + " with descriptor at: " + descriptor_index); }
	;

// A UTF8 encoded string in the constant pool.
constant_utf8_info!
{
  short length=0;
  byte [] bytes;
  byte bytebuf=0;
  int bytepos=0;
}
	: length=u2 { bytes = new byte[length]; }  // Missing tag (according to the classfile specs)! See the cp_info rule!
	  ( {length > 0}? bytebuf=u1 { bytes[bytepos++] = bytebuf; length--; } )* {length==0}? 
	  { 
            String name = new String(bytes);
	    name= name.replace('/','.'); 
	    if(name.startsWith("[") && name.endsWith("]")) {
		name = name.substring(1,name.length()-1) + " []";
	    }
	    #constant_utf8_info = #[CONSTANT_UTF8STRING,name];
	    // System.out.println("Found UTF8 String: " + name); 
          }
	;

// Access modifiers for the class
access_modifiers!
{ short modifiers=0; }
	: modifiers=u2 
	  { 
            String accessString = "" + modifiers;
	    #access_modifiers = #[ACCESS_MODIFIERS,accessString]; 
	    // System.out.println("Access modifiers: " + Integer.toHexString(modifiers)); 
	  }
	;

// Info on the main class
class_info!
{ short class_info_index = 0; }  	// A index of a entry in the constant pool.
	: class_info_index=u2  
	  { 
	    // System.out.println("Class info at index: " + class_info_index); 
	    ShortAST class_info = (ShortAST)getConstant((int)class_info_index & 0xffff);
	    // int class_name_index = Integer.parseInt(class_info.getText());
	    // String class_name = getConstant(class_name_index).getText();
            String class_name = getConstant(class_info.getShortValue()).getText();
	    #class_info = #[CLASS_NAME, class_name];
	  }
	;

// Info on the super class
superclass_info!
{ short class_info_index = 0; }   // A index of a entry in the constant pool.
	: class_info_index=u2
	  { 
  	    // System.out.println("Superclass info at index: " + class_info_index);
	    #superclass_info = getConstant((int)class_info_index & 0xffff);
	  }
	;

// Info on the implemented interfaces
interface_block
{ short interfaces_count=0; }
	: interfaces_count=u2  { /* System.out.println("Number of interfaces in file: " + interfaces_count); */ }	// Get the number of implemented interfaces.
 	  ( {interfaces_count > 0}? interface_info {interfaces_count--;} )* {interfaces_count==0}?  	// Parse <interfaces_count> interface_info structures.
	;

// Info on a interface.
interface_info
{ int interface_index=0; }
	: interface_index=u2  	// A valid index into the constant_pool table, that references a CONSTANT_Class_info structure.
	  { System.out.println("Parsing interface"); }
	;

// Info on all the fields of this class.
field_block
{ short fields_count=0; }
	: fields_count=u2  { /* System.out.println("Number of fields in file: " + fields_count); */ }	 // Get the number of fields.
	  ( {fields_count > 0}? field_info {fields_count--;})* {fields_count==0}?		// Parse <fields_count> field_info structures.
	;

// Info on a field.
field_info
{
  short access_flags=0;
  short name_index=0;
  short descriptor_index=0;
  short attributes_count;
}
	: access_flags=u2
	  name_index=u2
	  descriptor_index=u2
          attributes_count=u2
	  ( {attributes_count > 0}? attribute_info {attributes_count--;})* {attributes_count==0}?
	;

// Info on all the methods of this class.
method_block
{ int methods_count=0; }
	: methods_count=u2  { /* System.out.println("Number of methods in file: " + methods_count); */ } // Get the number of methods.
	  ( {methods_count > 0}? method_info {methods_count--;})* {methods_count==0}?		// Parse <methods_count> method_info structures.
	;

// Info on a method.
method_info
{
  short access_flags=0;
  short name_index=0;
  short descriptor_index=0;
  short attributes_count=0;
}
	: access_flags=u2
          name_index=u2  { /* System.out.println("Method name at index: " + name_index); */ }
	  descriptor_index=u2
	  attributes_count=u2 // { System.out.println("Number of method attributes in file: " + attributes_count); }	
	  ( {attributes_count > 0}? attribute_info {attributes_count--;})* {attributes_count==0}?
	;

// Info on all the attributes of a class.
attribute_block
{ int attributes_count=0; }
	: attributes_count=u2  { /* System.out.println("Number of attributes in file: " + attributes_count); */ }		// Get the number of attributes.
	  ( {attributes_count > 0}? attribute_info {attributes_count--;})* {attributes_count==0}?	// Parse <attributes_count> attribute_info structures.
	;

// Info on a attribute
attribute_info!
{
  short attribute_name_index=0;
  int attribute_length=0;
  String attribute_name=null;
  byte [] info;
  int bytepos=0;
  byte bytebuf=0;
  short sourcefile_index = 0;
  String sourcefile_name = null;
}
	: attribute_name_index=u2 { attribute_name = getConstant((int)attribute_name_index & 0xffff).getText(); }
	  attribute_length=u4 
	  (
	    // The classfile specs define a few special class attributes, that give additional info
	    // on things like the filename of the sourcecode etc.

	    ( // Check if this attribute holds the name of the sourcecode file.
	      {attribute_length=2 && "SourceFile".equals(attribute_name)}? 
	      sourcefile_index=u2 { sourcefile_name = getConstant((int)sourcefile_index & 0xffff).getText(); }
	      #attribute_info = #[SOURCEFILE, sourcefile_name];
	    )

	    |

	    (
	      { info = new byte[attribute_length]; }
	      ( {bytepos < attribute_length}? bytebuf=u1 {info[bytepos++] = bytebuf;} )* {bytepos==attribute_length}?
	      #attribute_info = #[ATTRIBUTE_NAME, attribute_name];
	    )
          )
	;


//////////////////////
// Some utility rules.
//////////////////////

// A 1 byte int
u1! returns [byte res=0]
	: val:BYTE { res = (byte)(val.getText().charAt(0)); }
	;

// A 2 byte int
u2! returns [short res=0]
{ short high=0,low=0; }
	: ( high=u1 low=u1 ) { res = (short)((high << 8) + (low & 0xFF)); }  // The u1 byte result is signed, so I have to mask the
									     // lsb with 0xFF to remove the sign extension after the casting!
	;

// A 4 byte int
u4! returns [int res=0]
{ int high=0,low=0; }
	: ( high=u2 low=u2 ) { res = (high << 16) + (low & 0x0000FFFF); }  // Masquerading required after (int)u2 cast!
	;

/******************************
 * A lexer to scan a bytestream
 ******************************/
class ByteLexer extends Lexer;
options { charVocabulary = '\u0000'..'\u00FF'; }

BYTE : .
     ;                      
