<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE book SYSTEM "../docbook-setup/docbookx/docbookx.dtd" [
<!ENTITY cookbookmodules SYSTEM "cookbook_modules.xml">
<!ENTITY cookbooklogging SYSTEM "cookbook_logging.xml">
]>

<!-- THIS IS THE ARGO/UML DEVELOPER COOKBOOK 
     - PLEASE FEEL FREE TO ADD TO THE CONTENT AND INSERT YOUR 
     NAME IN THE AUTHOR GROUP.
     - IMAGES SHOULD BE LOCATED IN THE GENERAL IMAGES SECTION OF THE 
     DOCUMENTATION MODULE UNDER THE DIRECTORY COOKBOOK
     - PLEASE VERIFY THAT YOUR CHANGES COMPILE CORRECTLY BEFORE COMMITING THEM
-->
     
<book>
     <bookinfo>
         <date>2001-11-10
         </date>
         <title>ArgoUML Programmers Cookbook</title>
         <subtitle>An introduction to ArgoUML Programming</subtitle>
         <authorgroup>
             <author>
                 <firstname>Markus</firstname>
                 <surname>Klink</surname>
             </author>
             <author>
                 <firstname>Linus</firstname>
                 <surname>Tolke</surname>
             </author>
         </authorgroup>
         <legalnotice>
             <para>
 Copyright (c) 1996-2001 The Regents of the University of California. All
 Rights Reserved. Permission to use, copy, modify, and distribute this
 software and its documentation without fee, and without a written
 agreement is hereby granted, provided that the above copyright notice
 and this paragraph appear in all copies.  This software program and
 documentation are copyrighted by The Regents of the University of
 California. The software program and documentation are supplied "AS
 IS", without any accompanying services from The Regents. The Regents
 does not warrant that the operation of the program will be
 uninterrupted or error-free. The end-user understands that the program
 was developed for research purposes and is advised not to rely
 exclusively on the program for any reason.  IN NO EVENT SHALL THE
 UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
 SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
 ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
 WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
 PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
 CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
 UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
             </para>
         </legalnotice>
     </bookinfo>
     <toc/>

  <chapter>
    <title>Introduction</title>
    <sect1 id="thanks">
      <title>Thanks</title>
      <para>
We, the authors would like to take the opportunity to thank everyone
involved in the creation of this documentation, and especially the
people behind setting up the DocBook environment. In particular thanks
go out to Alejandro Ramirez, Phillipe Vanpeperstraete and Andreas
Rueckert.  Thank you!
</para>
    </sect1>
  
    <sect1 id="project">
      <title>About the project</title>
      <para>
ArgoUML is an open source project, so it depends on
people that volunteer to work on it. Especially in the
area of development there is still so much to do!
Everyone who wants to contribute needs to know the
what, where and how to write good quality code, but
getting into it is a big challenge since there are
hundreds of Java files. 
This developer Cookbook is dedicated to all interested programmers and
should help to transfer the knowledge from the old experts to them.
Please feel free to send more questions and/or answers to the 
<ulink url="mailto:dev@argouml.tigris.org">dev mailing list</ulink>!
</para>
    </sect1>

    <sect1>
      <title>About this Cookbook...</title>
      <para>
This document, the ArgoUML Programmers Cookbook, is provided
with the hopes of being helpful for the developers of ArgoUML when
it comes to learning and understanding how ArgoUML work in order
to improve on its functions and features. 

It can also be of interest for persons that wish to analyse the
ArgoUML project for whatever purpose that may be.
</para>
      <sect2>
	<title>In this Cookbook, you will find...</title>
	<para>
Information on how you can compile ArgoUML.
</para>
	<para>
Information on how different features of ArgoUML are implemented.
</para>
	<para>
Information on how you should add modules and Plug-ins to ArgoUML.
</para>
	<para>
Some information that you, as a developer of ArgoUML,
needs to know about how the project is organised and
what requirements you need to fulfil in order to contribute.
</para>

      </sect2>
      <sect2>
	<title>In this Cookbook, you will not find...</title>
	<para>
Information on how to install and use ArgoUML.
</para>
	<para>
Information on what UML is and if/how you should use it in your project.
How to convince your project to use ArgoUML as a modelling tool.
</para>
      </sect2>
    </sect1>
  </chapter>

     <chapter id="Preliminaries">
     <title>Preliminaries</title>
     <sect1 id="starting">
     <title>Getting started</title>
     <para>In order to develop with ArgoUML it is absolutely mandatory to get get the CVS version of ArgoUML. See the ArgoUML website for instructions for that.</para>
     <para>
<indexterm><primary>Libraries</primary><secondary>GEF</secondary></indexterm>
<indexterm><primary>Libraries</primary><secondary>NSUML</secondary></indexterm>
It is also recommended that you check out GEF from <ulink url="http://gef.tigris.org">gef.tigris.org</ulink> because many things in Argo relate to GEF and it is quite handy to have the source code available. Especially since during development cycles new gef libraries to not as frequently get checked into the argouml modules, so it is useful to build the current version for yourself in order to avoid build errors.</para>
     <para>If you want to - but that is really more of a gimmick - get yourself the source of the NSUML library to. But that is not strictly required.
 </para>

      <sect2>
	<title>Which tools do I need to build ArgoUML?</title>
	<itemizedlist>
	  <listitem>
	    <para>
CVS for obtaining the latest files via internet
</para>
	  </listitem>
	  <listitem>
	    <para>
ANT, the Java make tool to manage compiling and packaging
</para>
	  </listitem>
	  <listitem>
	    <para>
JDK, at least version 1.2.2 (includes the java compiler)
</para>
	  </listitem>
	  <listitem>
	    <para>
libs: nsuml.jar, ocl-argo.jar, gef.jar, antlrall.jar
</para>
	  </listitem>
	</itemizedlist>
	<para>
The four libs can be found in cvs.
For compiling/building, a simple 'build package'
should be sufficient.
</para>
      </sect2>
      <sect2>
	<title>Compiling failed. Any suggestions?</title>
	<para>
Most compiling problems arise from wrong versions: maybe ANT
or JDK, but most often one of the four libs. A look on the error
messages can help. Get the appropriate version (or, e.g. in the
case of gef.jar, get the sources through CVS and build it on
your own). Another reason for problems is an unclean local
source tree: if yours is in doubt, remove it completely and
get it all again through CVS. If nothing helps, ask the
<ulink url="mailto:dev@argouml.tigris.org">experts</ulink>!
</para>
      </sect2>

 </sect1>
 <sect1 id="Build">
     <title>Build Process</title>
     <para>
     The ArgoUML build process is driven by ant, and it is highly recommend that you stick to that. There are people known to build from JBuilder or Netbeans, but always make sure that your work compile with the plain vanilla build process.
     </para>
      <para>
Ant is a tool written in java developed for Apache that reads an xml-file
with rules telling what to compile to what result and what files to include
in what jar-file.
</para>
      <para>
The rule file is named <filename>build.xml</filename>.
There is one of those in every separately built directory
(<filename class="directory">src_new</filename>,
<filename class="directory">documentation</filename>, and
<filename class="directory">modules/<replaceable>whatever</replaceable></filename>).
</para>

      <sect2>
	<title>How ant is run from the ArgoUML development environment</title>
	<para>
For your convenience the ant tool of the correct version is present in the
cvs repository of ArgoUML in the file 
<filename class="libraryfile">argouml/lib/ant.jar</filename>.
</para>
	<para>
Normally ant is started with the command
<command>ant <replaceable>parameter</replaceable></command>
but the ArgoUML cvs repository does not contain that convenience program
so you would instead have to write:
<command>java -Dant.home=<replaceable>/your/checked/out/copy/of/argouml</replaceable> -classpath <replaceable>a:complex:classpath</replaceable> -jar ant.jar <replaceable>parameter</replaceable></command>.
</para>
	<para>
To help you there are instead two scripts (one for Unix and one for
Windows) that are called <filename>build.sh</filename> and
<filename>build.bat</filename> respectively present in most
of the directories that contain a <filename>build.xml</filename> file.
These contain some definitions of classpath to simplify the setup.
All you have to do is to set the variables JAVA_HOME and ANT_HOME.
</para>
	<para>
By setting JAVA_HOME to different values you can at different times
build with different versions of jdk and java.
</para>
	<para>
By setting ANT_HOME to different values you can at different times
build with different versions of ant.
This does however not work in the Windows case because of
how <filename>build.bat</filename> is written.
</para>
	<sect3>
	  <title>Compiling for Unix</title>
	  <para>
Here is what you need to do in order to compile and run 
your checked out copy of ArgoUML under Unix.
</para>
	  <orderedlist>
	    <listitem>
	      <para><command>JAVA_HOME=<replaceable>/where/you/have/installed/jdk</replaceable></command></para>
	    </listitem>
	    <listitem>
	      <para><command>export JAVA_HOME</command></para>
	      <para>
This is for sh-style shells like sh, ksh, zsh and bash. If you use
csh-style shells like csh and tcsh you will instead have to write
<command>setenv JAVA_HOME <replaceable>/where/you/have/installed/jdk</replaceable></command>.
</para>
	    </listitem>
	    <listitem>
	      <para>
Change the current directory to the directory you are building
</para>
	      <para>
<command>cd <replaceable>/your/checked/out/copy/of/argouml/src_new</replaceable></command>
</para>
	    </listitem>
	    <listitem>
	      <para>
Modify the beginning of the <filename>build.sh</filename> file 
by setting ARGO_HOME and ANT_HOME to the name
<replaceable>/your/checked/out/copy/of/argouml</replaceable>
</para>
	    </listitem>
	    <listitem>
	      <para>Start ant using <command>./build.sh</command></para>
	      <para>This gives you a list of targets with descriptions</para>
	    </listitem>
	    <listitem>
	      <para>
Compile and run Argouml using <command>./build.sh run</command>
</para>
	      <para>
You can do this over and over again when you have modified something
or want to compile and run again.
</para>
	    </listitem>
	  </orderedlist>
	</sect3>
	<sect3>
	  <title>Compiling for Windows</title>
	  <orderedlist>
	    <listitem>
	      <para>
<command>set JAVA_HOME=<replaceable>/where/you/have/installed/jdk</replaceable></command>
</para>
	    </listitem>
	    <listitem>
	      <para>
<command>set ANT_HOME=<replaceable>/your/checked/out/copy/of/argouml</replaceable></command>
</para>
	    </listitem>
	    <listitem>
	      <para>Change the current directory to the directory you are building</para>
	      <para>
<command>chdir <replaceable>\your\checked\out\copy\of\argouml\src_new</replaceable></command>
</para>
	    </listitem>
	    <listitem>
	      <para>Start ant using <command>build</command></para>
	      <para>This gives you a list of targets with descriptions</para>
	    </listitem>
	    <listitem>
	      <para>
Compile and run Argouml using <command>build run</command>
</para>
	      <para>
You can do this over and over again when you have modified something
or want to compile and run again.
</para>
	    </listitem>
	  </orderedlist>
	</sect3>
      </sect2>
      <sect2>
	<title>How documentation is presented</title>
	<para>
This describes how the documentation arrives on the web site.
</para>
	<sect3>
	  <title>How the ArgoUML web site works</title>
	  <para>
Tigris provides the ArgoUML site to be edited through cvs. Everything
that is checked in under <filename>argouml/www</filename>
becomes immediatly available at the url 
<ulink url="http://argouml.tigris.org/">http://argouml.tigris.org/</ulink>
with some added decorations left and up.
</para>
	  <para>
Example: The file <filename>argouml/www/project.html</filename> is
available at 
<ulink url="http://argouml.tigris.org/project.html">http://argouml.tigris.org/project.html</ulink>.
</para>
	  <para>
This is the way the site is maintained and updated.
</para>
	</sect3>
	<sect3>
	  <title>The ArgoUML documentation</title>
	  <para>
For the ArgoUML project the same documenation shall be available in both
html, pdf and javahelp. To this end the documentation is written in
docbook xml and generated into two versions of html 
(one page per chapter and one page for the whole book),
pdf and javahelp.
</para>
	  <para>
We have tools that does the conversion from docbook xml to html and pdf.
The conversion is done whenever you need to look at the result or when 
you want to present the final result on the web site.
</para>
	  <para>
There is currently four different books generated in this way, 
each its own directory. They are cookbook (this document), faq, 
manual and quick-guide. They are all generated and stored in the
exact same way except for the name of the directory that is one
of <filename class="directory">cookbook</filename>,
<filename class="directory">faq</filename>, 
<filename class="directory">manual</filename> or 
<filename class="directory">quick-guide</filename>.
Below I will reference this directory using 
<filename class="directory"><replaceable>book</replaceable></filename>.
</para>
	  <para>
When a new version of the documentation is to be made available on the
web site the responsible document release person does the following:
</para>
	  <orderedlist>
	    <listitem>
	      <para>
He checks out an updated copy of everything needed
and a copy of the <filename class="directory">argouml/www</filename>.
</para>
	      <para>
To be on the safe side, this could be the whole of ArgoUML.
</para>
	      <para>
If wanted, the cvs repository could be tagged and then the tag
can be checked out. This makes it possible to know exactly 
how a certain version of the documentation was generated.
</para>
	    </listitem>
	    <listitem>
	      <para>
The documentation is generated using <command>build docs</command>.
</para>
	      <para>
This generates all four books and the result appears in 
<filename class="directory">argouml/build/documentation/defaulthtml/<replaceable>book</replaceable></filename>,
<filename class="directory">argouml/build/documentation/printablehtml/<replaceable>book</replaceable></filename>, and
<filename class="directory">argouml/build/documentation/pdf/<replaceable>book</replaceable></filename>.
</para>
	      <para>
This has been done several times before while preparing the release so
no problems are expected. If there are problems then the preparations
was not good enough and the process is best stopped right here.
</para>
	    </listitem>
	    <listitem>
	      <para>
All the old files are removed from the checked out copy of 
<filename class="directory">argouml/www/documentation/defaulthtml/<replaceable>book</replaceable></filename>, 
<filename class="directory">argouml/www/documentation/printablehtml/<replaceable>book</replaceable></filename>, and
<filename class="directory">argouml/www/documentation/pdf/<replaceable>book</replaceable></filename>.
</para>
	    </listitem>
	    <listitem>
	      <para>
New files are copied into the checked out copy of www
on top of the previous files there replacing them.
</para>
	      <para>
All the files are copied from
<filename class="directory">argouml/build/documentation/defaulthtml/<replaceable>book</replaceable></filename> to
<filename class="directory">argouml/www/documentation/defaulthtml/<replaceable>book</replaceable></filename>. 
The same for <filename class="directory">printablehtml</filename> and 
<filename class="directory">pdf</filename>.
</para>
	    </listitem>
	    <listitem>
	      <para>
No longer used files in 
<filename class="directory">argouml/www/documentation</filename>
are removed from cvs and new files are added.
</para>
	      <para><command>cvs -n update</command></para>
	      <para>Watch for "Missing" and "Unknown" files.</para>
	      <para>
The missing files are scheduled to be removed by:
<command>cvs remove <replaceable>each of the missing files</replaceable></command>
</para>
	      <para>
The "Unknown" files are scheduled to be added by:
<command>cvs add <replaceable>each of the added files</replaceable></command>
</para>
	      <para>
This removing of missing files and adding of unknown files may seem
backward but it is from the perspective of cvs.
The missing files are the ones that were present in the previous
version of the documentation and that does not have a replacement,
either because that chapter does not exist anymore or that the tool
generate filenames differently.
The Unknown files are files with filenames that for the same reason
appear from one version of the documentation to the next.
</para>
	    </listitem>
	    <listitem>
	      <para>
Commit the changes thus publishing it on the web site.
</para>
	      <para>
<command>cvs commit -m'New version of the documentation published'</command>
</para>
	    </listitem>
	  </orderedlist>
	  <sect4>
	    <title>Tools that does the generation</title>
	    <para>
The tools and templates to do the conversion from docbook xml to html,
pdf, and javahelp are developed by other open source projects and
entered in the ArgoUML cvs as a convenience to the developer and
quality responsible of the ArgoUML project.
</para>
	    <para>
The quality responsible is mentioned because 
this makes it possible to afterwards have access to exactly the tool 
that was used to generate a certain version of the documentation.
</para>
	    <para>
When a new release of that tool is provided
and we have decided that we want to move to that version of the tool,
possibly at the same time as doing the necessary tweaks
for that new version in the documentation itself,
the tool is updated in cvs.
This means that ArgoUML cvs only contains released versions of that tool.
If we find an unacceptable bug in any of these tools
we either refrain from moving to that version or 
revert to the previous version of the tool.
</para>
	  </sect4>
	</sect3>
      </sect2>
 </sect1>
 <sect1 id="mailing_lists">
     <title>Mailing Lists</title>
     <indexterm><primary>mailinglist</primary></indexterm>
     <indexterm><primary>mailinglist</primary><secondary>developer</secondary></indexterm>
     <indexterm><primary>mailinglist</primary><secondary>cvs</secondary></indexterm>
     <indexterm><primary>mailinglist</primary><secondary>issues</secondary></indexterm>
     <para>All developers <emphasis>MUST</emphasis> subscribe to the mailinglist for developers. Please find the details at: <ulink url="http://argouml.tigris.org/servlets/ProjectMailingListList">http://argouml.tigris.org/servlets/ProjectMailingListList</ulink>
     </para>
     <para>It is also recommended to join the CVS and Issues mailinglists. Both have pretty low traffic, but it helps to see what is going on. Developers should also feel an obligation towards monitoring the Bug database.
     </para>
 </sect1>
</chapter>
<chapter id="components">
    <title>ArgoUML Components</title>

    <sect1>
      <title>Argo Initialization</title>
      <sect2>
	<title>Which sources are involved?</title>
	<para>
Relative to the directory org/argouml, they are mainly:
</para>
	<itemizedlist>
	  <listitem>
	    <para>
application/Main.java,
</para>
	  </listitem>
	  <listitem>
	    <para>
kernel/Project.java + xml/argo/ArgoParser.java,
</para>
	  </listitem>
	  <listitem>
	    <para>
ui/{ProjectBrowser.java,*Pane.java},
</para>
	  </listitem>
	  <listitem>
	    <para>
cognitive/{Designer.java,ui/ToDoPane.java}.
</para>
	  </listitem>
	</itemizedlist>
      </sect2>
      <sect2>
	<title>What is loaded/initialized?</title>
	<para>
It all begins in org.argouml.application.Main: set up
main application frame (org.argouml.ui.ProjectBrowser), the
project (org.argouml.kernel.Project), numerous classes, and
finally as a background thread: cognitive support
(org.argouml.cognitive.Designer) and some more classes.
</para>
	<para>
The ProjectBrowser initializes the menu, toolbar, status bar
and the four main areas:
navigation pane (org.argouml.ui.NavigatorPane),
editor pane (org.argouml.ui.MultiEditorPane),
to do pane (org.argouml.cognitive.ui.ToDoPane), and
details pane (org.argouml.ui.DetailsPane). Then, the actual
project is set to either a read from file project
(see ArgoParser.SINGLETON.readProject(URL) and
ArgoParser.SINGLETON.getProject() in org.argouml.xml.argo.ArgoParser)
or a newly generated project (see Project.makeEmptyProject()).
</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Which Objects live during a typical session?</title>
      <para>
(Project, Designer, Globals, NavPane, ToDoPane, ...)
</para>
    </sect1>
    <sect1>
      <title>What is their task?</title>
      <para>
(visual component, model, controller, ...)
</para>
    </sect1>

    <sect1 id="bigger_components">
    <title>The bigger picture, ArgoUML and supporting libraries</title>
<indexterm><primary>libraries</primary></indexterm>
<indexterm><primary>components</primary></indexterm>
    <para>
<mediaobject>
					<imageobject>
						<imagedata format="GIF" fileref="images/cookbook/big.gif"/>
					</imageobject>
				</mediaobject>
    <itemizedlist>
      <listitem><para>Well, ArgoUML is obviously the main thing.</para></listitem>
      <listitem><para>GEF stands for <emphasis>Graph Editing Framework</emphasis>. It is the package which controls most of the graphical aspects of ArgoUML.</para></listitem>
      <listitem><para>NSUML stands for <emphasis>Novosoft UML</emphasis>. This library gives ArgoUML all the components which are required to deal with UML objects and their relationships with each other. Normally you can recognize everything out of the NSUML packages very easily because the classes start with a capital M.</para>
</listitem>
</itemizedlist>
</para>
</sect1>
<sect1 id="nsuml">
<title>NS-UML</title>
<para>
<mediaobject>
					<imageobject>
						<imagedata format="GIF" fileref="images/cookbook/nsuml_foundation"/>
					</imageobject>
</mediaobject>
</para>
<para>
<mediaobject>
					<imageobject>
						<imagedata format="GIF" fileref="images/cookbook/nsuml_behaviour"/>
					</imageobject>
</mediaobject>
</para>
</sect1>

<sect1 id="small">
<title>The smaller components, inside ArgoUML</title>
<para>
ArgoUML itself breaks down into several components. The graphic does not reflect the true package names, neither the true dependencies of the packages.
<mediaobject>
					<imageobject>
						<imagedata format="GIF" fileref="images/cookbook/small.gif"/>
					</imageobject>
				</mediaobject>
<itemizedlist>
<listitem><para>Critics</para></listitem>
<listitem><para>Diagrams</para></listitem>
<listitem><para>Notation</para></listitem>
<listitem><para>Code Generation</para></listitem>
<listitem><para>Reverse Engineering</para></listitem>
<listitem><para>Help System</para></listitem>
<listitem><para>Internationalization</para></listitem>
<listitem><para>Plugin-Module API</para></listitem>
<listitem><para>Logging</para></listitem>
</itemizedlist>
</para>
</sect1>
</chapter>

<chapter id="inside_components">
<title>Inside the components</title>
<para>...</para>
<sect1 id="general">
<title>General information</title>
<para>This section explains some general concepts which come in handy, when 
programming in Argo/UML.
</para>
<sect2 id="howdoi_general">
<title>How do I ...?</title>
<para>
<itemizedlist>
<listitem><para>...get the according NS-UML element for a given FigXXX class?</para>
<para>each FigXXX implements the method getOwner() which returns the appropriate owner element which is responsible for this Fig element.
</para>
</listitem>
<listitem><para>...get the according Fig element for a given MModelElement?</para>
<para>for this one needs to iterate through all fig elements and invoke getOwner. Compare the result with the given MModelElement. Beware that there might be more than one Fig Element per MModelElement.</para>
</listitem>
</itemizedlist>
</para> 
</sect2>
</sect1>



<sect1 id="critics">
<title>Critics</title>
<para>Here is a small illustration</para>
<mediaobject>
					<imageobject>
						<imagedata format="GIF" fileref="images/cookbook/critics.gif"/>
					</imageobject>
				</mediaobject>
<para>Critics are currently located in:
<itemizedlist>
<listitem><para>org.argouml.cognitive.critics</para>
<para>These are basic critics, which are very general in nature. For example ArgoUML keeps nagging when Modelelements overlap, which makes the Diagram hard to read.</para></listitem>
<listitem><para>org.argouml.uml.cognitive.critics</para>
<para>These are Critics which are directly related to UML issues (well, more or less). For example, it will nag when a class has two many operations, because that makes it hard to maintain the particular class.</para></listitem>
<listitem><para>org.argouml.pattern.cognitive.critics</para>
<para>These are critics related to patterns. Currently they deal only with the Singleton pattern</para>
</listitem>
<listitem><para>org.argouml.language.java.cognitive.critics</para>
<para>These are critics which deal with java specific issues. Currently this is only a warning agains modelling multiple inheritance.</para>
</listitem>
</itemizedlist>
</para>
<sect2 id="howdoi_critics">
<title>How do I ...?</title>
<para>
<itemizedlist>
<listitem><para>...add a critique?</para>
<para>Your best bet is to look for a critique, which does something similiar and copy what it does. The locations of the critics are mentioned above.
</para>
</listitem>
<listitem><para>...fix a critique?</para>
<para>Locate the critique and insert some logging code. You should make sure that you understand all the implications of changes, therefore it is a good idea to see what makes the critic nag in the first place. But rest assured: some of the critics haven't been updated to reflect the latest changes in ArgoUML, so this is a procedure which is well worth digging into, since it gives you also some exposure to related NSUML elements.</para>
</listitem>
<listitem><para>...change the text of a critique?</para>
<para>The texts of the critics should be in the according localization files and resource bundles. Be careful: in some critics the text is still in the critic, but if yo change that, you will notice that it doesn't have any effect.</para>
</listitem>
</itemizedlist>
</para> 
</sect2>
</sect1>
<sect1 id="notation">
<title>Notation</title>
<sect2 id="howdoi_notation">
<title>How do I ...?</title>
<para>...</para>
</sect2>
</sect1>

<sect1 id="diagrams">
<title>Diagrams</title>
<sect2 id="howdoi_diagrams">
<title>How do I ...?</title>
<para>...</para></sect2>
</sect1>

<sect1 id="reverse">
<title>Reverse Engineering</title>
<sect2 id="howdoi_reverse">
<title>How do I ...?</title>
<para>...</para></sect2>

      <sect2>
	<title>Which sources are involved?</title>
	<para>
The package org.argouml.uml.reveng is supposed to hold those classes
that are common to all RE packages. At the moment this is the Import
class which is mainly responsible to recognize directories, get their
content and parse every known source file in them. These are only java
files at them moment, but there might be other languages like C++ in
the future. With this concept you could mix several languages within
a project. The DiagramInterface is used to visualize generated NSUML
metamodel objects then.
</para>
	<para>
The package org.argouml.uml.reveng.java holds the Java specific parts
of the current RE code. C++ RE might go to org.argouml.uml.reveng.cc,
or so...
</para>
      </sect2>
      <sect2>
	<title>How is the grammar of the target language implemented?</title>
	<para>
It's a Antlr (<ulink url="http://www.antlr.org">http://www.antlr.org</ulink>)
grammar, based on the Antlr Java parser
example. The main difference is the missing AST (Abstract Syntax Tree)
generation and treeparser. So the original example generates a AST
(a treelike data structure) and then traverses this tree, while the
ArgoUML code parses the source file and generates NSUML objects
directly from the sources. This was done to avoid the memory usage
of an AST and the frequent GC while parsing many source files.
</para>
      </sect2>
      <sect2>
	<title>Which model/diagramm elements are generated?</title>
	<para>
The *context classes hold the current context for a package, class
etc. When the required information for a object is available, the
corresponding NSUML object is created and passed to the DiagramInterface
to visualize it.
</para>
      </sect2>
      <sect2>
	<title>Which layout algorithm is used?</title>
	<para>
The classes in org.argouml.uml.diagram.static_structure.layout.* hold
the Classdiagram layout code. No layout for other diagram types yet.
It's based on a ranking scheme for classes and interfaces. The rank of
a class/interface depends on the total number of (direct or indirect)
superclasses. So if class B extends A (with rank(A)=0), then rank(B)=1.
If C extends B, then rank(C)=2 since it has 2 superclasses A,B. An
implemented interface is treated similar to a extended class. The
objects are placed in rows then, that depend on their rank.
rank(0)=1st row. rank(1) =2nd row (below the 1st one) etc. Example:
</para>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="images/examples/example1.gif" format="GIF"/>
	  </imageobject>
	</mediaobject>
	<para>
In the next diagramm, a link goes to a object that is not in the row
above:
</para>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="images/examples/example2.gif" format="GIF"/>
	  </imageobject>
	</mediaobject>
	<para>
In this case, insert virtual objects which are linked to the actual
target and link to them:
</para>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="images/examples/example2.gif" format="GIF"/>
	  </imageobject>
	</mediaobject>
	<para>
The object are sorted within their row then to minimize crossing links
then. Compute the average value of the vertical positions of all linked
object in the row above. Example: we have 2 ranks 0 and 1 with 3
classes each:
</para>
	<blockquote>
	  <para>
A B C : rank 0
</para>
	  <para>
D E F : rank 1
</para>
	</blockquote>
	<para>
We give the superclasses an index in their rank (assuming that they are
already sorted):
</para>
	<blockquote>
	  <para>
A:0, B:1, C:2
</para>
	</blockquote>
	<para>
D, E, F have the following links (A, B, C could be interfaces, so I allow
links to multiple superclasses here):
</para>
	<blockquote>
	  <para>
D -> C
</para>
	  <para>
E -> A and C
</para>
	  <para>
F -> A and B
</para>
	</blockquote>
	<para>
Compute the average value of the indexes:
</para>
	<blockquote>
	  <para>
D = 2 (C has index 2 / 1 link)
</para>
	  <para>
E = 0 + 2 / 2 = 1 (A=0, C=2 divide by 2 links)
</para>
	  <para>
F = 0 + 1 / 2 = 0.5 (A=0, B=1, 2 links)
</para>
	</blockquote>
	<para>
Then sort the subclasses by that value:
</para>
	<blockquote>
	  <para>
F(is 0.5), E(is 1), D(is 2)
</para>
	</blockquote>
	<para>
So the placement is:
</para>
	<blockquote>
	  <para>
A B C
</para>
	  <para>
(here are the links, but I can't hardly paint them as ASCIIs)
</para>
	  <para>
F E D
</para>
	</blockquote>
</sect2>



</sect1>

<sect1 id="help">
<title>Help System</title>
<sect2 id="howdoi_help">
<title>How do I ...?</title>
<para>...</para></sect2>
</sect1>

<sect1 id="internationalization">
<title>Internationalization</title>
<sect2 id="howdoi_internationalization">
<title>How do I ...?</title>
<para>...</para></sect2>
</sect1>

&cookbookmodules;
&cookbooklogging;

</chapter>

<chapter id="cvs">
<title>Employed CVS standards</title>
<sect1 id="branches">
<title>Creating and using branches</title>
<para>We use the following standards in Argo/UML:
<itemizedlist>
          <listitem><para>Released versions get the tag <emphasis>VERSION_X_X_X</emphasis></para></listitem>
          <listitem><para>Versions which are considered stable in between official releases get build numbers assigned to them: <emphasis>VERSION_X_X_X_BLDYYY</emphasis></para></listitem>
          <listitem><para>Developers working on code, with an unspecified due date are requested to put the code into a branch if it is deemed useful that the code can be shared. Developer branches follow the scheme: <emphasis>work_explanation_owner</emphasis>, where 
            <itemizedlist>
              <listitem><para>work is a literal</para></listitem>
              <listitem><para>explanation is something like javahelp, propertypanel, cppcodegeneration</para></listitem>
              <listitem><para>owner is a self explaining code for the owner of the branch, e.g. tlach (Thierry Lach) or mklink (Markus Klink).</para></listitem>
              </itemizedlist>
</para>
          </listitem>
</itemizedlist>
</para>
      <para>Merging branches together is causing some work. So please use them sparingly and announce your attention before on the mailinglist.
</para>
      <sect2 id="howdoi_cvs">
	<title>How do I ...?</title>
	<para>
	  <itemizedlist>
	    <listitem>
	      <para>
...get my update or patch into cvs if I don't have cvs write rights?
</para>
	      <para>
Contact any of the active developers on the list and send them your
updates. They're very nice about it the first few times.
</para>
	    </listitem>
	    <listitem>
	      <para>...get a list of the currently active working branches?</para>
	      <para>
You can't from cvs. You need to follow the announcements of created
and discontinued branches on the mailing list to know what branches are
interesting.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
...create a branch for my work on <replaceable>xxxyyy</replaceable> 
and start work on that branch?</para>
	      <para>
This assumes that you have a checked out copy of argouml
	      </para>
	      <orderedlist>
		<listitem>
		  <para>Change directory to the directory where argouml is checked out.</para>
		</listitem>
		<listitem>
		  <para>
Enter the argouml directory:
<command>cd argouml</command> or <command>chdir argouml</command>
		  </para>
		</listitem>
		<listitem>
		  <para>
Create your branch: 
<command>cvs tag -b <replaceable>work_xxxyyy_myname</replaceable></command>
		  </para>
		  <para>
<replaceable>myname</replaceable> is is a self explaining code for you
(your Tigris login).
		  </para>
		</listitem>
		<listitem>
		  <para>
Change your checked out copy to be on the branch:
<command>cvs update -r <replaceable>work_xxxyyy_myname</replaceable></command>
		  </para>
		</listitem>
		<listitem>
		  <para>Do your work!</para>
		</listitem>
		<listitem>
		  <para>
Check in your changes in the branch:
<command>cvs commit -m'<replaceable>Blablabla</replaceable>' <optional>file</optional></command>
		  </para>
		</listitem>
		<listitem>
		  <para>Continue working and checking in!</para>
		</listitem>
	      </orderedlist>
	    </listitem>
	    <listitem>
	      <para>...move my work from my working branch into the release?</para>
	      <para>
This is done when your work with the feature xxxyyy is finished and you have
decided/received clearance to enter it in the main branch.
	      </para>
	      <orderedlist>
		<listitem>
		  <para>
Change directory to the directory where argouml is checked out.
		  </para>
		  <para>
If you are just working on one feature at a time this is the place where you
have a checked out copy on the branch in question. If not, this could be any
checked out copy of the source that does not contain any uncommited changes.
		  </para>
		</listitem>
		<listitem>
		  <para>
Enter the argouml directory:
<command>cd argouml</command> or <command>chdir argouml</command>
		  </para>
		</listitem>
		<listitem>
		  <para>
Move the checked out copy that you are working on to the main branch:
<command>cvs update -A</command>
		  </para>
		</listitem>
		<listitem>
		  <para>
Merge the changes from the branch into you checked out copy:
<command>cvs update -j <replaceable>work_xxxyyy_myname</replaceable></command>
		  </para>
		</listitem>
		<listitem>
		  <para>
Compile and run all your tests again.
		  </para>
		  <para>
This is to verify that the merge was all right, noone else had done any changes
that in the meantime that has in any way modified the work made in the branch.
		  </para>
		</listitem>
		<listitem>
		  <para>
Commit your changes in the main branch:
<command>cvs commit -m'<replaceable>xxxyyy entered in the main branch</replaceable></command>
		  </para>
		</listitem>
		<listitem>
		  <para>
Discontinue your branch!
		  </para>
		  <para>
From this point on it is important that you do not reuse your branch for 
any work. Only check it out for the purpose of examining how things were
in the branch. Make sure that all other developers that have been looking
at your branch also knows that it is discontinued.
		  </para>
		</listitem>
	      </orderedlist>
	    </listitem>
	    <listitem>
	      <para>...look at someone else's work in a branch?</para>
	      <para>
You need the name of the branch, i.e. the 
<replaceable>work_xxxyyy_hisname</replaceable>.
	      </para>
	      <para>
There are two alternatives:
		<itemizedlist>
		  <listitem>
		    <para>
Check out argouml or part of it on that branch:
<command>cvs co -r <replaceable>work_xxxyyy_hisname</replaceable> argouml</command>
		    </para>
		  </listitem>
		  <listitem>
		    <para>
Update your copy of argouml to be on that branch:
<command>cvs update -r <replaceable>work_xxxyyy_hisname</replaceable></command>
		    </para>
		    <para>
Make sure that your copy does not have any uncommited code or else your
your uncommited code will be present in your checked out copy on the branch.
This could, on the other hand, be useful if you want to test if your uncommited
code works also with the additions on that branch.
		    </para>
		  </listitem>
		</itemizedlist>
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>
      </sect2>

</sect1>
</chapter>

<chapter id="further_reading">
<title>Further Reading</title>
<sect1 id="robbins">
<title>Jason Robbins Dissertation</title>
<para>
The dissertation of Jason Robbins is a <emphasis>MUST READ</emphasis> for everyone concerned about ArgoUML. Be careful though, since it is based on an old version of ArgoUML, but many of the concepts remain intact.
</para>
<para><emphasis>LINK: </emphasis><ulink url="http://argouml.tigris.org/docs/robbins_dissertation/">Robbins Dissertation</ulink>
</para>
</sect1>
</chapter>


 <chapter>
  <title>Screen Grabs</title> 
    <para>
The following chapters are moved here from the User FAQ. They need rework.
</para>
    <sect1>
      <title>How to make Screen Grabs</title> 
  <para>There's nothing like show and tell when using software! Everyone likes screen grabs...here's how you can help out!</para> 
  <para>Make screen grabs as you go! And here's how...</para> 
      <sect2>
	<title>MS Windows</title>
  <para>You can use the PrintScreen key to copy the screen to the clipboard (as a bitmap), and then you can paste it into another application (such as MS Word, PowerPoint, etc. (maybe Paint, too)) using the Paste function (ctrl-v). MS Word may (depending on your version) allow you to save the document as an HTML page, which creates an html source file and gif files for all the embedded images (i.e. your pasted screen shot).</para> 
  <para>To capture a single window instead of the entire screen, use Alt-PrintScreen.</para> 
  <para>Image resolution is determined by screen size, for best results: 256 colors by 800X600 is good for a full screen capture.</para> 
  <para>Thanks to Derek for that little tip!</para> 
  <para>Do a search on any of your favorite freeware sites for more elaborate applications. Snagit from techsmith has been recommended</para> 
      </sect2>
      <sect2>
	<title>Linux</title> 
  <para>There's a number of screen shots apps under Linux though they escape me now!</para> 
      </sect2>
    </sect1>
    <sect1>
  <title>Argouml\application\api class diagram screen grab</title> 
 <mediaobject>
 <imageobject>
  <imagedata format="PNG" fileref="images/screenshots/argoapi.png"/> 
  </imageobject>
  </mediaobject>
    </sect1>
    <sect1>
  <title>org\Argouml\application\configuration class diagram screen grab</title> 
 <mediaobject>
 <imageobject>
  <imagedata format="PNG" fileref="images/screenshots/argoconfig.png"/> 
  </imageobject>
  </mediaobject>
    </sect1>
    <sect1>
  <title>org\Argouml\application\configuration class diagram screen grab</title> 
 <mediaobject>
 <imageobject>
  <imagedata format="PNG" fileref="images/screenshots/argocogchklist.png"/> 
  </imageobject>
  </mediaobject>
    </sect1>
    <sect1>
 <title>org\Argouml\cognitive\critics class diagram screen grab</title> 
 <mediaobject>
 <imageobject>
  <imagedata format="PNG" fileref="images/screenshots/argocogcritics.png"/> 
  </imageobject>
  </mediaobject>
    </sect1>
    <sect1>
  <title>org\Argouml\cognitive\critics\ui class diagram screen grab</title> 
      <para>
Could anyone add this one?
</para>
    </sect1>
    <sect1>
  <title>src_new\org\Argouml\kernel class diagram screen grab</title> 
 <mediaobject>
 <imageobject>
  <imagedata format="PNG" fileref="images/screenshots/argokernel.png"/> 
  </imageobject>
  </mediaobject>
    </sect1>
    <sect1>
  <title>src_new\org\Argouml\ocl class diagram screen grab</title> 
<mediaobject>
<imageobject>
  <imagedata format="PNG" fileref="images/screenshots/argoocl.png"/> 
  </imageobject>
  </mediaobject>
    </sect1>
  </chapter>
</book>


