<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Id$ -->


    <sect1 id="diagrams">
      <title>Diagrams</title>
      <indexterm>
	<primary>Diagrams</primary>
      </indexterm>

      <para>
Purpose - to generate a graphical view of the diagrams in the model with
tools.
The contents of the diagrams and model is modifyable.
TODO: Notation!
</para>
      <para>
The Diagrams will be located in <classname>org.argouml.???</classname>.
</para>
      <para>
The Diagrams is a Layer 2 component. <xref linkend="layer2"></xref>.
</para>
      <para>
The Diagrams are depending on the Model and the GUI framework.
</para>

      <sect2>
	<title>Multi editor pane</title>
	<para>
The multieditorpane is the pane with the diagram editor in it.
Normally it is placed in the upper right corner of the application.
One of the feature requests is to make the pane dockable so maybe 
it won't be there in the future.
</para>
	<para>
The multieditorpane consists of tabs that hold editors as you can see
in the classdiagram.
        <mediaobject>
	  <imageobject>
	    <imagedata fileref="images/cookbook/multieditorpane.gif" 
		       format="gif"/>
	  </imageobject>
        </mediaobject>
</para>
	<para>
At the moment there is only one editor tab in place.
This is the TabDiagram that shows an UMLDiagram, the target.
</para>
	<para>
The TabDiagram is spawnable.
This means that the user can double click the tab and the diagram will
spawn as a separate window.
</para>
	<para>
The target of the MultiEditorPane is set via the setTarget method 
of the pane.
This method is called by the setTarget method of the ProjectBrowser.
The pane's setTarget method will call each setTarget method of each
tab that is an instance of TabModelTarget.
Besides setting the target of the tabs, the setTarget method also
calls MultiEditorPane.select(Object o).
This selects the new target on a tab. This probably belongs in 
the setTarget method of the individual tabs and diagrams but 
that's how it's implemented at the moment.
</para>
	<sect3>
	  <title>How do I ...?</title>
	  <para>
<itemizedlist>
	      <listitem>
		<para>...add a new tab to the MultiEditorPane?</para>
		<para>
Create a new class that's a child of JPanel and put the following 
line in argo.ini:
<programlisting>
multi:	<replaceable>fully classified name of new tab class</replaceable>
</programlisting>
</para>
	      </listitem>
	    </itemizedlist>
</para>
	</sect3>
      </sect2>

      <sect2 id="howdoi_diagrams">
	<title>How do I add a new element to a diagram?</title>

	<para>
To add a new element to a diagram, two main things have to be done.
</para>

	<orderedlist>
	  <listitem>
	    <para>
Create new Fig classes to represent the element on the
diagram and add them to the graph model and renderer.
</para>
	  </listitem>

	  <listitem>
	    <para>
Create a new property panel class that will be displayed in
the property tab windown on the details pane.
This is described in <xref linkend="propertypanels"></xref>.
</para>
	  </listitem>
	</orderedlist>

	<para>
Throughout we shall use the example of adding the UML Extend
relationship to a use case diagram. This allows two Use Cases to be
joined by a dotted arrow labelled
<literal>&laquo;extend&raquo;</literal> to show that one extends the
behavior of the other.
</para>

	<para>
The classes involved in this particular example have all been well
commented and have full Javadoc descriptions, to help when examining
the code. 
You will need to read the description here in conjunction
with looking at the code.
</para>

      </sect2>

      <sect2>
	<title>How to add a new Fig</title>

	  <para>
The new item must be added to the toolbar. Both the graph model and
diagram renderer for the diagram will need modifying for any new fig
object.
</para>

	<sect3>
	  <title>Adding to the toolbar</title>

	    <para>
Find the diagram object in
<literal>uml/diagram/XXXX/ui/UMLYYYYDiagram.java</literal>, where
<literal>XXXX</literal> is the diagram type (lower case) and
<literal>YYYY</literal> the diagram type (bumpy caps). For example
<literal>uml/diagram/use_case/ui/UMLUseCaseDiagram.java</literal>. 
This will be a subclass of UMLDiagram (in
<literal>uml/diagram/ui/UMLDiagram.java</literal>).
</para>

	    <para>
Each toolbar action is declared as a protected static field of class
<literal>Action</literal>, initiated as a 
<literal>new CmdCreateNode</literal> (for nodal UML elements) or a
<literal>new CmdSetMode</literal> (for behavior, or creation of line
UML elements). These classes are part of the GEF library.
</para>

	    <para>
The common ones (select, broom, graphic annotations) are inherited
from UMLDiagram, the diagram specific ones in the class itself. For
example in UMLUseCaseDiagram.java we have the following for creating
Use Case nodes.
</para>

	    <para><programlisting>
protected static Action _actionUseCase =
    new CmdCreateNode(MUseCaseImpl.class, "UseCase");
</programlisting>
</para>

	    <para>
The first argument is the class of the node to create from NSUML, the
second a textual tool tip.
</para>

	    <para>For creating associations we have:</para>

	    <para><programlisting>
protected static Action _actionAssoc =
      new CmdSetMode(ModeCreatePolyEdge.class,
	   	     "edgeClass", MAssociationImpl.class,
		     "Association");
</programlisting>
</para>

	    <para>
The first argument is a GEF class that defines the type of behavior
wanted (in this case creating a poly-edge). The second and third
arguments are a named parameter used by
<literal>ModeCreatePolyEdge</literal> ("edgeClass") and its value
(<literal>MAssociationImpl.class</literal>). The final argument is a
tooltip.
</para>

	    <para>
The toolbar is actually created by defining a method,
<literal>initToolBar()</literal> which adds the tools in turn to the
toolbar (a protected member named <literal>_toolBar</literal>).
</para>

	    <para>
The default constructor for the diagram is declared private, since it
must not be called directly. The desired constructor takes a namespace
as an argument, and sets up a graph model
(<literal>UseCaseDiagramGraphModel</literal>), layer perspective and
renderer (<literal>UseCaseDigramRenderer</literal>) for nodes and
edges.
</para>
	</sect3>

	<sect3>
	  <title>Changing the graph model</title>

	    <para>
The graph model is the bridge between the UML meta-model
representation of the design and the graph model of GEF. They are
found in the parent directory of the corresponding diagram class, and
have the general name <literal>YYYYDiagramGraphModel.java</literal>,
where <literal>YYYY</literal> is the diagram name in bumpy caps. For
example the use case diagram graph model is in
<literal>uml/diagram/use_case/UseCaseDiagramGraphModel.java</literal>
</para>

	    <para>
The graph model is defined as a child of the GEF class
<literal>MutableGraphSupport</literal>, and should implement
<literal>MutableGraphModel</literal> (GEF),
<literal>VetoableChangeListener</literal> (Java) and
<literal>MElementListener</literal> (NSUML).
</para>
	</sect3>

	<sect3>
	  <title>Changing the renderer</title>

	    <para>
The renderer is responsible for creating graphic figs as required on
the diagram. It is found in the same directory of the corresponding
diagram class, and has the general name
<literal>YYYYDiagramRenderer.java</literal>, where
<literal>YYYY</literal> is the diagram name in bumpy caps. For example
the use case diagram graph model is in
<literal>uml/diagram/use_case/ui/UseCaseDiagramRenderer.java</literal>
</para>

	    <para>
This provides two routines, <literal>getFigNodeFor()</literal>, which
provides a fig object to represent a given NSUML node object and
<literal>getFigEdgeFor()</literal>, which provides a fig object to
represent a given NSUML edge object.
</para>

	    <para>
In our example, we must extend <literal>getFigEdgeFor()</literal> so
it can handle NSUML MExtend objects (producing a
<literal>FigExtend</literal>).
</para>
	</sect3>

	<sect3>
	  <title>Creating a new Fig (explanation 1)</title>

	    <para>
New objects that are to appear on a diagram will require new Fig
classes to represent them. In our example we have created
FigExtend. They are placed in the same directory as the diagram that
uses them.
</para>

	    <para>
The implementation must provide constructors for both a generic fig,
and one representing a specific NSUML object. It should provide a
setFig() method to set a particular figure as the representation. It
should provide a method canEdit() to indicate whether the Fig can be
edited. It should provide an event handler modelChanged() to cope with
advice that the model has changed.
</para>
	</sect3>

	<sect3 id="howto_createnewfig_2">
	  <title>Creating a new Fig (explanation 2)</title>

	  <para>
Assuming you have your modelelement already defined in the model
and your PropPanel for that modelelement
you should make the Fig class. 

            <orderedlist>
              <listitem>
                <para>
For nodes, that are Figs that are enclosed figures like 
<classname>FigClass</classname>, 
extend from <classname>FigNodeModelElement</classname>. 
For edges, that are lines like <classname>FigAssociation</classname>, 
extend from <classname>FigEdgeModelElement</classname>.
The name of the Fig has to start with (yes indeed) Fig. 
The rest of the name should be equal to the modelelement name.
</para>
              </listitem>
              <listitem>
                <para>
Create a default constructor in the Fig.
In this default constructor the drawing of the actual figure is done.
Here you draw the lines and text fields.
See <classname>FigClass</classname> and 
<classname>FigAssociation</classname> for an example of this.
</para>
              </listitem>
              <listitem>
                <para>
Create a constructor 
<methodname>FigMyModelelement(Object owner)</methodname>.
Set the owner in this method by calling <methodname>setOwner</methodname>.
Make a method <methodname>setOwner</methodname> that overrides
it's super. 
Let the method call it's super.
Set all attributes of the Fig with data from it's owner 
in this <methodname>setOwner</methodname> method. 
See <methodname>setOwner</methodname> of 
<classname>FigAssociation</classname> for an example.
</para>
              </listitem>
              <listitem>
                <para>
Create an overriden method 
<methodname>protected void modelChanged()</methodname>.
This method must be called (and is if you implement the fig correctly)
if the owner changes.
In this method you update the fig if the model is changed. 
See <classname>FigAssociation</classname> and 
<classname>FigClass</classname> for an example.
</para>
              </listitem>
              <listitem>
                <para>
If you have text that can be edited, override the method
<methodname>textEdited(FigText text)</methodname>.
In this method the edited text is parsed. 
If the parsing is simple and not Notation specific, just do it in textEdited.
But for most cases: delegate to ParserDisplay. 
See the method <methodname>parseAttribute</methodname>
in ParserDisplay for an example. 
Stick to the Notation you are using to have the right parsing scheme.
There is work to be done here but please don't make it an even bigger mess :)
</para>
              </listitem>
              <listitem>
                <para>
Make an Action that can be called from the GUI.
If you are lucky, you just can use <classname>CmdCreateNode</classname>.
See for examples <classname>UMLClassDiagram</classname> of using
<classname>CmdCreateNode</classname>.
</para>
              </listitem>
              <listitem>
                <para>
Adapt the method <methodname>canAddEdge(Object o)</methodname>
on subclasses of <classname>GraphModel</classname> if
you are building an edge so it will return true if the edge may be added
to the subclass. 
Subclasses are for example <classname>ClassDiagramGraphModel</classname> and
<classname>UseCaseDiagramGraphModel</classname>.
If you are building a node, adapt
<methodname>canAddNode(Object o)</methodname>.
</para>
              </listitem>
              <listitem>
                <para>
Adapt the method <methodname>getFigEdgeFor</methodname> on
implementors of <classname>GraphEdgeRenderer</classname> if
you are implenting an edge so it will return the correct 
<classname>FigEdge</classname> for your object. 
If you are implementing a node, adapt the method 
<methodname>getFigNodeFor</methodname> on
implementors of <classname>GraphNodeRenderer</classname>.
In argouml classes like <classname>ClassDiagramRenderer</classname>
implement these interfaces.
</para>
              </listitem>
              <listitem>
                <para>
Add an image file for the buttons to the resource directory
<filename class="directory">org/argouml/Images</filename>.
This image file must be of Gif format and have a
drawing of the button image to be used in itself.
This image is also used on the PropPanel.
The name of the Image file should be 
<filename><replaceable>modelelement</replaceable>.gif</filename>
</para>
              </listitem>
              <listitem>
                <para>
Add buttons to the action you created on those places in the gui that
have a need for it.
This should be at least the button bar in each diagram
where you can draw your modelelement.
Probably the parent of your modelelement (e.g. class in case of operation) 
will want a button too, so add it to the PropPanel of the parent. 
In case of the diagrams, add it in 
<filename>UML<replaceable>diagram</replaceable>.java</filename>, 
so in <classname>UMLClassDiagram</classname> if it belongs there. 
In case of the PropPanels, most of them don't use actions,
they implement them directly as methods in the PropPanel themselves.
Please don't do that but use an action so we have one place of definition.
</para>
              </listitem>
	    </orderedlist>
          </para>
	</sect3>
      </sect2>
    </sect1>


<!-- Local stuff for Emacs - please do not delete

Local Variables:
mode: xml
sgml-doctype: "cookbook.xml"
sgml-parent-document: ("cookbook.xml" "sect1" nil)
sgml-validate-command: "nsgmls -wxml -sv ../docbook-setup/xml.dcl \
  cookbook.xml"
End:

-->
