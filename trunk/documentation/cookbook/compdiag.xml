<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Id$ -->


    <sect1 id="diagrams">
      <title>Diagrams</title>
      <indexterm>
	<primary>Diagrams</primary>
      </indexterm>

      <para>
Purpose - to generate a graphical view of the diagrams in the model with
tools.
The contents of the diagrams and model is modifyable.
TODO: Notation!
</para>
      <para>
The Diagrams will be located in <classname>org.argouml.???</classname>.
</para>
      <para>
The Diagrams is a Layer 2 component. <xref linkend="layer2"></xref>.
</para>
      <para>
The Diagrams are depending on the Model and the GUI framework.
</para>

      <sect2 id="howdoi_diagrams">
	<title>How do I add a new element to a diagram?</title>

	<para>
To add a new element to a diagram, two main things have to be done.
</para>

	<orderedlist>
	  <listitem>
	    <para>
Create new Fig classes to represent the element on the
diagram and add them to the graph model and renderer.
</para>
	  </listitem>

	  <listitem>
	    <para>
Create a new property panel class that will be displayed in
the property tab windown on the details pane.
This is described in <xref linkend="propertypanels"></xref>.
</para>
	  </listitem>
	</orderedlist>

	<para>
Throughout we shall use the example of adding the UML Extend
relationship to a use case diagram. This allows two Use Cases to be
joined by a dotted arrow labelled
<literal>&laquo;extend&raquo;</literal> to show that one extends the
behavior of the other.
</para>

	<para>
The classes involved in this particular example have all been well
commented and have full Javadoc descriptions, to help when examining
the code. 
You will need to read the description here in conjunction
with looking at the code.
</para>

      </sect2>

      <sect2>
	<title>How to add a new Fig</title>

	  <para>
The new item must be added to the toolbar. Both the graph model and
diagram renderer for the diagram will need modifying for any new fig
object.
</para>

	<sect3>
	  <title>Adding to the toolbar</title>

	    <para>
Find the diagram object in
<literal>uml/diagram/XXXX/ui/UMLYYYYDiagram.java</literal>, where
<literal>XXXX</literal> is the diagram type (lower case) and
<literal>YYYY</literal> the diagram type (bumpy caps). For example
<literal>uml/diagram/use_case/ui/UMLUseCaseDiagram.java</literal>. 
This will be a subclass of UMLDiagram (in
<literal>uml/diagram/ui/UMLDiagram.java</literal>).
</para>

	    <para>
Each toolbar action is declared as a protected static field of class
<literal>Action</literal>, initiated as a 
<literal>new CmdCreateNode</literal> (for nodal UML elements) or a
<literal>new CmdSetMode</literal> (for behavior, or creation of line
UML elements). These classes are part of the GEF library.
</para>

	    <para>
The common ones (select, broom, graphic annotations) are inherited
from UMLDiagram, the diagram specific ones in the class itself. For
example in UMLUseCaseDiagram.java we have the following for creating
Use Case nodes.
</para>

	    <para><programlisting>
protected static Action _actionUseCase =
    new CmdCreateNode(MUseCaseImpl.class, "UseCase");
</programlisting>
</para>

	    <para>
The first argument is the class of the node to create from NSUML, the
second a textual tool tip.
</para>

	    <para>For creating associations we have:</para>

	    <para><programlisting>
protected static Action _actionAssoc =
      new CmdSetMode(ModeCreatePolyEdge.class,
	   	     "edgeClass", MAssociationImpl.class,
		     "Association");
</programlisting>
</para>

	    <para>
The first argument is a GEF class that defines the type of behavior
wanted (in this case creating a poly-edge). The second and third
arguments are a named parameter used by
<literal>ModeCreatePolyEdge</literal> ("edgeClass") and its value
(<literal>MAssociationImpl.class</literal>). The final argument is a
tooltip.
</para>

	    <para>
The toolbar is actually created by defining a method,
<literal>initToolBar()</literal> which adds the tools in turn to the
toolbar (a protected member named <literal>_toolBar</literal>).
</para>

	    <para>
The default constructor for the diagram is declared private, since it
must not be called directly. The desired constructor takes a namespace
as an argument, and sets up a graph model
(<literal>UseCaseDiagramGraphModel</literal>), layer perspective and
renderer (<literal>UseCaseDigramRenderer</literal>) for nodes and
edges.
</para>
	</sect3>

	<sect3>
	  <title>Changing the graph model</title>

	    <para>
The graph model is the bridge between the UML meta-model
representation of the design and the graph model of GEF. They are
found in the parent directory of the corresponding diagram class, and
have the general name <literal>YYYYDiagramGraphModel.java</literal>,
where <literal>YYYY</literal> is the diagram name in bumpy caps. For
example the use case diagram graph model is in
<literal>uml/diagram/use_case/UseCaseDiagramGraphModel.java</literal>
</para>

	    <para>
The graph model is defined as a child of the GEF class
<literal>MutableGraphSupport</literal>, and should implement
<literal>MutableGraphModel</literal> (GEF),
<literal>VetoableChangeListener</literal> (Java) and
<literal>MElementListener</literal> (NSUML).
</para>
	</sect3>

	<sect3>
	  <title>Changing the renderer</title>

	    <para>
The renderer is responsible for creating graphic figs as required on
the diagram. It is found in the same directory of the corresponding
diagram class, and has the general name
<literal>YYYYDiagramRenderer.java</literal>, where
<literal>YYYY</literal> is the diagram name in bumpy caps. For example
the use case diagram graph model is in
<literal>uml/diagram/use_case/ui/UseCaseDiagramRenderer.java</literal>
</para>

	    <para>
This provides two routines, <literal>getFigNodeFor()</literal>, which
provides a fig object to represent a given NSUML node object and
<literal>getFigEdgeFor()</literal>, which provides a fig object to
represent a given NSUML edge object.
</para>

	    <para>
In our example, we must extend <literal>getFigEdgeFor()</literal> so
it can handle NSUML MExtend objects (producing a
<literal>FigExtend</literal>).
</para>
	</sect3>

	<sect3>
	  <title>Creating a new Fig</title>

	    <para>
New objects that are to appear on a diagram will require new Fig
classes to represent them. In our example we have created
FigExtend. They are placed in the same directory as the diagram that
uses them.
</para>

	    <para>
The implementation must provide constructors for both a generic fig,
and one representing a specific NSUML object. It should provide a
setFig() method to set a particular figure as the representation. It
should provide a method canEdit() to indicate whether the Fig can be
edited. It should provide an event handler modelChanged() to cope with
advice that the model has changed.
</para>
	</sect3>
      </sect2>
    </sect1>


<!-- Local stuff for Emacs - please do not delete

Local Variables:
mode: xml
sgml-doctype: "cookbook.xml"
sgml-parent-document: ("cookbook.xml" "sect1" nil)
sgml-validate-command: "nsgmls -wxml -sv ../docbook-setup/xml.dcl \
  cookbook.xml"
End:

-->
