<?xml version="1.0" encoding="ISO-8859-1"?>

<!--

This section covers requirements capture and how Argo/UML supports such
activity.


Modifications
=============

 4 Dec 2001:  Jeremy Bennett. Broken out as a separate section from the
              original manual by Alejandro, Phillipe and Andreas.

 3 May 2002:  Jeremy Bennett. Chapter written.

-->

<chapter id="ch.tut.reqs">
  <title>Requirements Capture</title>

  <sect1>
    <title>Introduction</title>

    <para>Requirements capture is the process of identifying what the
      <quote>customer</quote> wants from the proposed system.</para>

    <para>The key at this stage is that we are in the problem domain. At this
      stage we must describe everything from the <quote>customer</quote>
      perspective and in the language of the <quote>customer</quote>.</para>

    <para>The biggest risk we have in requirements capture is to start thinking
      in terms of possible solutions. That must wait until the
      <emphasis>Analysis Phase</emphasis> (see <xref
      linkend="ch.tut.analysis"/>). One of the steps of the Analysis Phase will
      be to take the output of the Requirements Phase and recast it in the
      language of a putative solution.</para>

    <para>Remember we are using both a <emphasis>recursive</emphasis>, and an
      <emphasis>iterative</emphasis> process.</para>

    <para>We may well come back to the requirements process again as we break
      down the problem into smaller chunks, each of which must have its
      requirements captured.</para>

    <para>We will certainly come back through the requirements phase on each
      iteration as we seek to define the requirements of more and more of the
      system</para>

    <note>
      <para>
The only part of the requirements notation specified by the
      UML standard is the use case diagram. The remainder is process
      specific. The process described in this chapter draws heavily on the
      Rational Unified Process.</para></note>
  </sect1>

  <!-- Take the reader through the process of capturing requirements. This will
       be quite high level in the current version of the document. -->

  <sect1>
    <title>The Requirements Capture Process</title>

    <para>We start with a top level view of the problem we are solving and the
      key areas of functionality that we must address in any
      solution. This is our <emphasis>vision document</emphasis>, and should
      be just a few pages long.</para>

    <para>For example the top level view of an automated teller machine (ATM)
      might be that it should support the following.</para>

    <orderedlist>
      <listitem><para>Cash deposit, cash withdrawal and account inquiries by
        customers.</para></listitem>

      <listitem><para>Maintenance of the equipment by the bank's engineers, and
        unloading of deposits and loading of cash by the local bank
        branch.</para></listitem>

      <listitem><para>Audit trail for all activities sent to the bank's central
        computer.</para></listitem>
    </orderedlist>

    <para>From this top level view we can extract the principle activities of
      the system, and the external agents (people, equipment) that are involved
      in those activities. These activities are known as <emphasis>use
      cases</emphasis> and the external agents are known as
      <emphasis>actors</emphasis>.</para>

    <para>Actors may be people or machines. From a practical standpoint it is
      worth knowing the stakeholder behind any machine, since only they will be
      able to engage with the requirements capture process.</para>

    <para>Use cases should be significant activities for the system. For
      example customer use of the ATM machine is a use case. Entering a PIN
      number is not.</para>

    <para>There is a gray area between these two extremes. As we shall see it
      is often useful to break very large use cases into smaller sub-use
      cases. For example we may have sub-use cases covering cash deposit, cash
      withdrawal and account inquiry.</para>

    <para>There is no hard and fast rule. Some architects will prefer a small
      number of relatively large use cases, others will prefer a larger number
      of smaller use cases. A useful rule of thumb is that any practical
      project ought to require no more than about 30 use cases (if it needs
      more, it should be broken into separate projects).</para>

    <para>We then show the relationship between use cases and actors on one or
      more use case diagrams. For a large project more than one diagram will be
      needed. Usually groups of related use cases are shown on one
      diagram.</para>

    <para>We must then give a more detailed specification of each use
      case. This covers its normal behavior, alternative behaviors and any pre-
      and post-conditions. This is captured in a document variously known as a
      <emphasis>use case specification</emphasis> or <emphasis>use case
      scenario</emphasis>.</para>

    <para>Finally, since use cases are functional in nature, we need a document
      to capture the non-functional requirements (capacity, performance,
      environmental needs etc). These requirements are captured in a document
      known as a <emphasis>supplementary requirements
      specification</emphasis>.</para>

    <sect2>
      <title>Process Steps</title>

      <para>The steps in the requirements capture process can be summarized as
        follows.</para>

      <orderedlist>
        <listitem><para>Capture an overall view of the problem, and the desired
          characteristics of its solution in the <emphasis>vision
          document</emphasis>.</para></listitem>

        <listitem><para>Identify the <emphasis>use case</emphasis> and
          <emphasis>actors</emphasis> from the vision document and show their
          relationships on one or more <emphasis>use case
          diagrams</emphasis>.</para></listitem>

        <listitem><para>Give detailed <emphasis>use case
          specifications</emphasis> for each use case, covering normal and
          alternate behavior, pre- and post-conditions.</para></listitem>

        <listitem><para>Capture all non-functional requirements in a
          <emphasis>supplementary requirements
          specification</emphasis>.</para></listitem>
      </orderedlist>

      <para>In any iterative development process, there will be an exercise of
        prioritization, and early iterations will focus on capturing the key
        behavior of the most important use cases.</para>

      <para>Most modern requirements capture processes agree that it is
        essential that the authoritative representative of the customer is
        fully involved throughout the process.</para>
    </sect2>
  </sect1>

  <sect1 id="s1.tut.req_process_output">
    <title>Output of the Requirements Capture Process</title>

    <para>Almost all the output of the requirements capture process is
      documentary. The only diagram is the use case diagram, showing the
      relationships between use cases and actors.</para>

    <sect2 id="s2.tut.vision_document">
      <title>Vision Document</title>

      <para>Typical sections of this document would be as follows.</para>

      <itemizedlist>
        <listitem><para><emphasis>Summary</emphasis>. A statement of the
          context, problem and solution goals.</para></listitem>

        <listitem><para><emphasis>Goals</emphasis>. What are we trying to
          achieve (and how do we wish to achieve it).</para></listitem>

        <listitem><para><emphasis>Market Context</emphasis> or
          <emphasis>Contractual Arrangements</emphasis>. For a market led
          development, this should indicate target markets, competitive
          differentiators, compelling events and so forth. For a contractual
          development this should explain the key contractual
          drivers.</para></listitem>

        <listitem><para><emphasis>Stakeholders</emphasis>. Who are the users
          (in the widest sense) of the system. Many of these will map in to
          actors, or control equipment that maps into
          actors.</para></listitem>

        <listitem><para><emphasis>Key Features</emphasis>. At the very
          highest level what are they key functional aspects of the
          problem/desired solution. These will largely map down to the use
          cases. It is helpful to give some prioritization
          here.</para></listitem>

        <listitem><para><emphasis>Constraints</emphasis>. A high level view
          of the non-functional parameters of the system. These will be
          worked out in detail in the supplementary requirements
          specification.</para></listitem>

        <listitem><para><emphasis>Appendix</emphasis>. A listing of the
          actors and use cases that will be needed to meet this vision. It is
          useful to link to these from the earlier sections to ensure
          comprehensive coverage.</para></listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Use Case Diagram</title>

      <para>The vision document has identified the use cases and actors. The
        use case diagram captures how they interact. In our ATM example we
        have identified <quote>customer uses machine</quote>, <quote>maintain
        machine</quote> and <quote>audit</quote> as the three main use
        cases. We have identified <quote>customer</quote>, maintenance
        engineer<quote>, </quote><quote>local branch official</quote> and
        <quote>central computer</quote> as the actors.</para>

      <para><xref linkend="fig.tut.atm_use_case_diagram_basic"/> shows how
        this could be displayed on a use case diagram. The use cases are
        shown as ovals, the actors as stick people (even where they are
        machines), with lines (known as <emphasis>associations</emphasis>
        connecting use cases to the actors who are involved with them. A box
        around the use cases emphasizes the boundary between the system
        (defined by the use cases) and the actors who are external.</para>

      <note><para>Not all analysts like to use a box around the use cases. It
        is a matter of personal choice.</para></note>

      <!-- This just shows the three use cases and four actors -->

      <figure id="fig.tut.atm_use_case_diagram_basic" float="1">
        <title>Basic use case diagram for an ATM system.</title>

        <screenshot><mediaobject>
            <imageobject>
              <imagedata format="GIF" align="center"
                fileref="images/tutorial/atm_use_case_diagram_basic.gif"/>
            </imageobject>
          </mediaobject></screenshot>
      </figure>

      <para>The following sections show how the basic use case diagram can be
        extended to show additional information about the system being
        designed.</para>

      <!-- Showing navigation on associations -->

      <sect3>
        <title>Active and Passive Actors</title>

        <para><emphasis>Active</emphasis> actors initiate interaction with
          the system. This can be shown by placing an arrow on the
          association from the actor pointing toward the use case. In the
          ATM example, the customer is an active actor.</para>

        <para>Interaction with <emphasis>passive</emphasis> actors is
          initiated by the system. This can be shown by placing an arrow on
          the association from the use case pointing toward the actor. In
          the ATM example, the central computer is a passive actor.</para>

        <para>This is a good example where the arrow helps, since it allows
          us to distinguish an event driven system (the ATM initiates
          interaction with the central computer) from a polling system (the
          central computer interrogates the ATM from time to time).</para>

        <para>Where an actor may be either active or passive, depending on
          circumstances, the arrow may be omitted. In the ATM example the
          bank engineer fits into this category. Normally he is active,
          turning up on a regular cycle to service the machine. However if
          the ATM detects a fault, it may summon the engineer to fix
          it.</para>

        <para>The use of arrows on associations is referred to as the
          <emphasis>navigation</emphasis> of the association. We shall see
          this used elsewhere in UML later on.</para>

        <para><xref linkend="fig.tut.atm_use_case_diagram_navigation"/> shows
          the ATM use case diagram with navigation displayed.</para>

        <!-- This adds navigation to the diagram -->

        <figure id="fig.tut.atm_use_case_diagram_navigation" float="1">
          <title>Use case diagram for an ATM system showing
            navigation.</title>

          <screenshot><mediaobject>
              <imageobject>
                <imagedata format="GIF" align="center"
                  fileref="images/tutorial/atm_use_case_diagram_navigation.gif"/>
              </imageobject>
            </mediaobject></screenshot>
        </figure>
      </sect3>

      <!-- Multiplicity -->

      <sect3>
        <title>Multiplicity</title>

        <para>It can be useful to show the <emphasis>multiplicity</emphasis> of
          associations between actors and use cases. By this we mean how many
          instances of an actor interact with how many instances of the use
          case.</para>

        <para>By default we assume one instance of an actor interacts with one
          instance of a use case. In other cases we can label the multiplicity
          of one end of the association, either with a number to indicate how
          many instances are involved, or with a range separated by two periods
          (<literal>..</literal>). An asterisk (<literal>*</literal>) is used
          to indicate an arbitrary number.</para>

        <para>In the ATM example, there is only one central computer, but it
          may be auditing any number of ATM uses. So we place the label
          <literal>0..*</literal> at the use case end. There is no need for a
          label at the other end, since the default is one.</para>

        <para>A local bank will have up to three officials authorized to unload
          and load ATM machines. So at the actor end of the relationship with
          the use case <literal>Maintain ATM</literal>, we place the label
          <literal>1..3</literal>. They may be dealing with any number of ATM
          machines, so at the other end we place the label
          <literal>0..*</literal>.</para>

        <para>There may be any number of customers and there may be any number
          of ATM systems they could use. So at each end of the association we
          place the label <literal>0..*</literal>.</para>

        <note><para><literal>0..*</literal> is so common as a label that the
          shorthand <literal>*</literal> is often used instead, although at
          present this is not supported by &argouml;.</para></note>

        <para><xref linkend="fig.tut.atm_use_case_diagram_multiplicity"/> shows
          the ATM use case diagram with multiplicity displayed.</para>

        <!-- This adds multiplicity to the diagram -->

        <figure id="fig.tut.atm_use_case_diagram_multiplicity" float="1">
          <title>Use case diagram for an ATM system showing
            multiplicity.</title>

          <screenshot><mediaobject>
              <imageobject>
                <imagedata format="GIF" align="center"
                  fileref="images/tutorial/atm_use_case_diagram_multiplicity.gif"/>
              </imageobject>
            </mediaobject></screenshot>
        </figure>

        <para>Multiplicity can clutter a diagram, and is often not shown,
          except where it is critical to understanding. In the ATM example we
          would only choose to show <literal>1..3</literal> against the local
          bank official, since all others are obvious from the context.</para>
      </sect3>

      <!-- Use of includes, extends and generalization -->

      <sect3>
        <title>Hierarchies of Use Cases</title>

        <para>In our ATM example so far we have just three use cases to
          describe all the behavior of the system. While use cases should
          always describe a significant chunk of system behavior, if they are
          too general they can be difficult to describe.</para>

        <para>We could for example define the behavior of the use case
          <quote>Use ATM</quote> in terms of the behavior of three simpler
          use cases, <quote>Deposit Cash</quote>, <quote>Withdraw
          Cash</quote> and <quote>Query Account</quote>. The main use case
          could be specified by <emphasis>including</emphasis> the behavior
          of the subsidiary use cases where needed.</para>

        <para>Similarly the <quote>Maintain ATM</quote> use case could be
          defined in terms of two use cases <quote>Maintain Equipment</quote>
          and <quote>Reload ATM</quote>. In this case the two actors involved
          in the main use case are really only involved in one or other of
          the two subsidiary use cases and this can be shown on the
          diagram.</para>

        <para>The decomposition of a use case into simpler sub-use cases is
          shown in UML by using an <emphasis>include relationship</emphasis>,
          a dotted arrow from the main use case to the subsidiary, with the
          label <emphasis>&laquo;include&raquo;</emphasis>.</para>

        <!-- Show include on the diagram -->

        <figure id="fig.tut.atm_use_case_diagram_include" float="1">
          <title>Use case diagram for an ATM system showing
            include relationships.</title>

          <screenshot><mediaobject>
              <imageobject>
                <imagedata format="GIF" align="center"
                  fileref="images/tutorial/atm_use_case_diagram_include.gif"/>
              </imageobject>
            </mediaobject></screenshot>
        </figure>

        <para>Include relationships are fine for breaking down the use case
          behaviors in to hierarchies. However we may also want to show a use
          case that is an <emphasis>extension</emphasis> to an existing
          use case to cater for a particular circumstance.</para>

        <para>In the ATM example we have a use case covering routine
          maintenance of the ATM, <quote>Maintain Equipment</quote>. We also
          want to cover the special case of an unscheduled repair caused by
          the ATM detecting an internal fault.</para>

        <para>This is shown in UML by the <emphasis>extend</emphasis>
          relationship. In the main use case, we specify a name for a
          location in the description, where an extension to the behavior
          could be attached. The name and location are shown in a
          separate compartment within the use case oval. The representation
          extend relationship is the same as the include relationship, but
          with the label <emphasis>&laquo;extend&raquo;</emphasis>. Alongside
          the extend relationship, we specify the condition under which that
          behavior will be attached.</para>

        <para><xref linkend="fig.tut.atm_use_case_diagram_extend"/> shows
          the ATM use case diagram with an extend relationship to a use case
          for unscheduled repairs. The diagram is now getting rather
          complex, and so we have split it into two, one for the maintenance
          side of things, the other for customer usage and audit.</para>

        <para>The <quote>Maintain Equipment</quote> use case defines a name
          <quote>Unsched</quote>, at the start of its description. The
          extending use case <quote>Unscheduled Repair</quote> is attached
          there when the ATM detects an internal error.</para>

        <!-- This adds navigation to the diagram -->

        <figure id="fig.tut.atm_use_case_diagram_extend" float="1">
          <title>Use case diagram for an ATM system showing an extend
            relationship.</title>

          <screenshot><mediaobject>
              <imageobject>
                <imagedata format="GIF" align="center"
                  fileref="images/tutorial/atm_use_case_diagram_extend.gif"/>
              </imageobject>
            </mediaobject></screenshot>
        </figure>

        <para>Use cases may be linked together in one other way. One use case
          may be a <emphasis>generalization</emphasis> of a subsidiary use
          case (or alternatively the subsidiary is a
          <emphasis>specialization</emphasis> of the main use case).</para>

        <para>This is very like the extends relationship, but without the
          constraint of specific extension points at which the main use case
          may be extended, and with no condition on when the subsidiary use
          case may be used.</para>

        <para>Generalization is shown on a use case diagram by an arrow with
          solid line and solid white head from the subsidiary to the main use
          case.</para>

        <para>This may be useful when a subsidiary use case specializes the
          behavior of the main use case at a large number of positions and
          under a wide range of circumstances.</para>

        <para>However the lack of any restriction makes generalization very
          hard to specify precisely. In general use an extend relationship
          instead.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>The Use Case Specification</title>

      <para>Each use case must be documented to explain in detail the
        behavior it is specifying. This document is known by different names
        in different processes: <emphasis>use case
        specification</emphasis>,<emphasis> use case scenario</emphasis> or
        even (confusingly) just <emphasis>use case</emphasis>.</para>

      <para>A typical use case will include the following sections.</para>

      <itemizedlist>
        <listitem><para><emphasis>Name</emphasis>. The name of the use case
          to which this relates.</para></listitem>

        <listitem><para><emphasis>Goal</emphasis>. A one or two line summary
          of what this use case achieves <emphasis>for its
          actors</emphasis>.</para></listitem>

        <listitem><para><emphasis>Actors</emphasis>. The actors involved in
          this use case, and any context regarding their involvement.</para>

        <note><para>This should not be a description of the actor. That
          should be associated with the actor on the use case
          diagram.</para></note></listitem>

        <listitem><para><emphasis>Pre-condition</emphasis>. These would be
          better named <quote>pre-assumptions</quote>, but the term used
          everywhere is pre-conditions. This is a statement of any
          simplifying assumptions we can make at the start of the use
          case.</para>

        <para>In the ATM example we might make the assumption for the<quote>
          Maintain Equipment</quote> use case that an engineer is always
          available, and we do not need to worry about the case where a
          routine maintenance visit is missed.</para>

        <caution><para>Avoid pre-conditions wherever possible. You need to be
          absolutely certain that the pre-condition holds under all possible
          circumstances. If not your system will be under specified and hence
          will fail when the pre-condition is not true. Alternatively, when
          you cannot be certain the pre-condition is always true, you will
          need to specify a second use case to handle the pre-condition being
          false. In the the first case, pre-conditions are a source of
          problems, in the second a source of more
          work.</para></caution></listitem>

        <listitem><para><emphasis>Basic Flow</emphasis>. The linear sequence
          of steps that describe the behavior of the use case in the
          <quote>normal</quote> scenario. Where a use case has a number of
          scenarios that could be normal, one is arbitrarily
          selected. Specifying the basic flow is described in more detail in
          <xref linkend="s3.tut.basic_flow"/> below.</para></listitem> 

        <listitem><para><emphasis>Alternate Flows</emphasis>. A series of
          linear sequences describing each of the alternative behaviors to
          the basic flow. Specifying alternate flows is described in more
          detail in <xref linkend="s3.tut.alternate_flows"/>.
          </para></listitem>

        <listitem><para><emphasis>Post-conditions</emphasis>. These would be
          better named <quote>post-assumptions</quote>. This is a statement
          of any assumptions that we can make at the end of the use
          case. Most useful where the use case is one of a series of
          subsidiary use cases that are included in a main use case, where
          they can form the pre-conditions of the next use case to be
          included.</para>

        <caution><para>Like pre-conditions, post-conditions are best
          avoided. They place a burden on the specification of the use case
          flows, to ensure that the post-condition always holds. They
          therefore are also a source of problems and extra
          work.</para></caution></listitem>

        <listitem><para><emphasis>Requirements</emphasis>. In an ideal world
          the vision document, use case diagrams, use case specifications and
          supplementary requirements specification would form the
          requirements for a project.</para>

        <para>For most market-led developments, where ownership of requirements
          is within the same business as the team who will do the development,
          this is now usually the case. The marketing department can learn use
          case based requirements capture and analysis to link to their
          customer facing activities.</para>

        <para>However for external contract developments, customers may
          insist on a traditional <quote>list of features</quote> as the
          basis of the contract. Where this is the case, this section of the
          use case specification should link to the contract features that
          are covered by the use case.</para>
          
        <para>This is often done through a third party tool that can link
          documents, providing automated checking of coverage, in which case
          this section is not needed, or may be generated
          automatically.</para></listitem>
      </itemizedlist>

      <para>The final size of the use case specification will depend on the
        complexity of the use case. As a rule of thumb, most use cases take
        around 10-15 pages to specify, the bulk of which is alternate
        flows. If you are much larger than this, consider breaking the use
        case down. If you are much smaller consider whether the use case is
        addressing too small a chunk of behavior.</para>

      <!-- More detail on the basic flow -->

      <sect3 id="s3.tut.basic_flow">
        <title>Specifying the Basic Flow</title>

        <para>All flows in a use case specification are linear&mdash;that is
          there is no conditional branching. Any choices in flows are handled
          by specifying another alternate flow that takes over at the choice
          point. It is important to remember we are specifying behavior here,
          not programming it.</para>

        <para>A flow is specified as a series of numbered steps. Each step
          must involve some interaction with an actor, or at least generate a
          change that is observable externally by an actor. Requirements
          capture should not be specifying hidden internal behavior of a
          system.</para>

        <para>For example we might give the following sequence of steps for
          the basic flow of the use case "Withdraw Cash" in our ATM
          example.</para>

        <orderedlist>
          <listitem><para>Customer indicates a receipt is
            required.</para></listitem>

          <listitem><para>Customer enters amount of cash
            required.</para></listitem>

          <listitem><para>ATM verifies with the central computer that the
            customer can make this withdrawal.</para></listitem>

          <listitem><para>ATM dispenses cash to the
            customer.</para></listitem>

          <listitem><para>ATM issues receipt to customer.</para></listitem>
        </orderedlist>

        <para>Remember this is a sub-use case included in the main <quote>Use
          ATM</quote> use case, which will presumably handle checking of
          cards and PINs before invoking this included use case.</para>

        <note><para>The first step is not a condition. We take as our basic
          flow the case where the customer does want a receipt. The case
          where the customer does not want a receipt will be an alternative
          flow.</para></note>
      </sect3>

      <!-- More detail on the alternate flows -->

      <sect3 id="s3.tut.alternate_flows">
        <title>Specifying the Alternate Flows</title>

        <para>This captures the alternative scenarios, as linear flows, by
          reference to the basic flow. Initially we just build a list of the
          alternate flows.</para>

        <orderedlist numeration="upperalpha" inheritnum="inherit">
          <listitem><orderedlist numeration="arabic" inheritnum="inherit">
            <listitem><para>Customer does not require a
              receipt.</para></listitem>

            <listitem><para>Customer's account will not support the
              withdrawal.</para></listitem>

            <listitem><para>Communication to the central computer is
              down.</para></listitem>

            <listitem><para>The customer cancels the
              transaction.</para></listitem>

            <listitem><para>The customer fails to take the dispensed
              cash.</para></listitem>
        </orderedlist></listitem></orderedlist>

        <para>Subsequently we flesh out each alternate flow, by reference to
          the basic flow. For example the first alternate flow might look
          like.</para>

        <orderedlist numeration="upperalpha" inheritnum="inherit">
          <listitem><orderedlist numeration="arabic" inheritnum="inherit">
            <listitem><para>Customer does not require a
              receipt.</para>

            <orderedlist numeration="arabic" inheritnum="inherit">
              <listitem><para>At step 1 of the basic flow the customer
                indicates they do not want a receipt.</para></listitem>

              <listitem><para>The basic flow proceeds from step 2 to step 4,
                and step 5 is not used.</para></listitem>
            </orderedlist></listitem>
        </orderedlist></listitem></orderedlist>

        <para>The convention is to number the various alternate flows as A.1,
          A.2, A.3, etc. The steps within an alternate flow are then numbered
          from this. So the steps of the first alternate flow would be A.1.1,
          A.1.2, A.1.3, etc.</para>
      </sect3>

      <!-- How does this fit into iterative development -->

      <sect3>
        <title>Iterative Development of Use Case Specifications</title>

        <para>Iterative development will prioritize the use cases, and the
          first iterations will address the most important.</para>

        <para>Early iterations will capture the basic flows of the most
          important use cases with only essential detail and list the
          headings of the main alternate flows.</para>

        <para>Later iterations will address the remaining use cases, flesh
          out the steps on individual alternate flows and possibly provide
          more detail on individual steps.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Supplementary Requirement Specification</title>

      <para>This captures the non-functional requirements or constraints placed
        on the system. Since use cases are inherently functional in nature,
        they cannot capture this sort of information.</para>

      <note><para>Some analysts like to place non-functional requirements in a
        section at the end of each use case specification, containing the
        non-functional requirements relevant to the use case.</para>

      <para>I don't like this for two reasons. First key non-functional
        requirements (for example about performance) may need to appear in many
        use cases and it is bad practice to replicate information. Secondly
        there are invariably some non-functional requirements that are system
        wide and need a system wide document. Hence my preference for a single
        supplementary requirements specification.</para></note>

      <para>There should be a section for each of the main areas of
        non-functional requirements. The check list provided by Ian Sommerville
        in his book <emphasis>Software Engineering</emphasis> (Third Edn,
        Addison-Wesley, 1989) is a useful guide.</para>

      <itemizedlist>
        <listitem><para><emphasis>Speed</emphasis>. Processor performance,
          user/event response times, screen refresh time.</para></listitem>

        <listitem><para><emphasis>Size</emphasis>. Main memory (and possibly
          caches), disc capacity.</para></listitem>

        <listitem><para><emphasis>Ease of use</emphasis>. Training time, style
          and detail of help system.</para></listitem>

        <listitem><para><emphasis>Reliability</emphasis>. Mean time to failure,
          probability of unavailability, rate of failure,
          availability.</para></listitem>

        <listitem><para><emphasis>Robustness</emphasis>. Time to restart after
          failure, percentage of events causing failure, probability of data
          corruption on failure.</para></listitem>

        <listitem><para><emphasis>Portability</emphasis>. Percentage of
          target-dependent code/classes, number of target
          systems.</para></listitem>
      </itemizedlist>

      <para>To this we should add sections on environment (temperature,
        humidity, lightening protection status) and standards
        compliance.</para>
    </sect2>
  </sect1>

  <!-- Now show how to do in in Argo/UML. -->

  <sect1 id="s1.argo_use_cases">
    <title>Using Use Cases in &argouml;</title>

    <para>&argouml; allows you to draw use case diagrams. When you create a new
      project it has a use case diagram created by default, named <literal>use
      case diagram 1</literal>. Select this by &button1; click on the diagram
      name in the explorer (the upper left quadrant of the user
      screen).</para>

    <para>New use case diagrams can be created as needed through
      <literal>Create Diagram</literal> on the main menu bar. They are edited
      in the editing pane (the upper right quadrant of the user screen).</para>

    <sect2>
      <title>Actors</title>

      <para>To add an actor to the diagram use &button1; click on the actor
        icon on the editing pane toolbar
        (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
        align="center" fileref="images/icons/actor.gif"/>
        </imageobject></inlinemediaobject></guiicon>) and then &button1; click
        at the location where you wish to place it. The actor can be moved
        subsequently by &button1; motion (i.e &button1; down over the actor to
        select it, move to the new position and &button1; release to drop the
        actor in place.</para>

      <para>Multiple actors can be added in one go, by using &button1; double
        click on the actor icon. Each subsequent &button1; click will drop an
        actor on the diagram. &button1; on the select icon
        (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
        align="center" fileref="images/icons/select.gif"/>
        </imageobject></inlinemediaobject></guiicon>) to stop adding
        actors.</para>

      <para>The actors name is set in its property panel. First select the
        actor (if not already selected) on the editing pane using &button1;
        click. Then click on the <literal>Properties</literal> tab in the
        details pane. The name is entered in the name field, and will appear on
        the screen.</para>

      <para>As a shortcut, double &button1; click on the name of the actor in
        the editing pane (or just typing on the keyboard when an actor is
        selected) will allow the name to be edited directly. This is a
        convenient way to enter a name for a new actor.</para>

      <para>Having created the actor, you will see it appear in the explorer
        (the upper left quadrant of the user screen). This shows all the
        artifacts created within the UML design. A drop down at the top of the
        explorer controls the ordering of artifacts in the explorer.
        The most useful are the <literal>Package-centric</literal>
        (default) and <literal>Diagram-centric</literal>. The latter shows
        artifacts grouped by the diagram on which they appear.</para>
    </sect2>

    <sect2>
      <title>Use Cases</title>

      <para>The procedure for adding use cases is the same as that for adding
        actors, but using the use case icon on the editing pane toolbar
        (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
        align="center" fileref="images/icons/use_case.gif"/>
        </imageobject></inlinemediaobject></guiicon>).</para>

      <para>By default use cases in &argouml; do not display their extension
        points (for use in extend relationships). You can show the extension
        point compartment in one of two ways.</para>

      <orderedlist>
        <listitem><para>Select the use case in the editing pane with &button1;
          click, then select the <literal>Style</literal> tab in the details
          pane and &button1; click on the <literal>Display: Extension
          Points</literal> check box.</para></listitem>

        <listitem><para>Use &button2; click over the use case in the editing
          pane to display a context sensitive pop-up menu and from that choose
          <literal>Show/Show Extension Point
          Compartment</literal>.</para></listitem>
      </orderedlist>

      <para>The same approaches can be used to hide the extension point
        compartment.</para>

      <sect3>
        <title>Adding an Extension Point to a Use Case</title>

        <para>There are two ways to add an extension point to a use
          case.</para>

        <orderedlist>
          <listitem><para>Select the use case on the editing pane with
            &button1; click. Then click on the <literal>Add Extension
            Point</literal> icon
            (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
            align="center" fileref="images/icons/extension_point.gif"/>
            </imageobject></inlinemediaobject></guiicon>) on the toolbar, and a
            new extension point with default name and location will be added
            after any existing extension points.</para>

          <note><para>The <literal>Add Extension Point</literal> icon is grayed
            out and unusable until a use case is
            selected.</para></note></listitem>

          <listitem><para>Select the use case on the editing pane with
            &button1; click and then select its property tab in the details
            pane. &button2; click over the <literal>Extension Points:</literal>
            field will bring up a context sensitive pop-up menu. Select
            <literal>Add</literal> to add a new extension point.</para>

          <para>If any extension points already exist, they will be shown in
            this field on the property tab. The new extension point will be
            inserted immediately before the entry over which the pop-up menu
            was invoked. This ordering can be changed later by using the
            <literal>Move Up</literal> and <literal>Move Up</literal> entries
            on the pop-up menu.</para></listitem>
        </orderedlist>

        <para>Whichever method is used, the new extension point is selected,
          and its property tab can be displayed in the details pane. The name
          and location of the extension point are free text, set in the
          corresponding fields of the property tab.</para>

        <para>An existing extension point can be edited from its property
          tab. The property tab can be reached in two ways.</para>

        <orderedlist>
          <listitem><para>If the extension point compartment for the use case
            is displayed on the diagram, select the use case with &button1;
            click and then select the extension point with a further &button1;
            click. The property tab can then be selected in the details
            pane.</para></listitem>

          <listitem><para>Otherwise select the use case and its property tab in
            the details pane. &button1; click on the desired entry in the
            <literal>Extension Points</literal> field will bring up the
            property tab for the extension point in the details
            pane.</para></listitem>
        </orderedlist>

        <para>The name and location fields of the extension point may then be
          edited.</para>

        <para>As a shortcut, where the extension point compartment is
          displayed, double click on the extension point allows text to be
          typed in directly. This is parsed to set name and location for the
          extension point.</para>

        <para>Extension points may be deleted, or their ordering changed by
          using the &button2; pop-up menu over the extension points field in
          the use case property tab.</para>

        <para>Having created an extension point, it will appear in the
          explorer (upper left quadrant of the user screen). Extension
          points are always shown in a sub-tree beneath their owning use
          case.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Associations</title>

      <para>To join a use case to an actor on the diagram use &button1; click
        on the association icon on the editing pane toolbar
        (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
        align="center" fileref="images/icons/association.gif"/>
        </imageobject></inlinemediaobject></guiicon>).
Then hold &button1; down
        at the use case, move to the actor and release &button1; (or
        alternatively start at the actor and finish at the use case).</para>

      <para>This will create a straight line between actor and use case. You
        can segment the line by holding down &button1; down on the line and
        moving before releasing. A vertex will be added to the line, which you
        can move by &button1; motion. A vertex can be removed by picking it up
        and sliding to one end of the line.</para>

      <para>Multiple associations can be added in one go, by using &button1;
        double click on the association icon. Each subsequent &button1;
        down/motion/release sequence will join an actor to a use case. Use
        &button1; on the select icon
        (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
        align="center" fileref="images/icons/select.gif"/>
        </imageobject></inlinemediaobject></guiicon>) to stop adding
        associations.</para>

      <para>It is also possible to add associations using small
        <quote>handles</quote> that appear to the left and right of a use case
        or actor when it is selected and the mouse is over it. Dragging the
        handle from a use case to an actor will create an association to that
        actor (and similarly by dragging a handle from an actor to a use
        case).</para>

      <para>Dragging a handle from a use case into empty space will create a
        new actor to go on the other end. Similarly dragging a handle from an
        actor into empty space will create a new use case.</para>

      <para>It is possible to give an association a name, describing the
        relationship of the actor to the use case, although this is not usually
        necessary. This is done through the property tab of the
        association. Such a name appears alongside the association near its
        center.</para>

      <!-- How to put arrows on the associations -->

      <sect3 id="s3.tut.req_argo_navigation">
        <title>Setting Navigation</title>
        
        <para>There are two ways of setting the navigation of an
          association.</para>

        <orderedlist>
          <listitem><para>Use &button2; click on the association to bring up a
            context-sensitive pop-up menu. The <literal>Navigability</literal>
            sub-menu has options for bidirectional navigation (the default,
            with no arrows) and for navigability actor&rarr;use case and use
            case&rarr;actor.</para></listitem>

          <listitem><para>Use &button1; to select the association and select
            its property tab in the details pane. This shows a field named
            <literal>Association Ends:</literal>, with entries for each end
            labeled by the actor or use case name and its
            multiplicity. Select the end that should be at the tail of the
            arrow with &button1; click. This brings up the property tab for the
            association end. Use &button1; click to uncheck the
            <literal>Navigability</literal> box.</para>

          <note><para>This may seem counter-intuitive, but in fact associations
            by default are navigable in both directions (when no arrows are
            shown). This process is <emphasis>turning off</emphasis> navigation
            at one end, rather than turning it on at the
            other.</para></note></listitem>
        </orderedlist>

        <para>You will see it is possible to give an association end a name in
          its property tab. This name will appear at that end of the
          association, and can be used to indicate the
          <emphasis>role</emphasis> being played by an actor or use case in an
          association.</para>

        <para>For example a time management system for a business may have use
          cases for completing time sheets and for signing off time sheets. An
          employee actor may be involved in both, one as an employee, but the
          other in a role as manager.</para>
      </sect3>

      <!-- How to set multiplicity -->

      <sect3>
        <title>Setting multiplicity</title>

        <para>There are two ways of setting multiplicity at the end of an
          association.</para>

        <orderedlist>
          <listitem><para>&Button2; click over the end of an association will
            cause a context sensitive pop-up menu to appear with a sub-menu
            labeled <literal>Multiplicity</literal>. This allows you to select
            from <literal>1</literal> (the default), <literal>0..1</literal>,
            <literal>0..*</literal> and
            <literal>1..*</literal>.</para></listitem>

          <listitem><para>Bring up the property sheet for the association end
            as described for setting navigation (see the second option in <xref
            linkend="s3.tut.req_argo_navigation"/>). A drop down menu gives a
            range of multiplicity options that may be
            selected.</para></listitem>
        </orderedlist>

        <para>The second of these two approaches has a wider range of options,
          although &argouml; does not currently allow the user to set an
          arbitrary multiplicity.</para>

        <note><para>&argouml; always shows multiplicities as a range, even when
          the ends of the range are the same (when it could be shown as a
          single number), or the range is <literal>0..*</literal> (when it
          could be shown as <literal>*</literal>).</para></note>
      </sect3>
    </sect2>

    <sect2>
      <title>Hierarchical Use Cases</title>

      <sect3>
        <title>Includes</title>

        <para>The procedure for adding an include relationship is the same as
          that for adding an association, but using the include icon from the
          editing pane toolbar
          (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
          align="center" fileref="images/icons/include.gif"/>
          </imageobject></inlinemediaobject></guiicon>) to join two use
          cases.</para>

        <para>Since include relationships are directional the order in which
          the two ends are selected is important. The
          <emphasis>including</emphasis> (main) use case should be selected
          first (&button1; down) and the <emphasis>included</emphasis>
          (subsidiary) use case second (&button1; release).</para>

        <para>It is possible to name include relationships using the property
          tab, but this is rarely done, and will not be displayed on the use
          case diagram.</para>
      </sect3>
       
      <sect3>
        <title>Extends</title>

        <para>The procedure for adding an extend relationship is the same as
          that for adding an include relationship, but using the extend icon
          from the editing pane toolbar
          (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
          align="center" fileref="images/icons/extend.gif"/>
          </imageobject></inlinemediaobject></guiicon>) to join two use
          cases.</para>

        <para>As with include relationships, the order of selection matters. In
          this case, the <emphasis>extending</emphasis> (subsidiary) use case
          should be selected first (&button1; down) and the
          <emphasis>extending</emphasis> (main) use case second (&button1;
          release).</para>

        <note><para>This is the reverse of the include relationship, but
          reflects the way that designer's tend to think. The fact that the
          extend icon's arrow points upward (the opposite of the include icon)
          should help remind you of this.</para></note>

        <para>To set a condition for the extend relationship, select the extend
          relationship in the editing pane (&button1; click) and then bring up
          its property tab in the details pane ((&button1; click on the
          tab). The text of the condition may be typed in the
          <literal>Condition</literal> field. Long conditions may be split over
          several lines if desired. The condition is displayed under the
          <literal>&laquo;extend&raquo;</literal> label on the diagram.</para>

        <para>It is possible to name extend relationships using the property
          tab, but this is rarely done, and will not be displayed on the use
          case diagram.</para>
      </sect3>

      <sect3>
        <title>Generalization</title>

        <para>The procedure for adding generalizations is the same as for
          adding extend relationships, but using the generalization icon from
          the editing pane toolbar
          (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
          align="center" fileref="images/icons/generalization.gif"/>
          </imageobject></inlinemediaobject></guiicon>).</para>

        <para>Since generalization is a directed relationship, the order of
          selection matters. The specialized use case should be selected first
          (&button1; down) and the generalized second (&button1;
          release).</para>

        <para>It is also possible to add generalizations using small
          <quote>handles</quote> that appear to the top and bottom of a use
          case when it is selected. Dragging the handle at the top to another
          use case will create a generalization. The original use case is
          the specializing end, and the use case to which the handle was
          dragged will be the generalizing end. Dragging into empty space will
          create a new use case to be the generalizing end.</para>

        <para>Similarly dragging on the bottom handle will create a
          generalization in which the original use case is the
          <emphasis>generalizing</emphasis> end.</para>

        <para>Generalization is also permitted between actors, although its use
          is beyond the scope of this tutorial. Unlike use cases there are no
          generalization handles on actors, so generalizations must be created
          using the toolbar icon.</para>

        <para>
It is possible to name generalization relationships using the property
          tab, but this is rarely done. If a name is provided, it will be
          displayed on the use case diagram.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Stereotypes</title>

      <para>UML has the concept of <emphasis>stereotyping</emphasis> as a way
        of extending the basic notation. It may prove useful for example to
        model a problem at both the business level and the engineering
        level. For both of these we will need use cases, but the use cases at
        the business level hold a different sort of information to those at the
        engineering level. Very likely they use different language and notation
        in their underlying use case specifications.</para>

      <para><emphasis>Stereotypes</emphasis> are used to label UML artifacts
        such as use cases, to indicate that they belong to a certain
        category. Such labels are shown in guillemots
        (<literal>&laquo;&raquo;</literal>) above the name of the artifact on
        the diagram. The UML standard defines a number of standard stereotypes,
        and the user may be define more of their own.</para>

      <para>You will see that &argouml; has a drop down selector,
        <literal>Stereotype</literal> on every property tab. This is populated
        with the standard stereotypes, to which you may add your own user
        defined ones.</para>

      <para>The details of stereotyping is beyond the scope of this
        tutorial. The reference manual (see <xref
        linkend="s1.ref.stereotype"/>) documents the support provided in
        &argouml;.</para>

      <warning><para>&argouml; is missing a few of the standard UML
        stereotypes. In addition not all artifacts will actually display the
        stereotype on the diagram. At present this includes use cases and
        actors.</para></warning>
    </sect2>

    <sect2>
      <title>Documentation</title>

      <para>&argouml; has some simple documentation facilities associated with
        artifacts on a diagram. In general these should be used only to record
        the location of material in documents that can be handled by a
        mainstream editor or word processor, not the actual documentation
        itself.</para>

      <para>Documentation for a particular artifact is recorded through the
        documentation tab in the details pane (the quadrant of the user screen
        at the bottom right).</para>

      <para>In addition annotation may be added to diagrams using the text icon
        on the editing pane toolbar
        (<guiicon><inlinemediaobject><imageobject><imagedata format="GIF"
        align="center" fileref="images/icons/text.gif"/>
        </imageobject></inlinemediaobject></guiicon>).</para>

      <para>The recommendation is that a use case diagram should use the
        documentation tab of actors to record information about the actor, or
        if the actor is complex to refer to a separate document that holds
        information about the actor.</para>

      <para>The documentation tab of use cases should record the location of
        the use case specification. The information in a use case specification
        (for all but the simplest use cases) is too complex to be placed
        directly in the tab.</para>

      <para>The project should also have a separate vision document and
        supplementary requirements specification. A text annotation on diagrams
        may be used to refer to these if the user finds this helpful.</para>

      <warning><para>The documentation tab includes a
        <literal>Deprecated</literal> check-box. The state of this flag is not
        preserved over save and load in the current release of
        &argouml;</para></warning>
    </sect2>

    <!-- How to add other annotation -->

    <sect2>
      <title>System Boundary Box</title>

      <para>&argouml; provides a series of tools to provide arbitrary graphical
        annotation on diagrams (we have already mentioned the text tool). These
        are found at the right hand end of the editing pane toolbar and are
        fully documented in the reference manual (see <xref
        linkend="ch.ref.editpane"/>).</para>

      <para>The rectangle tool can be used to draw the boundary box. Use the
        &button2; context sensitive <literal>Ordering</literal> pop-up menu to
        place it behind everything else. However there is no way to change its
        fill color from the default white. You may therefore prefer to draw
        the boundary box as four lines. This is the method used for the
        diagrams in this chapter.</para>

      <note><para>The editing pane in &argouml; has a grid to which objects
        snap to aid in drawing. The size of this grid and its effect may be
        altered through the <literal>View</literal> menu (using <literal>Adjust
        Grid</literal> and <literal>Adjust Grid Snap</literal>). This is
        described fully in the reference manual (see <xref
        linkend="ch.ref.menu"/>).</para></note>
    </sect2>
  </sect1>

  <!-- The Case Study will show at least some of these features -->

  <sect1>
    <title>Case Study</title>

    <sect2>
      <title>Vision Document</title>
      <para>
A vision document contains more than those things needed for
the modelling effort.
It also contains financial and scheduling pertinent information.
The following sections are those parts of the Vision Document
spelled out in section
<xref linkend="s2.tut.vision_document"/> above.
In practice this format need not be followed religiously, but
is used here for consistency.
</para>

      <sect3>
        <title>Summary</title>
        <para>
The company wishes to produce and market a line of ATM devices.
The purpose of this project is to produce the hardware and
the software to drive it that are both maintainable and robust.
</para>
      </sect3>

      <sect3>
        <title>Goals</title>
        <para>
To produce better designed products based on newer
technology.
Follow the MDA philosophy of the OMG by producing first
a Platform Independent Model (PIM).
As current modeling technology does not admit of
maintaining the integrity of the connection between the 
PIM and Platform Specific Models (PSMs), the PIM will
become comparatively stable before the first iteration of
the PSM is produced.
The software platform will be Java technology.
The system will use a simple userid (from ATM card) and
password (or PIN) mechanism.
</para>
      </sect3>

      <sect3>
        <title>Market Context</title>
        <para>
Equipment currently on the market is based on older
technology for both hardware and software.
This technology has not reached the end of its
useful life, making it unlikely that the vendors of that
gear are going to update it in the near future.
On the other hand newer technology is available
that would put us at a competitive advantage if implemented
now.
</para>
      </sect3>

      <sect3>
        <title>Stakeholders</title>

        <para>
Among the stakeholders for this system are the Engineering
Department, the Maintenance Department, and the Central
Computer Facility.
The full list of these stakeholders and the specific
individuals representing them are.
</para>

        <itemizedlist>
          <listitem>
            <para>
<emphasis>Engineering</emphasis>. &nbsp;Bunny, Bugs
</para>
          </listitem>
          <listitem>
            <para>
<emphasis>Maintenance</emphasis>. &nbsp;Hardy, Oliver
</para>
          </listitem>
          <listitem>
            <para>
<emphasis>Computer Facility</emphasis>. &nbsp;Laurel, Stanley
            </para>
          </listitem>
          <listitem>
            <para>
<emphasis>Chief Executive Officer</emphasis>. &nbsp;Hun, Atilla The
            </para>
          </listitem>
          <listitem>
            <para>
<emphasis>Marketing</emphasis>. &nbsp;Harry, Oil Can
            </para>
          </listitem>
        </itemizedlist>

      </sect3>

      <sect3>
        <title>Key Features</title>

        <para>
Cash deposit, cash withdrawal, and account inquiries by
customers.
Customers include people who have accounts at the owning
bank as well as people who wish to make withdrawals from
accounts in other banks or from credit card accounts.
</para>

        <para>
Maintenance of the equipment by the bank's engineers.
This action may be initiated by the engineer on a routine
basis.
It may also be initiated by the equipment which can call
the engineer when it detects an internal fault.
</para>

        <para>
Unloading of deposits and loading of cash by officials
of the local bank branch.
These actions occur either on a scheduled basis or when the
central computer determines that the cash supply is low or
the deposit receptacle is liable to be getting full.
</para>

        <para>
An audit trail for all activities will be maintained and
sent periodically to the bank's central computer.
It will be possible for the maintenance engineer to make 
a copy of the audit trail for sneaker net communications
with the central computer.
</para>

        <para>
Both dialup and leased line support will be provided.
The ATM will continue to provide services to customers when
communications with the central computer is not available.
</para>

      </sect3>

      <sect3>
        <title>Constraints</title>
        <para>
The project must be completed within nine months.
It must cost no more than 1,750,000 USD excluding
production costs.
Components may be contracted out, but the basic
architecture as well as the infrastructure will be designed
in house.
Close liaison must be maintained between the software
development and the design, development and production of
the hardware.
Neither the hardware nor the software shall be considered
the independent variable, but rather they shall be
considered coequal.
</para>
      </sect3>

      <sect3>
        <title>Appendix</title>

        <para>
The following are the actors that directly support this
vision.
Additional actors may be identified later that are needed
to support this or that technology.
They should not be added to this list unless they are
deemed to directly support the vision as described in this
document.
</para>

        <itemizedlist>
          <listitem><para>Central Computer</para></listitem>
          <listitem><para>Customer</para></listitem>
          <listitem><para>Local Branch Official</para></listitem>
          <listitem><para>Maintenance Engineer</para></listitem>
        </itemizedlist>

        <para>
The following are the use cases that directly support this vision.
Additional use cases may be identified later that are
needed to support this or that technology or to support the
use cases listed here.
They should not be added to this list unless they are
deemed to directly support the vision as described in this
document.
</para>

        <itemizedlist>
          <listitem><para>Audit</para></listitem>
          <listitem><para>Customer Uses Machine</para></listitem>
          <listitem><para>Maintain Machine</para></listitem>
        </itemizedlist>

      </sect3>

    </sect2>

    <sect2>
      <title>Identifying Actors and Use Cases (To be written)</title>

      <remark>To be written&hellip;</remark>
    </sect2>

    <sect2>
      <title>Associations (To be written)</title>

      <remark>To be written&hellip;</remark>
    </sect2>

    <sect2>
      <title>Advanced Diagram Features (To be written)</title>

      <remark>To be written&hellip;</remark>
    </sect2>

    <sect2>
      <title>Use Case Specifications (To be written)</title>

      <remark>To be written&hellip;</remark>
    </sect2>

    <sect2>
      <title>Supplementary Requirements Specification (To be written)</title>

      <remark>To be written&hellip;</remark>
    </sect2>
  </sect1>
</chapter>

<!-- Local stuff for Emacs - please do not delete

Local Variables:
mode: xml
sgml-doctype: "argomanual.xml"
sgml-parent-document: ("argomanual.xml" "chapter" nil)
sgml-validate-command: "nsgmls -wxml -sv ../docbook-setup/xml.dcl \
  argomanual.xml"
End:

-->
